# v0.5 — Public Release & Foundation — Detailed Plan

## Overview

**Goal:** Ship-ready quality, public launch, embedding-first semantic engine, and foundational improvements for everything that follows.

**6 Phases**, ordered by dependency:
1. Quality & Polish (no dependencies)
2. Embedding-First Semantic Engine (foundational — phases 3-6 benefit from this)
3. Value Validator Hardening (depends on phase 2 architecture)
4. Shareable Links (independent)
5. Documentation & Landing (depends on phases 1-4 being mostly stable)
6. Launch Prep (depends on all above)

**Phases 1 and 2 can run in parallel.** Phase 3 depends on phase 2's architecture being in place. Phase 4 is independent. Phases 5 and 6 are sequential and come last.

---

## Phase 1: Quality & Polish

**Goal:** Fix known tech debt, improve error/loading/empty states.

### Tasks

#### 1.1 Remove orphaned files
- Delete `src/components/loading/SkeletonDetail.tsx` (15 lines, never imported)
- Verify no other orphaned files exist

#### 1.2 Fix Buffer polyfill
- Current: `src/main.tsx` imports Buffer from `buffer` npm package and assigns to `globalThis`
- Current: `vite.config.ts` aliases `buffer` and lists it in optimizeDeps
- The polyfill is needed for `@apidevtools/swagger-parser` and the CORS proxy middleware
- **Action:** Keep the polyfill but isolate it — move the import into a dedicated `src/polyfills.ts` file imported at the top of `main.tsx`, with a comment explaining why it exists
- **Action:** Add `buffer` to the "intentional dependencies" section of documentation

#### 1.3 Improve error states
- **Files:** `src/App.tsx`, `src/hooks/useAPIFetch.ts`
- Audit current error handling for fetch failures, CORS errors, invalid JSON, timeout
- Ensure every error state has a clear user-facing message and a recovery action (retry, try different URL, check CORS)
- Add error boundary component for unexpected render crashes

#### 1.4 Improve loading states
- **Files:** `src/components/loading/`
- Audit current skeleton loading (SkeletonTable exists, SkeletonDetail was orphaned)
- Add loading skeletons for card list, gallery, and detail views
- Ensure loading→content transition is smooth (no layout shift)

#### 1.5 Improve empty states
- When an API returns an empty array `[]` or empty object `{}`
- When all fields are null/undefined
- When a search/filter returns no results
- Each should show a helpful message, not a blank screen

#### 1.6 Run full test suite, fix any failures
- `npm run test:run` — verify all 449 tests pass
- Fix any that are broken

**Files touched:**
- `src/components/loading/SkeletonDetail.tsx` (delete)
- `src/main.tsx` (polyfill isolation)
- `src/polyfills.ts` (new, small)
- `src/App.tsx` (error boundary)
- `src/components/loading/` (new skeletons)
- `src/components/` (empty states)

---

## Phase 2: Embedding-First Semantic Engine

**Goal:** Replace regex name matching with pre-computed embedding similarity as the default classification mechanism. Retain regex as optional fallback.

This is the most complex phase. Broken into sub-phases.

### 2A: Build-Time Embedding Generation Script

**Goal:** Create a script that generates the static embedding data shipped with the app.

#### 2A.1 Define category vocabulary
- Create `scripts/categories.json` — a JSON file mapping each of the 21 semantic categories to their synonym lists across EN/ES/FR/DE/PT
- Categories: price, currency_code, sku, quantity, email, phone, uuid, name, address, url, image, video, thumbnail, avatar, rating, tags, status, title, description, date, timestamp
- Each category gets 10-30 synonyms across 5 languages
- Estimated total: ~300-500 unique tokens

Example structure:
```json
{
  "price": {
    "synonyms": ["price", "cost", "amount", "fee", "total", "subtotal", "charge", "rate", "precio", "costo", "importe", "prix", "cout", "montant", "preis", "kosten", "betrag", "preco", "valor", "custo"],
    "description": "Monetary amounts and pricing"
  },
  "email": {
    "synonyms": ["email", "mail", "e-mail", "correo", "correo_electronico", "courriel", "adresse_email", "e_mail_adresse", "correio_eletronico"],
    "description": "Email addresses"
  }
}
```

#### 2A.2 Create embedding generation script
- Create `scripts/generate-embeddings.mjs`
- Dependencies: `@huggingface/transformers` (dev dependency only — not shipped to browser)
- Uses `Xenova/multilingual-e5-small` model with `dtype: 'q8'` (118 MB download, cached)
- **Prefix:** All inputs prefixed with `"query: "` (required by E5 model training)
- **Process:**
  1. Read `scripts/categories.json`
  2. Embed all unique tokens in batches of 32
  3. Compute category centroids (average + L2 normalize)
  4. Quantize to 6 decimal places
  5. Write to `src/data/category-embeddings.json`
- **Performance:** ~15-30 seconds for 500 tokens on M1/M2 MacBook
- Add npm script: `"generate-embeddings": "node scripts/generate-embeddings.mjs"`

#### 2A.3 Generate the initial embedding data
- Run the script to produce `src/data/category-embeddings.json`
- Verify the file: ~21 centroids × 384 dims ≈ **~44 KB minified, ~20 KB gzipped**
- Commit the generated JSON file to the repo (it's a build artifact but small enough to version)

### 2B: Runtime Embedding Classifier

**Goal:** Implement the client-side classification logic that uses the pre-computed centroids.

#### 2B.1 Create embedding classifier module
- Create `src/services/semantic/embeddings.ts`
- **Exports:**
  - `classifyFieldName(fieldName: string): { category: SemanticCategory; score: number } | null`
  - `getEmbeddingSimilarity(fieldName: string, category: SemanticCategory): number`
- **Internals:**
  - `tokenizeFieldName(name: string): string[]` — splits on `_`, `-`, `.`, camelCase boundaries, lowercases
  - `lookupTokenEmbedding(token: string): number[] | null` — looks up in static table
  - `computeFieldEmbedding(tokens: string[]): number[] | null` — averages token embeddings, L2 normalizes
  - `dotProduct(a: number[], b: number[]): number` — cosine similarity (vectors are pre-normalized)
- **Data loading:** Import centroids from `src/data/category-embeddings.json` (bundled by Vite, ~44KB)
- **Threshold:** Return null if best score < configurable threshold (start at 0.65, tune later)

#### 2B.2 Create token embedding lookup
- The centroids alone handle category matching, but we also need per-token embeddings for runtime lookup
- **Option A (simpler):** Ship the full token embedding table (~300-500 tokens × 384 dims). At 6 decimal places: **~400-800 KB** JSON. This lets us look up any known token.
- **Option B (smaller):** Ship only centroids (~44 KB). For unknown field names, skip embedding and rely on value validators only.
- **Decision:** Start with Option A (ship token table). The ~400-800 KB cost is acceptable (user confirmed). We can optimize later.
- Update `scripts/generate-embeddings.mjs` to also export the token embedding table
- Output: `src/data/token-embeddings.json`

#### 2B.3 Handle unknown tokens
- If a token isn't in the lookup table, skip it
- If ALL tokens in a field name are unknown, embedding signal returns null (no score)
- The scorer falls back to type constraint + value validator only
- Log a debug warning for unknown tokens (helps identify vocabulary gaps)

### 2C: Integrate Embeddings into Scoring Pipeline

**Goal:** Wire the embedding classifier into the existing multi-signal scorer as the default name-matching signal.

#### 2C.1 Create detection strategy abstraction
- Create `src/services/semantic/strategies.ts`
- Define interface:
  ```typescript
  interface NameMatchStrategy {
    name: 'embedding' | 'regex'
    matchName(fieldName: string, category: SemanticCategory): number  // returns 0.0-1.0
  }
  ```
- Implement `EmbeddingStrategy` — uses `getEmbeddingSimilarity()` from 2B.1
- Implement `RegexStrategy` — wraps the existing `namePatterns` regex matching logic
- Export a `getActiveStrategy(): NameMatchStrategy` function that checks configuration

#### 2C.2 Modify scorer to use strategy
- **File:** `src/services/semantic/scorer.ts`
- Current: `calculateConfidence()` directly iterates `pattern.namePatterns` to find best regex match
- New: `calculateConfidence()` calls `strategy.matchName(fieldName, pattern.category)` to get the name signal score
- The strategy returns a 0.0-1.0 score which gets weighted by 0.40 (same as current name pattern weight)
- The rest of the scoring (type constraint, value validators, format hints) stays unchanged

#### 2C.3 Add configuration flag
- **File:** `src/store/configStore.ts` (or new semantic config)
- Add setting: `semanticEngine: 'embedding' | 'regex'` (default: `'embedding'`)
- This flag controls which `NameMatchStrategy` is used
- Exposed in settings UI later (phase 5), but functional from the start

#### 2C.4 Adjust weight distribution
- Current weights: name 0.40, type 0.20, value 0.25-0.30, format 0.10-0.15
- New weights: embedding 0.40, type 0.20, value 0.30, format 0.10
- **Critical fix:** When no OpenAPI spec is present, exclude format hints from `maxPossibleScore`
  - Current bug: format hint weight (0.10-0.15) is always in the denominator, deflating ALL scores by 10-18% for non-OpenAPI APIs
  - Fix: Only add format hint weight to `maxPossibleScore` if `openapiHints` is provided

### 2D: Update Tests

#### 2D.1 Create embedding classifier tests
- Create `src/services/semantic/embeddings.test.ts`
- Test token splitting: `"correo_electronico"` → `["correo", "electronico"]`
- Test camelCase splitting: `"firstName"` → `["first", "name"]`
- Test dot notation: `"user.email"` → `["user", "email"]`
- Test known token lookup: `"price"` returns a valid embedding
- Test unknown token: `"xyzabc123"` returns null
- Test classification: `"precio"` → `{ category: "price", score: > 0.7 }`
- Test multilingual: `"bewertung"` → `{ category: "rating" }`, `"correo_electronico"` → `{ category: "email" }`
- Test ambiguous: `"id"`, `"type"`, `"value"` — should either return low score or null

#### 2D.2 Update scorer tests
- **File:** `src/services/semantic/scorer.test.ts`
- Update tests to work with both strategies (embedding and regex)
- Add tests verifying the format hint weight fix
- Add tests verifying the strategy switching configuration

#### 2D.3 Update detector tests
- **File:** `src/services/semantic/detector.test.ts`
- The multilingual tests (Spanish "precio"→price, French "prix"→price) should now pass with embedding strategy
- Add new multilingual tests: Portuguese "preco", German "bewertung", French "courriel"
- Ensure existing English tests still pass with embedding strategy
- Add tests for strategy fallback (regex mode still works)

#### 2D.4 Verify downstream tests still pass
- `src/services/selection/heuristics.test.ts` (1,447 lines) — these consume semantic results
- `src/services/analysis/grouping.test.ts` (542 lines)
- `src/services/analysis/importance.test.ts` (601 lines)
- Run full suite: `npm run test:run`

**Files created:**
- `scripts/categories.json`
- `scripts/generate-embeddings.mjs`
- `src/data/category-embeddings.json` (generated)
- `src/data/token-embeddings.json` (generated)
- `src/services/semantic/embeddings.ts`
- `src/services/semantic/strategies.ts`
- `src/services/semantic/embeddings.test.ts`

**Files modified:**
- `src/services/semantic/scorer.ts` (strategy integration, weight fix)
- `src/services/semantic/scorer.test.ts`
- `src/services/semantic/detector.test.ts`
- `src/store/configStore.ts` (semantic engine config flag)
- `package.json` (dev dependency: @huggingface/transformers, npm script)

**Files NOT modified (kept as-is):**
- `src/services/semantic/patterns/` (all 5 pattern files — regex stays intact)
- `src/services/semantic/detector.ts` (calls scorer, which handles strategy internally)
- `src/services/semantic/cache.ts` (cache key includes strategy in hash)
- `src/services/semantic/types.ts` (no type changes needed)
- `src/services/semantic/index.ts` (public API unchanged)

---

## Phase 3: Value Validator Hardening

**Goal:** Fix the weak validators identified in the audit so they carry their 0.30 weight meaningfully.

**Depends on:** Phase 2 architecture being in place (weights rebalanced).

### Tasks

#### 3.1 Fix status validator
- **File:** `src/services/semantic/patterns/engagement.ts`
- **Current:** Hardcoded list of 20 English words (`active|inactive|pending|...`)
- **New approach:** Heuristic-based detection:
  - String value length < 30 characters
  - Low cardinality across samples (if multiple values, check distinct count is small)
  - Contains only alphabetic characters, underscores, hyphens (no numbers, no spaces in the middle)
  - Optionally: check against expanded multilingual enum (add ES/FR/DE/PT equivalents)
- **Test:** Spanish `"activo"`, French `"actif"`, German `"aktiv"` should all pass

#### 3.2 Fix rating validator
- **File:** `src/services/semantic/patterns/engagement.ts`
- **Current:** `value >= 0 && value <= 100` (matches age, percentage, temperature)
- **New:** `value >= 0 && value <= 10` (most rating systems are 1-5 or 1-10)
  - Also check: if all sample values have same decimal precision (e.g., all `.5` increments), boost confidence
  - Also check: if values cluster in a small range (e.g., 3.5-4.8), more likely ratings than arbitrary numbers
- **Test:** `4.5` should pass, `75` should fail, `0` should pass

#### 3.3 Fix SKU validator
- **File:** `src/services/semantic/patterns/commerce.ts`
- **Current:** Alphanumeric 4-20 chars (matches almost anything)
- **New:** Require mixed content — must contain both letters AND numbers, or contain a dash/hyphen separating segments
  - Pattern: `/^(?=.*[a-zA-Z])(?=.*\d)[a-zA-Z0-9\-]{4,20}$/` or segment pattern like `ABC-123`
  - Pure alphabetic strings (like usernames) should fail
  - Pure numeric strings (like IDs) should fail
- **Test:** `"SKU-12345"` passes, `"abc123"` passes, `"hello"` fails, `"12345"` fails

#### 3.4 Fix name/title/description/address validators
- **Files:** `src/services/semantic/patterns/identity.ts`, `src/services/semantic/patterns/engagement.ts`
- **Current:** `isNonEmptyString` or `isString` (matches ANY string)
- **New discriminating validators:**
  - **Name:** Contains 1-5 words, each capitalized or all-lowercase, no special characters except hyphens/apostrophes, length 2-100. Check: `"John O'Brien"` passes, `"<html>..."` fails, `"12345"` fails
  - **Title:** 2-200 characters, contains at least 2 words OR is a single capitalized word, not a URL, not an email
  - **Description:** Length > 50 characters (raised from 20), contains spaces (is a sentence/paragraph, not a code string)
  - **Address:** Contains at least one number AND at least one word, or contains known address tokens (st, ave, rd, blvd, street, calle, rue, str)
- **Test each with clear positive and negative cases**

#### 3.5 Fix format hint weight calculation
- **File:** `src/services/semantic/scorer.ts`
- **Current bug:** `maxPossibleScore` always includes format hint weights even when no OpenAPI hints are provided
- **Fix:** Only add format hint weights to `maxPossibleScore` when `openapiHints` parameter is truthy
- **Impact:** All non-OpenAPI APIs get a ~10-18% confidence boost (because the denominator shrinks)
- **Test:** Verify that a perfect name+type+value match yields confidence ~1.0 when no format hints

#### 3.6 Update tests for all validator changes
- Update existing tests in `scorer.test.ts` and `detector.test.ts`
- Add negative test cases for each tightened validator
- Verify no regressions in downstream heuristics tests

**Files modified:**
- `src/services/semantic/patterns/commerce.ts` (sku validator)
- `src/services/semantic/patterns/identity.ts` (name, address validators)
- `src/services/semantic/patterns/engagement.ts` (status, rating, title, description validators)
- `src/services/semantic/scorer.ts` (format hint weight fix)
- `src/services/semantic/scorer.test.ts`
- `src/services/semantic/detector.test.ts`

---

## Phase 4: Shareable Links (Public)

**Goal:** Generate client-side shareable URLs that encode API endpoint + view configuration.

**Independent of phases 2-3.** Can run in parallel.

### Tasks

#### 4.1 Design URL encoding scheme
- Use URL hash fragment (`#`) to encode state (no server needed, no URL length limit from servers)
- Encode: API URL, active endpoint path, view configuration overrides, layout mode
- Format: `https://api2ui.dev/#/api=<encoded-url>&path=<path>&config=<base64-config>`
- Use `lz-string` or built-in `btoa` for compression (evaluate which is better for typical configs)
- Consider: max practical URL length (~2000 chars for sharing via chat/email, technically unlimited for hash)

#### 4.2 Implement URL state serialization
- **File:** Create `src/services/sharing/encoder.ts`
- `encodeShareableState(state: ShareableState): string` — produces the hash fragment
- `decodeShareableState(hash: string): ShareableState | null` — parses hash back to state
- `ShareableState` type: `{ apiUrl, endpointPath?, componentOverrides?, layoutMode? }`
- Handle missing/partial state gracefully (only apiUrl is required)

#### 4.3 Implement URL state hydration
- **File:** Create `src/services/sharing/hydrator.ts`
- On app load, check for hash fragment
- If present, decode and auto-load the API URL with saved configuration
- Apply component overrides from the shared state
- Navigate to the shared endpoint path if specified

#### 4.4 Add "Share" button to UI
- **File:** Modify `src/App.tsx` or create `src/components/ShareButton.tsx`
- Button visible in both View and Configure modes
- Clicking generates the shareable URL and copies to clipboard
- Show toast notification: "Link copied to clipboard"
- Optional: show a modal with the URL for manual copying

#### 4.5 Handle edge cases
- Sharing an API that requires authentication: show warning "This link won't work for others without credentials"
- Very large configurations: test URL length limits, consider compression
- Invalid/expired APIs: graceful error when shared link's API is down

#### 4.6 Tests
- Create `src/services/sharing/encoder.test.ts`
- Test encode/decode roundtrip for various states
- Test partial state (only apiUrl)
- Test with special characters in URLs
- Test with large configurations (many overrides)

**Files created:**
- `src/services/sharing/encoder.ts`
- `src/services/sharing/hydrator.ts`
- `src/services/sharing/encoder.test.ts`
- `src/components/ShareButton.tsx`

**Files modified:**
- `src/App.tsx` (share button integration, hash hydration on load)

---

## Phase 5: Documentation & Landing

**Goal:** Usage guide, example gallery, contributor guide, updated landing page.

**Depends on:** Phases 1-4 being mostly stable.

### Tasks

#### 5.1 Update README.md
- Project description matching the vision
- Quick start (paste a URL, see your data)
- Feature list (semantic detection, auth, component switching, shareable links)
- Example screenshots/GIFs
- Tech stack overview
- Contributing section (link to contributor guide)
- License (decide: MIT? Apache 2.0?)

#### 5.2 Create contributor guide
- `CONTRIBUTING.md`
- How to set up the dev environment
- How to run tests
- How to add new semantic categories (add to `scripts/categories.json`, run `generate-embeddings`)
- How to add new value validators
- How to add new rendering components
- Code style and conventions

#### 5.3 Update landing page examples
- **File:** `src/components/URLInput.tsx`
- Current: 4 examples (JSONPlaceholder users, single user, DummyJSON products, Petstore OpenAPI)
- Add: 1-2 more diverse examples showing semantic detection
  - Government/public API (e.g., NPI registry, clinical trials)
  - Non-English API example (if a stable one is available)
- Each example should showcase different features (tables, cards, detail views, auth)

#### 5.4 Add feature highlights to welcome screen
- **File:** `src/App.tsx`
- Current: Simple "Welcome to api2ui" with subtitle
- Add: Feature cards or bullet points below the URL input
  - "Semantic field detection — prices, dates, ratings auto-formatted"
  - "Works with OpenAPI specs — auto-discovers all endpoints"
  - "Shareable links — share your API view with a URL"
  - "Authentication support — API Key, Bearer, Basic Auth"

#### 5.5 Create usage guide
- Consider: in-app guide (tooltip tour) vs. external docs
- Start simple: a `/docs` page or GitHub wiki with screenshots
- Cover: URL input, component switching, configure mode, auth, sharing

**Files modified:**
- `README.md` (complete rewrite)
- `CONTRIBUTING.md` (new)
- `src/components/URLInput.tsx` (example updates)
- `src/App.tsx` (welcome screen enhancements)

---

## Phase 6: Launch Prep

**Goal:** Prepare for public release.

**Depends on:** All above phases complete.

### Tasks

#### 6.1 Version bump and changelog
- Update `package.json` version to `1.5.0`
- Create `CHANGELOG.md` with v0.5 highlights
- Tag git commit as `v0.5.0`

#### 6.2 Build verification
- `npm run build` — verify production build succeeds
- Check bundle size (report total JS, CSS, embedding data)
- Verify the embedding JSON is included in the build output
- Test the production build locally (`npm run preview`)

#### 6.3 Cross-browser testing
- Test in Chrome, Firefox, Safari (macOS), Edge
- Verify embedding classification works in all browsers
- Verify shareable links work cross-browser
- Verify auth flows work cross-browser

#### 6.4 GitHub release
- Create GitHub release with v0.5.0 tag
- Release notes summarizing the embedding engine, shareable links, validator improvements
- Attach build artifacts if applicable

#### 6.5 Deployment
- Deploy to hosting (Vercel/Netlify/GitHub Pages — decide)
- Verify production URL works
- Test shareable links with the production URL

#### 6.6 Launch materials
- Product Hunt listing draft
- Hacker News "Show HN" post draft
- Twitter/X announcement thread draft
- Key talking points: "paste any API URL, get an instant UI with semantic understanding"

---

## Dependency Graph

```
Phase 1 (Quality & Polish) ──────────────────────────────┐
                                                          ├── Phase 5 (Docs & Landing)
Phase 2 (Embedding Engine) ── Phase 3 (Validators) ──────┤
                                                          ├── Phase 6 (Launch)
Phase 4 (Shareable Links) ───────────────────────────────┘
```

- **Phases 1, 2, 4** can start in parallel
- **Phase 3** starts after phase 2 architecture is in place
- **Phase 5** starts after phases 1-4 are mostly complete
- **Phase 6** is the final sequential phase

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Embedding similarity thresholds need tuning | High | Medium | Start with conservative threshold (0.65), test with 10+ real APIs, adjust |
| Token vocabulary gaps (common field names not in lookup table) | Medium | Medium | Start with 300-500 tokens, add more based on real-world testing |
| Bundle size exceeds expectations | Low | Low | Token table is ~400-800KB; can switch to centroids-only (~44KB) if needed |
| Embedding quality for very short tokens ("id", "type") | Medium | Low | These are genuinely ambiguous — ok to fall back to value validators |
| Regex→embedding switch breaks existing tests | Medium | Medium | Strategy pattern allows testing both modes; keep regex as fallback |
| Shareable links hit URL length limits | Low | Low | Use hash fragment (no server limit) + compression |
| Format hint weight fix changes existing detection results | High | Medium | Expected — all non-OpenAPI detections get a ~10-18% confidence boost |

---

## Success Criteria

- [ ] All 449+ existing tests pass
- [ ] New embedding classifier tests pass for EN/ES/FR/DE/PT field names
- [ ] Spanish API (e.g., field names: precio, estado, descripcion, imagen) achieves HIGH confidence for all fields
- [ ] Portuguese API field names (preco, nome, endereco, telefone) achieve HIGH confidence
- [ ] Regex fallback mode still works when configured
- [ ] Shareable links encode/decode correctly cross-browser
- [ ] Production build succeeds with embedding data included
- [ ] Bundle size increase from embeddings is < 1 MB
- [ ] No regression in English API detection quality
- [ ] Documentation covers setup, usage, and contributing

---

*Plan created: 2026-02-14*
*Estimated scope: 6 phases, ~25-30 tasks*
*Key dependency: @huggingface/transformers (dev only, MIT license)*
*Shipping target: embedding data ~44KB centroids + ~400-800KB token table*
