---
phase: 08-enhanced-details
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/renderers/DetailRenderer.tsx
  - src/components/renderers/HorizontalCardScroller.tsx
autonomous: true

must_haves:
  truths:
    - "Detail view shows hero image at top when an image field is detected"
    - "Detail fields display in two-column layout on desktop, single column on mobile"
    - "Related fields are visually grouped with spacing hierarchy"
    - "Nested arrays render as horizontally scrollable card strips"
  artifacts:
    - path: "src/components/renderers/DetailRenderer.tsx"
      provides: "Enhanced detail layout with hero image, two-column grid, field grouping"
      contains: "grid-cols-1 md:grid-cols-2"
    - path: "src/components/renderers/HorizontalCardScroller.tsx"
      provides: "Horizontal card scroller for nested arrays"
      contains: "scrollSnapType"
  key_links:
    - from: "src/components/renderers/DetailRenderer.tsx"
      to: "src/utils/imageDetection.ts"
      via: "getHeroImageField import"
      pattern: "getHeroImageField"
    - from: "src/components/renderers/DetailRenderer.tsx"
      to: "src/components/renderers/HorizontalCardScroller.tsx"
      via: "import for nested array rendering"
      pattern: "HorizontalCardScroller"
---

<objective>
Enhance the DetailRenderer to produce polished product-page-style detail views with hero images at top, responsive two-column field layouts, visual field grouping, and horizontal card scrollers for nested arrays.

Purpose: Transform detail views from plain key-value lists into visually rich, well-organized layouts that feel like real product/profile pages. This covers requirements DTL-01, DTL-02, and DTL-03.
Output: Enhanced DetailRenderer.tsx and new HorizontalCardScroller.tsx component.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-enhanced-details/08-RESEARCH.md

@src/components/renderers/DetailRenderer.tsx
@src/utils/imageDetection.ts
@src/types/schema.ts
@src/components/DynamicRenderer.tsx
@src/utils/itemLabel.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance DetailRenderer with hero image and two-column layout</name>
  <files>src/components/renderers/DetailRenderer.tsx</files>
  <action>
Modify DetailRenderer to produce a polished detail layout. Keep ALL existing functionality intact (field ordering, visibility, Configure mode with FieldControls/DraggableField/SortableFieldList, context menus, popover state, cross-navigation events). The changes are to the VIEW MODE layout structure only.

**Hero Image (DTL-01):**
- Import `getHeroImageField` from `../../utils/imageDetection` (already imports `isImageUrl` from same file)
- After computing `visibleFields`, detect hero image: `const heroImage = getHeroImageField(obj, allFields)`
- At the top of the VIEW mode render output (before the field grid), render the hero image full-width if detected: `<div className="w-full"><img src={heroImage.url} alt="Detail hero" loading="lazy" className="w-full max-h-96 object-cover rounded-lg border border-gray-200" onError={(e) => { e.currentTarget.style.display = 'none' }} /></div>`
- When rendering fields, skip the hero image field to avoid duplication (filter it out by checking `fieldName !== heroImage?.fieldName`)

**Two-Column Layout (DTL-02):**
- In VIEW mode only, replace the current `space-y-3` container with CSS Grid: `grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4`
- Primitive fields each take one grid column
- Full-width elements (image fields, nested objects/arrays) use `md:col-span-2`
- Keep the existing `grid-cols-[auto_1fr]` for individual field label+value pairs WITHIN each grid cell
- CONFIGURE mode layout stays unchanged (SortableFieldList needs single-column for drag-drop)

**Visual Field Grouping (DTL-02):**
- Add a helper: `function isMetadataField(name: string): boolean` that matches `/created|updated|modified|timestamp|date/i`
- Partition `visibleFields` into 4 groups: `primaryFields` (using existing `isPrimaryField`), `imageFields` (primitive + isImageUrl), `metaFields` (isMetadataField), and `regularFields` (everything else that's primitive and not primary/meta/image)
- Nested fields (object/array kind) go into `nestedFields`
- Render order in the grid: primary fields (full-width, with bottom border separator) -> regular fields (two-column) -> image fields (full-width) -> nested fields (full-width) -> metadata group (full-width section with "Metadata" heading)

**VIEW mode structure:**
```
<div className="space-y-6 border border-border rounded-lg p-4">
  {heroImage && <div className="w-full">...</div>}
  <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
    {primaryFields.map(renderPrimitiveField)}
    {primaryFields.length > 0 && <div className="md:col-span-2 border-b border-gray-200" />}
    {regularFields.map(renderPrimitiveField)}
    {imageFields.map(field => <div className="md:col-span-2">{renderImageField(field)}</div>)}
    {nestedFields.map(field => <div className="md:col-span-2">{renderNestedField(field)}</div>)}
    {metaFields.length > 0 && (
      <div className="md:col-span-2 border-t border-gray-200 pt-4">
        <h3 className="text-xs uppercase tracking-wider text-gray-500 font-semibold mb-3">Metadata</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-2">
          {metaFields.map(renderPrimitiveField)}
        </div>
      </div>
    )}
  </div>
</div>
```

Extract the field rendering logic into helper functions (renderPrimitiveField, renderImageField, renderNestedField) to keep the JSX clean. These helpers should reuse the existing rendering code (context menu handlers, FieldConfigPopover, typography hierarchy).

IMPORTANT: Do NOT remove any existing functionality. All context menu handlers, popover state, cross-navigation events, FieldControls, DraggableField, field ordering, visibility filtering must continue working exactly as before.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Run `npx vite build` to confirm successful build. Visually confirm in browser: load an API with image fields (e.g., JSONPlaceholder photos), click into a detail view, verify hero image shows at top and fields are in two columns on desktop.
  </verify>
  <done>
Detail views show hero image at top when present, fields display in responsive two-column grid (single column mobile, two columns desktop), fields are visually grouped (primary first, metadata last with heading), and all existing Configure mode functionality remains intact.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HorizontalCardScroller and wire into DetailRenderer</name>
  <files>
    src/components/renderers/HorizontalCardScroller.tsx
    src/components/renderers/DetailRenderer.tsx
  </files>
  <action>
**Create HorizontalCardScroller.tsx (new file):**

Create a component that renders an array of objects as a horizontally scrollable strip of mini-cards using CSS scroll-snap. No new dependencies needed.

```typescript
import type { TypeSignature, FieldDefinition } from '../../types/schema'
import { getHeroImageField } from '../../utils/imageDetection'
import { getItemLabel } from '../../utils/itemLabel'

interface HorizontalCardScrollerProps {
  items: unknown[]
  schema: TypeSignature  // The items schema (should be object kind)
  path: string
  depth: number
  label: string
}
```

Implementation:
- Guard: if `schema.kind !== 'object'`, return null
- Extract fields: `Array.from(schema.fields.entries())`
- Header: `<div className="text-sm text-gray-500 mb-2">{label} ({items.length})</div>`
- Outer container: `<div className="relative">` (for gradient overlay positioning)
- Scroll container: `<div className="overflow-x-auto scroll-smooth pb-2" style={{ scrollSnapType: 'x proximity' }}>` (use `proximity` not `mandatory` to avoid scroll-locking pitfall)
- Inner flex: `<div className="inline-flex gap-4 p-1">`
- Each card: `<div className="flex-none w-64 border border-border rounded-lg overflow-hidden shadow-sm hover:shadow-md transition-shadow" style={{ scrollSnapAlign: 'start' }}>`
  - Hero image if detected via `getHeroImageField(obj, fields)`: `<div className="w-full h-36 bg-gray-100"><img src={heroImage.url} alt={label} loading="lazy" className="w-full h-full object-cover" onError={(e) => { e.currentTarget.parentElement!.style.display = 'none' }} /></div>`
  - Body: `<div className="p-3"><div className="font-medium text-sm mb-1 truncate">{getItemLabel(item)}</div>`
  - Show first 3 primitive fields (skip hero field): `<div className="text-xs text-gray-600 truncate"><span className="font-medium">{formatLabel(fieldName)}:</span> {String(value)}</div>`
  - Format labels using same pattern as DetailRenderer: `fieldName.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())`
- Edge fade gradient (right side): `<div className="pointer-events-none absolute right-0 top-0 bottom-2 w-8 bg-gradient-to-l from-white to-transparent" />`

**Wire into DetailRenderer:**

Import `HorizontalCardScroller` in DetailRenderer.tsx.

In the nested field rendering section, add an alternative path for nested arrays of objects in VIEW mode:

When `fieldDef.type.kind === 'array'` AND `fieldDef.type.items.kind === 'object'` AND `Array.isArray(value)` AND `value.length > 0` AND `!isConfigureMode`:
- Render `<HorizontalCardScroller items={value as unknown[]} schema={fieldDef.type.items} path={fieldPath} depth={depth + 1} label={displayLabel} />`
- This replaces the Disclosure/DynamicRenderer for this specific case in view mode only

For all other nested fields (objects, arrays of primitives, empty arrays) AND all Configure mode rendering: keep the existing Disclosure + DynamicRenderer pattern unchanged.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Run `npx vite build` to confirm successful build. Test by loading an API that returns objects with nested arrays. Verify the nested array shows as a horizontally scrollable card strip in the detail view with scroll-snap behavior.
  </verify>
  <done>
HorizontalCardScroller.tsx exists and renders nested object arrays as horizontal card strips. DetailRenderer uses HorizontalCardScroller for nested arrays of objects in view mode, with scroll-snap behavior, hero images on cards, item labels, and edge fade gradient. Configure mode unchanged.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx vite build` completes successfully
3. Detail view with image fields shows hero image at top, full-width
4. Detail view fields show in two-column grid on desktop viewport
5. Detail view fields show in single column on mobile viewport
6. Primary fields (name/title) appear first with visual separation
7. Metadata fields (timestamps) appear last with "Metadata" heading
8. Nested arrays of objects show as horizontal card scroller
9. Horizontal scroller has scroll-snap behavior and edge fade gradient
10. Configure mode continues to work with drag-and-drop field ordering
</verification>

<success_criteria>
- DTL-01: Hero image renders at top of detail views when image field detected
- DTL-02: Two-column responsive layout with visual field grouping
- DTL-03: Nested arrays render as horizontal card scrollers
- All existing DetailRenderer functionality preserved (Configure mode, field ordering, visibility, context menus, popovers)
</success_criteria>

<output>
After completion, create `.planning/phases/08-enhanced-details/08-01-SUMMARY.md`
</output>
