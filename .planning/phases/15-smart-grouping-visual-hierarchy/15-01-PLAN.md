---
phase: 15-smart-grouping-visual-hierarchy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/appStore.ts
  - src/hooks/useSchemaAnalysis.ts
  - src/components/renderers/FieldRow.tsx
  - src/services/analysis/types.ts
autonomous: true

must_haves:
  truths:
    - "Grouping results from analyzeFields are stored in analysis cache alongside semantics, importance, and selection"
    - "FieldRow component renders fields with three-tier visual hierarchy (primary large/bold, secondary normal, tertiary small/muted)"
    - "Same field renders with identical styling regardless of rendering context (grouped vs ungrouped)"
  artifacts:
    - path: "src/components/renderers/FieldRow.tsx"
      provides: "Shared field rendering with importance-tier visual hierarchy"
      min_lines: 40
    - path: "src/store/appStore.ts"
      provides: "AnalysisCacheEntry with grouping field"
      contains: "grouping"
  key_links:
    - from: "src/hooks/useSchemaAnalysis.ts"
      to: "src/store/appStore.ts"
      via: "setAnalysisCache includes grouping from analyzeFields result"
      pattern: "grouping.*analysisResult"
    - from: "src/components/renderers/FieldRow.tsx"
      to: "src/services/analysis/types.ts"
      via: "imports ImportanceTier for tier-based styling"
      pattern: "ImportanceTier"
---

<objective>
Add grouping data to the analysis cache and create a shared FieldRow component with importance-tier visual hierarchy.

Purpose: The analysis pipeline already computes grouping results via `analyzeFields()`, but discards them before caching. This plan stores grouping in the cache so Plan 02 can render grouped accordion views. The shared FieldRow component ensures consistent three-tier visual hierarchy (primary/secondary/tertiary) across all detail view rendering modes.

Output: Updated cache with grouping data, reusable FieldRow component with tier-based styling
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/store/appStore.ts
@src/hooks/useSchemaAnalysis.ts
@src/services/analysis/types.ts
@src/components/renderers/DetailRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add grouping to AnalysisCacheEntry and populate from useSchemaAnalysis</name>
  <files>src/store/appStore.ts, src/hooks/useSchemaAnalysis.ts</files>
  <action>
  1. In `src/store/appStore.ts`:
     - Import `GroupingResult` from `../services/analysis/types`
     - Add `grouping: GroupingResult | null` to `AnalysisCacheEntry` interface

  2. In `src/hooks/useSchemaAnalysis.ts`:
     - In the `array-of-objects` branch (line ~267-290): The code already calls `analyzeFields(fieldInfos)` which returns `{ importance, grouping }`. Currently only `importance` is stored. Add `grouping: analysisResult.grouping` to the `setAnalysisCache` call.
     - In the `object` branch (line ~291-314): Same fix - add `grouping: analysisResult.grouping` to `setAnalysisCache`.
     - In the `primitive-array` branch (line ~315-340): Set `grouping: null` since primitive arrays don't have field groups.

  This is a minimal wiring change - the grouping data is already computed, just not persisted.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify type correctness. All existing tests should still pass: `npm test -- --run`.
  </verify>
  <done>AnalysisCacheEntry includes grouping field. useSchemaAnalysis stores grouping results from analyzeFields in the cache for both array-of-objects and object schema kinds. Primitive arrays store null grouping.</done>
</task>

<task type="auto">
  <name>Task 2: Create shared FieldRow component with three-tier visual hierarchy</name>
  <files>src/components/renderers/FieldRow.tsx</files>
  <action>
  Create `src/components/renderers/FieldRow.tsx` - a shared field rendering component that applies visual hierarchy based on importance tier.

  **Props interface:**
  ```typescript
  interface FieldRowProps {
    fieldName: string
    displayLabel: string
    value: unknown
    fieldDef: FieldDefinition
    fieldPath: string
    tier: ImportanceTier  // from analysis cache
    depth: number
    onContextMenu?: (e: React.MouseEvent, fieldPath: string, fieldName: string, value: unknown) => void
  }
  ```

  **Visual hierarchy styles (from research):**
  - `primary`: label = `text-base font-semibold text-gray-700`, value = `text-lg font-semibold text-gray-900`, row padding = `py-2`
  - `secondary`: label = `text-sm font-medium text-gray-600`, value = `text-base text-gray-800`, row padding = `py-1`
  - `tertiary`: label = `text-xs font-medium text-gray-500`, value = `text-sm text-gray-600`, row padding = `py-0.5 opacity-80`

  **Implementation:**
  - Create a `getFieldStyles(tier: ImportanceTier)` helper that returns `{ row, label, value }` class strings
  - Use grid layout: `grid grid-cols-[auto_1fr] gap-x-3 items-baseline min-w-0`
  - Render label with tier-appropriate classes
  - Render value using `PrimitiveRenderer` with tier-appropriate wrapper classes
  - Include context menu / long-press handlers (same pattern as current DetailRenderer)
  - Export both `FieldRow` component and `getFieldStyles` helper (the helper will be useful in Plan 02)

  **Important:** This component handles ONLY primitive fields. Nested/image fields will continue using their existing rendering in DetailRenderer. The FieldRow is designed to be a drop-in replacement for the inline field rendering in DetailRenderer's `renderPrimitiveField` method.
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify types. Manually verify the component exports `FieldRow` and `getFieldStyles`.
  </verify>
  <done>FieldRow component exists with three-tier visual hierarchy. Styles differ visibly between primary (large/bold), secondary (normal), and tertiary (small/muted). Component accepts ImportanceTier prop and renders consistently regardless of context.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `npm test -- --run` passes all existing tests (no regressions)
3. `AnalysisCacheEntry` in appStore.ts includes `grouping: GroupingResult | null`
4. `useSchemaAnalysis.ts` populates grouping in setAnalysisCache for array-of-objects and object kinds
5. `FieldRow.tsx` exports FieldRow component and getFieldStyles helper
6. getFieldStyles returns different class strings for primary, secondary, and tertiary tiers
</verification>

<success_criteria>
- Analysis cache now includes grouping data from the already-computed analyzeFields results
- FieldRow component provides consistent tier-based visual hierarchy for primitive fields
- No regressions in existing tests or build
</success_criteria>

<output>
After completion, create `.planning/phases/15-smart-grouping-visual-hierarchy/15-01-SUMMARY.md`
</output>
