---
phase: 01-foundation-core-rendering
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/components/registry/ComponentRegistry.tsx
  - src/components/renderers/TableRenderer.tsx
  - src/components/renderers/DetailRenderer.tsx
  - src/components/renderers/PrimitiveRenderer.tsx
  - src/components/renderers/JsonFallback.tsx
  - src/components/loading/SkeletonTable.tsx
  - src/components/loading/SkeletonDetail.tsx
  - src/components/error/ErrorDisplay.tsx
  - src/components/URLInput.tsx
  - src/components/DynamicRenderer.tsx
  - src/store/appStore.ts
  - src/hooks/useAPIFetch.ts
  - src/App.tsx
autonomous: false

must_haves:
  truths:
    - "User can type a URL into the input field and submit it"
    - "After submitting a URL, a loading skeleton appears while data fetches"
    - "Arrays from the API render as a table with column headers from field names"
    - "Objects from the API render as a key-value detail view"
    - "CORS errors show a specific message explaining the issue with a suggestion"
    - "Network errors show a specific message with connectivity guidance"
    - "API errors (404, 500) show the status code and actionable suggestion"
    - "Parse errors show a message about invalid JSON"
    - "The table is virtualized for performance with large datasets"
  artifacts:
    - path: "src/components/registry/ComponentRegistry.tsx"
      provides: "Registry mapping TypeSignature to React components"
      exports: ["getComponent"]
    - path: "src/components/renderers/TableRenderer.tsx"
      provides: "Virtualized table for array-of-objects data"
      min_lines: 40
    - path: "src/components/renderers/DetailRenderer.tsx"
      provides: "Key-value pair view for object data"
      min_lines: 20
    - path: "src/components/error/ErrorDisplay.tsx"
      provides: "Error-type-specific display with suggestions"
      min_lines: 30
    - path: "src/components/DynamicRenderer.tsx"
      provides: "Top-level component that dispatches to correct renderer based on schema"
      exports: ["DynamicRenderer"]
    - path: "src/store/appStore.ts"
      provides: "Zustand store for URL, data, schema, loading, and error state"
      exports: ["useAppStore"]
    - path: "src/hooks/useAPIFetch.ts"
      provides: "Hook that orchestrates fetch -> infer -> store"
      exports: ["useAPIFetch"]
    - path: "src/App.tsx"
      provides: "Main app shell wiring URL input, loading, error, and renderer"
      min_lines: 30
  key_links:
    - from: "src/hooks/useAPIFetch.ts"
      to: "src/services/api/fetcher.ts"
      via: "calls fetchAPI(url)"
      pattern: "fetchAPI"
    - from: "src/hooks/useAPIFetch.ts"
      to: "src/services/schema/inferrer.ts"
      via: "calls inferSchema(data, url)"
      pattern: "inferSchema"
    - from: "src/hooks/useAPIFetch.ts"
      to: "src/store/appStore.ts"
      via: "updates store with data, schema, loading, error"
      pattern: "useAppStore"
    - from: "src/components/DynamicRenderer.tsx"
      to: "src/components/registry/ComponentRegistry.tsx"
      via: "calls getComponent(typeSignature)"
      pattern: "getComponent"
    - from: "src/components/renderers/TableRenderer.tsx"
      to: "react-window"
      via: "FixedSizeList for virtualization"
      pattern: "FixedSizeList"
    - from: "src/components/error/ErrorDisplay.tsx"
      to: "src/types/errors.ts"
      via: "checks error.kind for type-specific messaging"
      pattern: "error\\.kind"
    - from: "src/App.tsx"
      to: "src/hooks/useAPIFetch.ts"
      via: "triggers fetch on URL submit"
      pattern: "useAPIFetch"
    - from: "src/App.tsx"
      to: "src/components/DynamicRenderer.tsx"
      via: "renders DynamicRenderer when schema is available"
      pattern: "DynamicRenderer"
---

<objective>
Build all UI components, the component registry, Zustand store, and wire the complete URL-to-UI pipeline in the App shell. This is the plan that makes api2ui actually work end-to-end.

Purpose: Plans 01 and 02 built the engine (types, fetch, inference). This plan builds the car body (components) and connects everything (wiring). After this plan, a user can paste a URL and see rendered data.
Output: A working app where pasting a public JSON API URL renders the response as a table (arrays) or detail view (objects) with loading and error states.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-rendering/01-RESEARCH.md
@.planning/phases/01-foundation-core-rendering/01-01-SUMMARY.md
@.planning/phases/01-foundation-core-rendering/01-02-SUMMARY.md
@src/types/schema.ts
@src/types/components.ts
@src/types/errors.ts
@src/services/api/fetcher.ts
@src/services/api/errors.ts
@src/services/schema/inferrer.ts
@src/services/schema/mapper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build component registry, renderers, loading, and error display</name>
  <files>
    src/components/registry/ComponentRegistry.tsx
    src/components/renderers/TableRenderer.tsx
    src/components/renderers/DetailRenderer.tsx
    src/components/renderers/PrimitiveRenderer.tsx
    src/components/renderers/JsonFallback.tsx
    src/components/loading/SkeletonTable.tsx
    src/components/loading/SkeletonDetail.tsx
    src/components/error/ErrorDisplay.tsx
    src/components/DynamicRenderer.tsx
  </files>
  <action>
    1. **ComponentRegistry** (`src/components/registry/ComponentRegistry.tsx`):
       - Export `getComponent(typeSignature: TypeSignature): React.ComponentType<RendererProps>`
       - Map: array (with object items) -> TableRenderer, array (with primitive items) -> ListRenderer (use PrimitiveRenderer in a list), object -> DetailRenderer, primitive string/number/boolean/date -> PrimitiveRenderer, unknown -> JsonFallback
       - Do NOT use switch/if chains -- use a lookup structure (array of {match, component} entries)
       - Fallback to JsonFallback for any unmatched type

    2. **TableRenderer** (`src/components/renderers/TableRenderer.tsx`):
       - Accept `RendererProps` (data is unknown[], schema has kind: 'array' with items kind: 'object')
       - Extract column names from schema's item object fields
       - Render a header row with column names (capitalize, replace underscores with spaces)
       - Use `FixedSizeList` from react-window for rows (itemSize: 40, overscanCount: 5)
       - Each row renders cell values using PrimitiveRenderer for each field
       - Handle empty arrays: show "No data" message
       - Style with Tailwind: border, alternating row colors, sticky header
       - Table must have a container div with set height (min 200px, max 600px, or use calc with viewport)

    3. **DetailRenderer** (`src/components/renderers/DetailRenderer.tsx`):
       - Accept `RendererProps` (data is Record<string, unknown>, schema has kind: 'object')
       - Render each field as a label-value pair in a vertical layout
       - Labels: field name (capitalized, underscores to spaces), styled in gray/muted
       - Values: rendered using PrimitiveRenderer for primitives, or recursively using DynamicRenderer for nested objects/arrays
       - Style with Tailwind: grid layout (label left, value right), dividers between rows

    4. **PrimitiveRenderer** (`src/components/renderers/PrimitiveRenderer.tsx`):
       - Accept `RendererProps` (data is a primitive value)
       - Render based on type:
         - string: display as text (truncate long strings with ellipsis, show full on hover via title attr)
         - number: format with `toLocaleString()` for thousand separators
         - boolean: render as a styled badge ("true" green, "false" gray) -- NOT a checkbox (read-only app)
         - date: format with `new Date(value).toLocaleDateString()` with fallback to raw string
         - null: render as italic "null" in muted gray
         - unknown: render as JSON string

    5. **JsonFallback** (`src/components/renderers/JsonFallback.tsx`):
       - Accept `RendererProps`
       - Render `JSON.stringify(data, null, 2)` in a `<pre>` block with monospace font
       - Style: gray background, rounded corners, overflow-x auto

    6. **SkeletonTable** (`src/components/loading/SkeletonTable.tsx`):
       - Use react-loading-skeleton to show 8 rows of 4 columns
       - Style to match TableRenderer layout

    7. **SkeletonDetail** (`src/components/loading/SkeletonDetail.tsx`):
       - Use react-loading-skeleton to show 6 label-value pairs
       - Style to match DetailRenderer layout

    8. **ErrorDisplay** (`src/components/error/ErrorDisplay.tsx`):
       - Accept `{ error: Error }` props
       - Check if error implements AppError (has `kind` property)
       - For each error kind, render differently:
         - cors: Red banner with shield icon (use emoji or SVG), CORS explanation, suggestion
         - network: Orange banner with wifi-off icon, connectivity message, suggestion
         - api: Yellow banner with warning icon, status code, suggestion
         - parse: Blue banner with code icon, JSON parse message, suggestion
         - unknown/default: Gray banner with generic error, raw error.message
       - Each banner shows: error title, error.message, error.suggestion
       - Include a "Try again" button that emits an onRetry callback
       - Include a collapsible "Technical details" section showing the error stack (for developers)

    9. **DynamicRenderer** (`src/components/DynamicRenderer.tsx`):
       - Accept `{ data: unknown; schema: TypeSignature; path?: string; depth?: number }` props
       - Call `getComponent(schema)` from the registry to get the right component
       - Render the component, passing data, schema, path (default "$"), depth (default 0)
       - Guard against excessive depth: if depth > 5, render JsonFallback
       - This is the single entry point for rendering any piece of API data

    IMPORTANT: All components must import types from `src/types/` -- no inline type definitions.
    IMPORTANT: Do NOT use `any` anywhere. Use RendererProps interface for all renderer components.
    IMPORTANT: Import `react-loading-skeleton/dist/skeleton.css` in components that use skeletons, or import once in index.css.
  </action>
  <verify>
    1. `npm run build` -- compiles with zero errors
    2. Verify each component file exists and exports its main component
    3. Grep for `any` in src/components/ -- should find zero occurrences
    4. Verify TableRenderer imports FixedSizeList from react-window
    5. Verify ErrorDisplay checks error.kind for type-specific rendering
  </verify>
  <done>
    9 component files created. ComponentRegistry maps types to renderers. TableRenderer uses react-window virtualization. DetailRenderer shows key-value pairs. PrimitiveRenderer handles string/number/boolean/date/null formatting. ErrorDisplay shows type-specific error messages with suggestions. DynamicRenderer dispatches to correct component based on schema. Loading skeletons match component layouts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Zustand store, useAPIFetch hook, URL input, and wire App shell</name>
  <files>
    src/store/appStore.ts
    src/hooks/useAPIFetch.ts
    src/components/URLInput.tsx
    src/App.tsx
  </files>
  <action>
    1. **Zustand Store** (`src/store/appStore.ts`):
       ```typescript
       import { create } from 'zustand'
       import type { UnifiedSchema } from '../types/schema'

       interface AppState {
         // Input
         url: string
         setUrl: (url: string) => void

         // Pipeline state
         loading: boolean
         error: Error | null
         data: unknown
         schema: UnifiedSchema | null

         // Actions
         startFetch: () => void
         fetchSuccess: (data: unknown, schema: UnifiedSchema) => void
         fetchError: (error: Error) => void
         reset: () => void
       }

       export const useAppStore = create<AppState>()((set) => ({
         url: '',
         loading: false,
         error: null,
         data: null,
         schema: null,

         setUrl: (url) => set({ url }),
         startFetch: () => set({ loading: true, error: null, data: null, schema: null }),
         fetchSuccess: (data, schema) => set({ loading: false, data, schema, error: null }),
         fetchError: (error) => set({ loading: false, error, data: null, schema: null }),
         reset: () => set({ url: '', loading: false, error: null, data: null, schema: null }),
       }))
       ```

    2. **useAPIFetch hook** (`src/hooks/useAPIFetch.ts`):
       - Import `fetchAPI` from services/api/fetcher
       - Import `inferSchema` from services/schema/inferrer
       - Import `useAppStore` from store/appStore
       - Export a `useAPIFetch` hook that returns a `fetchAndInfer(url: string)` function
       - The function:
         a. Calls `startFetch()` on store
         b. Calls `fetchAPI(url)` to get raw data
         c. Calls `inferSchema(data, url)` to get schema
         d. Calls `fetchSuccess(data, schema)` on store
         e. On any error, calls `fetchError(error)` on store
       - Use async/await with try/catch
       - No useEffect -- the hook returns a function that App calls on form submit

    3. **URLInput** (`src/components/URLInput.tsx`):
       - Controlled input bound to `useAppStore().url` with `setUrl`
       - Form with URL input field and "Fetch" submit button
       - Input: full width, placeholder "https://jsonplaceholder.typicode.com/users", styled with Tailwind (border, rounded, padding, focus ring)
       - Button: primary color (blue-600), hover state, disabled while loading
       - On submit: call `fetchAndInfer(url)` from useAPIFetch hook
       - Basic client-side validation: URL must start with http:// or https://
       - Show inline validation error if URL is invalid
       - Include 2-3 example API links below the input that auto-fill the URL on click:
         - https://jsonplaceholder.typicode.com/users (array of objects)
         - https://jsonplaceholder.typicode.com/users/1 (single object)
         - https://dummyjson.com/products (nested with pagination)

    4. **App Shell** (`src/App.tsx`):
       - Import URLInput, DynamicRenderer, ErrorDisplay, SkeletonTable
       - Read state from useAppStore: url, loading, error, data, schema
       - Layout:
         - Top: app title "api2ui" with subtitle "Paste an API URL, see it rendered"
         - Below title: URLInput component
         - Main area (conditional rendering):
           - If loading: show SkeletonTable
           - If error: show ErrorDisplay with onRetry that re-fetches current URL
           - If schema and data: show DynamicRenderer with data and schema.rootType
           - If none of the above (initial state): show a welcome message with brief instructions
       - Style: max-w-6xl mx-auto, clean white background, subtle shadow on content area
       - Import skeleton CSS: `import 'react-loading-skeleton/dist/skeleton.css'` at the top of App.tsx

    IMPORTANT: The store is the single source of truth. Components read from store, hook writes to store.
    IMPORTANT: useAPIFetch returns a function, NOT a useEffect. The fetch is triggered by form submit, not by URL change.
    IMPORTANT: Do NOT pre-fetch on mount. The app starts empty and waits for user input.
  </action>
  <verify>
    1. `npm run build` -- compiles with zero errors
    2. `npm run dev` -- start dev server, open in browser
    3. Verify the page shows: title, URL input, example links
    4. Click "https://jsonplaceholder.typicode.com/users" example link -- should auto-fill URL
    5. Click Fetch -- should show loading skeleton, then render a table of users with columns (id, name, username, email, etc.)
    6. Try "https://jsonplaceholder.typicode.com/users/1" -- should render as detail/key-value view
    7. Try an invalid URL like "https://not-a-real-api.example.com/data" -- should show error
    8. Try "https://httpstat.us/404" -- should show APIError with 404 message
  </verify>
  <done>
    Zustand store manages the full pipeline state (url, loading, error, data, schema). useAPIFetch hook orchestrates fetchAPI -> inferSchema -> store update. URLInput provides URL entry with example links. App shell conditionally renders loading skeletons, error display, or dynamic data rendering. The complete URL-to-UI pipeline works end-to-end.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete api2ui Phase 1: URL input -> API fetch -> schema inference -> dynamic rendering with loading and error states</what-built>
  <how-to-verify>
    1. Run `npm run dev` and open http://localhost:5173
    2. You should see "api2ui" title, URL input field, and example API links
    3. Click the "jsonplaceholder.typicode.com/users" example, then click Fetch
       - Expected: Loading skeleton appears briefly, then a TABLE renders with user data (columns: id, name, username, email, etc.)
    4. Click the "jsonplaceholder.typicode.com/users/1" example, then Fetch
       - Expected: A DETAIL VIEW renders with key-value pairs (id: 1, name: Leanne Graham, etc.)
    5. Click the "dummyjson.com/products" example, then Fetch
       - Expected: Renders the response (likely a detail view with a nested products array)
    6. Type an obviously broken URL like "https://thisdomaindoesnotexist12345.com/api" and Fetch
       - Expected: A specific network or CORS error message with a suggestion
    7. Verify the table scrolls smoothly (virtualization working) by using the users endpoint
    8. Verify booleans render as badges, numbers have formatting, dates show readable format
  </how-to-verify>
  <resume-signal>Type "approved" if the pipeline works, or describe any issues you see</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` -- zero errors
2. `npm run test:run` -- all tests pass (from Plan 02 + any new tests)
3. Full pipeline test: paste URL -> see loading -> see rendered data
4. Error handling: CORS, network, 404, parse errors each show specific messages
5. Table uses react-window (check React DevTools for FixedSizeList)
6. Store state transitions: initial -> loading -> success/error
</verification>

<success_criteria>
- User can paste a REST API URL and see data rendered as table (arrays) or detail view (objects)
- Loading skeletons appear during fetch
- Each error type (CORS, network, API, parse) shows specific message with suggestion
- Table is virtualized with react-window
- Booleans render as badges, numbers are formatted, dates are readable
- Example API links work as one-click demos
- App builds with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-rendering/01-03-SUMMARY.md`
</output>
