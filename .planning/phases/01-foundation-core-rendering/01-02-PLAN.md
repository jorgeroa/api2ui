---
phase: 01-foundation-core-rendering
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/schema/inferrer.ts
  - src/services/schema/inferrer.test.ts
  - src/services/schema/typeDetection.ts
  - src/services/schema/typeDetection.test.ts
  - src/services/schema/mapper.ts
  - src/services/schema/mapper.test.ts
autonomous: true

must_haves:
  truths:
    - "Given a JSON array of objects, inferSchema returns TypeSignature with kind 'array' and item fields"
    - "Given a JSON object, inferSchema returns TypeSignature with kind 'object' and field definitions"
    - "Fields present in some samples but not all are marked optional"
    - "Fields with null values are marked nullable"
    - "Detected types include string, number, boolean, date, and null"
    - "ISO 8601 date strings are detected as 'date' type, not 'string'"
    - "mapToComponents maps array types to 'table' and object types to 'detail'"
  artifacts:
    - path: "src/services/schema/typeDetection.ts"
      provides: "detectFieldType function for single-value type detection"
      exports: ["detectFieldType"]
    - path: "src/services/schema/inferrer.ts"
      provides: "inferSchema function that analyzes JSON data and produces UnifiedSchema"
      exports: ["inferSchema"]
    - path: "src/services/schema/mapper.ts"
      provides: "mapToComponents function that maps TypeSignature to ComponentType"
      exports: ["mapToComponents", "getDefaultComponent"]
  key_links:
    - from: "src/services/schema/inferrer.ts"
      to: "src/types/schema.ts"
      via: "returns UnifiedSchema"
      pattern: "UnifiedSchema"
    - from: "src/services/schema/inferrer.ts"
      to: "src/services/schema/typeDetection.ts"
      via: "uses detectFieldType for value analysis"
      pattern: "detectFieldType"
    - from: "src/services/schema/mapper.ts"
      to: "src/types/components.ts"
      via: "returns ComponentType values"
      pattern: "ComponentType"
---

<objective>
Build the schema inference engine and type-to-component mapper using TDD. This is the brain of api2ui -- it analyzes raw JSON data and determines what UI components to render.

Purpose: Schema inference is the core algorithm of the app. It has clear inputs (JSON data) and outputs (UnifiedSchema), making it an ideal TDD candidate. Getting inference right determines whether the app renders useful UIs or garbage.
Output: Tested inferSchema() and mapToComponents() functions ready to be wired into the rendering pipeline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-rendering/01-RESEARCH.md
@src/types/schema.ts
@src/types/components.ts
</context>

<feature>
  <name>Type Detection</name>
  <files>src/services/schema/typeDetection.ts, src/services/schema/typeDetection.test.ts</files>
  <behavior>
    detectFieldType(value: unknown) -> FieldType

    Cases:
    - "hello" -> "string"
    - "" -> "string"
    - 42 -> "number"
    - 0 -> "number"
    - 3.14 -> "number"
    - true -> "boolean"
    - false -> "boolean"
    - null -> "null"
    - undefined -> "null"
    - "2026-02-01T12:00:00Z" -> "date" (ISO 8601 with time)
    - "2026-02-01" -> "date" (ISO 8601 date only)
    - "not-a-date" -> "string"
    - "12345" -> "string" (numeric string stays string)
    - [] -> NOT handled here (arrays handled by inferrer)
    - {} -> NOT handled here (objects handled by inferrer)
  </behavior>
  <implementation>
    Use regex for ISO 8601 detection: /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:?\d{2})?)?$/
    Validate with Date.parse() to reject false positives.
    typeof checks for string, number, boolean.
    null and undefined both map to "null".
  </implementation>
</feature>

<feature>
  <name>Schema Inference</name>
  <files>src/services/schema/inferrer.ts, src/services/schema/inferrer.test.ts</files>
  <behavior>
    inferSchema(data: unknown, url: string) -> UnifiedSchema

    Cases:
    - Array of flat objects:
      Input: [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]
      Output: rootType = { kind: "array", items: { kind: "object", fields: Map(id -> {type: {kind: "primitive", type: "number"}, optional: false, ...}, name -> {type: {kind: "primitive", type: "string"}, optional: false, ...}) } }

    - Single object:
      Input: {"id": 1, "name": "Alice", "email": "alice@example.com"}
      Output: rootType = { kind: "object", fields: Map(id -> number, name -> string, email -> string) }

    - Array with optional fields:
      Input: [{"id": 1, "name": "Alice"}, {"id": 2}]
      Output: name field has optional: true

    - Array with nullable fields:
      Input: [{"id": 1, "name": "Alice"}, {"id": 2, "name": null}]
      Output: name field has nullable: true

    - Nested objects:
      Input: {"user": {"name": "Alice", "age": 30}}
      Output: rootType.fields.get("user").type = { kind: "object", fields: Map(...) }

    - Nested arrays:
      Input: {"users": [{"name": "Alice"}, {"name": "Bob"}]}
      Output: rootType.fields.get("users").type = { kind: "array", items: { kind: "object", ... } }

    - Empty array:
      Input: []
      Output: rootType = { kind: "array", items: { kind: "primitive", type: "unknown" } }

    - Primitive root (string):
      Input: "hello"
      Output: rootType = { kind: "primitive", type: "string" }

    - Date detection in objects:
      Input: {"created": "2026-02-01T12:00:00Z", "name": "test"}
      Output: created field type = { kind: "primitive", type: "date" }

    All outputs include: sampleCount: 1, url, inferredAt (timestamp)
  </behavior>
  <implementation>
    Recursive analysis:
    1. Check if root is array -> analyze items (sample first 100 for large arrays)
    2. Check if root is object -> analyze each field
    3. For arrays of objects, merge field definitions across items:
       - Field in all items = required (optional: false)
       - Field in some items = optional: true
       - Field value is null in any item = nullable: true
       - Collect up to 5 sample values per field
    4. Confidence: high if all items agree on type and presence, medium if >70% agree, low otherwise
    5. Use detectFieldType for primitive value classification
    6. Recurse into nested objects and arrays (max depth 10 to prevent infinite recursion)
  </implementation>
</feature>

<feature>
  <name>Component Mapper</name>
  <files>src/services/schema/mapper.ts, src/services/schema/mapper.test.ts</files>
  <behavior>
    getDefaultComponent(typeSignature: TypeSignature) -> ComponentType
    mapToComponents(schema: UnifiedSchema) -> ComponentMapping[]

    getDefaultComponent cases:
    - { kind: "array", items: { kind: "object", ... } } -> "table"
    - { kind: "array", items: { kind: "primitive", ... } } -> "list"
    - { kind: "object", fields: ... } -> "detail"
    - { kind: "primitive", type: "string" } -> "text"
    - { kind: "primitive", type: "number" } -> "number"
    - { kind: "primitive", type: "boolean" } -> "boolean"
    - { kind: "primitive", type: "date" } -> "date"
    - { kind: "primitive", type: "null" } -> "text"
    - { kind: "primitive", type: "unknown" } -> "json"

    mapToComponents for root array of objects:
    - Returns mapping for root path "$" -> "table"
    - Returns mappings for each field "$.fieldname" -> appropriate type

    mapToComponents for root object:
    - Returns mapping for root path "$" -> "detail"
    - Returns mappings for each field
  </behavior>
  <implementation>
    getDefaultComponent: switch on kind, then sub-switch on type for primitives.
    mapToComponents: recursive traversal of UnifiedSchema, building path strings with dot notation.
    Path convention: "$" = root, "$.field" = top-level field, "$.field.nested" = nested field.
  </implementation>
</feature>

<verification>
1. `npm run test:run` -- all tests pass
2. Tests cover: primitive detection, array inference, object inference, optional fields, nullable fields, nested structures, date detection, component mapping
3. No `any` types in implementation files
4. inferSchema handles edge cases: empty array, empty object, primitive root, null root
</verification>

<success_criteria>
- typeDetection.test.ts has tests for all primitive types including ISO date detection
- inferrer.test.ts has tests for flat arrays, objects, optional fields, nullable fields, nested structures, and edge cases
- mapper.test.ts has tests for all type-to-component mappings
- All tests pass with `npm run test:run`
- Functions are pure (no side effects, no API calls, no DOM access)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-rendering/01-02-SUMMARY.md`
</output>
