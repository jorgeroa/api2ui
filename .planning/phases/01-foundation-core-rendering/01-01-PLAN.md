---
phase: 01-foundation-core-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - tsconfig.app.json
  - tsconfig.node.json
  - vite.config.ts
  - index.html
  - postcss.config.js
  - src/index.css
  - src/main.tsx
  - src/App.tsx
  - src/vite-env.d.ts
  - src/types/schema.ts
  - src/types/components.ts
  - src/types/errors.ts
  - src/services/api/fetcher.ts
  - src/services/api/errors.ts
autonomous: true

must_haves:
  truths:
    - "Project builds and dev server starts with zero errors"
    - "TypeScript compiles with strict mode enabled"
    - "API fetch service returns parsed JSON from a public URL"
    - "CORS errors are detected and thrown as CORSError with actionable message"
    - "Network errors are detected and thrown as NetworkError"
    - "Non-2xx responses are thrown as APIError with status code"
  artifacts:
    - path: "src/types/schema.ts"
      provides: "UnifiedSchema, FieldDefinition, TypeSignature interfaces"
      exports: ["UnifiedSchema", "FieldDefinition", "TypeSignature", "FieldType"]
    - path: "src/types/components.ts"
      provides: "ComponentType, ComponentMapping, RendererProps interfaces"
      exports: ["ComponentType", "ComponentMapping", "RendererProps"]
    - path: "src/types/errors.ts"
      provides: "Error type discriminator"
      exports: ["AppError", "ErrorKind"]
    - path: "src/services/api/errors.ts"
      provides: "Typed error classes for CORS, network, API, parse failures"
      exports: ["CORSError", "NetworkError", "APIError", "ParseError"]
    - path: "src/services/api/fetcher.ts"
      provides: "API fetch with CORS detection and error classification"
      exports: ["fetchAPI"]
  key_links:
    - from: "src/services/api/fetcher.ts"
      to: "src/services/api/errors.ts"
      via: "throws typed errors"
      pattern: "throw new (CORSError|NetworkError|APIError|ParseError)"
    - from: "src/services/api/errors.ts"
      to: "src/types/errors.ts"
      via: "implements AppError interface"
      pattern: "implements AppError|ErrorKind"
---

<objective>
Scaffold the api2ui project with Vite + React 19 + TypeScript 5.9 + Tailwind CSS 4, define the core type system for schema inference and component mapping, and build the API fetch service with typed error handling.

Purpose: Establish the project foundation that all subsequent plans build on. Types and fetch service are the two pillars -- every other module imports types, and the fetch service is the entry point of the URL-to-UI pipeline.
Output: A running Vite dev server with TypeScript types, API fetch service, and typed error classes ready for schema inference (Plan 02) and UI components (Plan 03).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-rendering/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Vite project with all Phase 1 dependencies</name>
  <files>
    package.json
    tsconfig.json
    tsconfig.app.json
    tsconfig.node.json
    vite.config.ts
    index.html
    postcss.config.js
    src/index.css
    src/main.tsx
    src/App.tsx
    src/vite-env.d.ts
  </files>
  <action>
    1. Initialize Vite project with React + TypeScript template:
       ```
       npm create vite@latest . -- --template react-ts
       ```
       (Use `.` to scaffold in current directory since repo already exists)

    2. Install all Phase 1 dependencies:
       ```
       npm install zustand react-window react-loading-skeleton
       npm install -D @types/react-window tailwindcss @tailwindcss/vite vitest @testing-library/react @testing-library/jest-dom jsdom
       ```

       NOTE: Do NOT install react-hook-form, zod, or @hookform/resolvers yet -- those are for Phase 2 parameter inputs.
       NOTE: Do NOT install postcss or autoprefixer separately -- Tailwind CSS 4 uses the Vite plugin directly (@tailwindcss/vite), not PostCSS.
       NOTE: Install `jsdom` for vitest browser environment.

    3. Configure Tailwind CSS 4 with Vite plugin approach (NOT the PostCSS approach):
       - Update `vite.config.ts` to include `@tailwindcss/vite` plugin
       - Update `src/index.css` to use `@import "tailwindcss"` (Tailwind 4 CSS-first syntax)
       - Remove any `postcss.config.js` and `tailwind.config.js` -- Tailwind 4 with Vite plugin does not need them

    4. Configure TypeScript with strict mode in tsconfig.app.json:
       - `"strict": true`
       - `"noUncheckedIndexedAccess": true`
       - `"forceConsistentCasingInFileNames": true`

    5. Configure Vitest in vite.config.ts:
       ```typescript
       /// <reference types="vitest/config" />
       import { defineConfig } from 'vite'
       import react from '@vitejs/plugin-react'
       import tailwindcss from '@tailwindcss/vite'

       export default defineConfig({
         plugins: [react(), tailwindcss()],
         test: {
           globals: true,
           environment: 'jsdom',
           setupFiles: './src/test/setup.ts',
         },
       })
       ```

    6. Create test setup file at `src/test/setup.ts`:
       ```typescript
       import '@testing-library/jest-dom'
       ```

    7. Update `src/App.tsx` to a minimal placeholder (remove Vite boilerplate):
       ```tsx
       export default function App() {
         return (
           <div className="min-h-screen bg-gray-50">
             <h1 className="text-2xl font-bold p-8">api2ui</h1>
           </div>
         )
       }
       ```

    8. Create the directory structure (empty directories as needed):
       ```
       src/types/
       src/services/api/
       src/services/schema/
       src/components/registry/
       src/components/renderers/
       src/components/loading/
       src/components/error/
       src/store/
       src/hooks/
       src/test/
       ```

    9. Add scripts to package.json:
       ```json
       "scripts": {
         "dev": "vite",
         "build": "tsc -b && vite build",
         "preview": "vite preview",
         "test": "vitest",
         "test:run": "vitest run"
       }
       ```
  </action>
  <verify>
    Run these commands and confirm all pass:
    1. `npm run build` -- compiles with zero errors
    2. `npm run test:run` -- vitest runs (0 tests ok, no config errors)
    3. `npm run dev` -- starts dev server (verify it responds, then kill it)
  </verify>
  <done>
    Vite dev server starts, TypeScript compiles in strict mode, Tailwind CSS 4 processes classes, vitest is configured and runnable. Project structure directories exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define core type system and build API fetch service</name>
  <files>
    src/types/schema.ts
    src/types/components.ts
    src/types/errors.ts
    src/services/api/errors.ts
    src/services/api/fetcher.ts
  </files>
  <action>
    **Type System (3 files):**

    1. `src/types/schema.ts` -- Schema inference types:
       ```typescript
       /** Primitive field types detected from JSON values */
       export type FieldType = 'string' | 'number' | 'boolean' | 'null' | 'date' | 'unknown'

       /** Type signature for a field -- can be primitive, object, or array */
       export type TypeSignature =
         | { kind: 'primitive'; type: FieldType }
         | { kind: 'array'; items: TypeSignature }
         | { kind: 'object'; fields: Map<string, FieldDefinition> }

       /** Confidence level based on multi-sample consistency */
       export type Confidence = 'high' | 'medium' | 'low'

       /** A single field in the inferred schema */
       export interface FieldDefinition {
         name: string
         type: TypeSignature
         optional: boolean
         nullable: boolean
         confidence: Confidence
         sampleValues: unknown[]
       }

       /** The complete inferred schema for an API response */
       export interface UnifiedSchema {
         rootType: TypeSignature
         sampleCount: number
         url: string
         inferredAt: number  // timestamp
       }
       ```

    2. `src/types/components.ts` -- Component registry types:
       ```typescript
       import type { TypeSignature } from './schema'

       /** Available component types for rendering */
       export type ComponentType = 'table' | 'detail' | 'card-list' | 'list' | 'text' | 'number' | 'boolean' | 'date' | 'json' | 'badge'

       /** Mapping from a schema path to a component */
       export interface ComponentMapping {
         path: string
         componentType: ComponentType
         typeSignature: TypeSignature
       }

       /** Props passed to every dynamic renderer component */
       export interface RendererProps {
         data: unknown
         schema: TypeSignature
         path: string
         depth: number
       }
       ```

    3. `src/types/errors.ts` -- Error type discriminator:
       ```typescript
       /** Error kinds for discriminated error handling */
       export type ErrorKind = 'cors' | 'network' | 'api' | 'parse' | 'unknown'

       /** Base interface all app errors implement */
       export interface AppError {
         kind: ErrorKind
         message: string
         suggestion: string
       }
       ```

    **API Fetch Service (2 files):**

    4. `src/services/api/errors.ts` -- Typed error classes:
       ```typescript
       import type { AppError, ErrorKind } from '../../types/errors'

       export class CORSError extends Error implements AppError {
         readonly kind: ErrorKind = 'cors'
         readonly suggestion: string

         constructor(url: string) {
           super(`Cannot access ${url} â€” blocked by CORS policy.`)
           this.name = 'CORSError'
           this.suggestion = 'This API does not allow browser requests. Try a CORS-enabled API like JSONPlaceholder (jsonplaceholder.typicode.com).'
         }
       }

       export class NetworkError extends Error implements AppError {
         readonly kind: ErrorKind = 'network'
         readonly suggestion: string

         constructor(url: string) {
           super(`Network error while fetching ${url}.`)
           this.name = 'NetworkError'
           this.suggestion = 'Check your internet connection and verify the URL is correct.'
         }
       }

       export class APIError extends Error implements AppError {
         readonly kind: ErrorKind = 'api'
         readonly suggestion: string
         readonly status: number

         constructor(url: string, status: number, statusText: string) {
           super(`API returned ${status} ${statusText} for ${url}.`)
           this.name = 'APIError'
           this.status = status
           this.suggestion = status === 404
             ? 'The endpoint was not found. Check the URL path.'
             : status >= 500
             ? 'The API server is having issues. Try again later.'
             : `The API returned an error (${status}). Verify the URL.`
         }
       }

       export class ParseError extends Error implements AppError {
         readonly kind: ErrorKind = 'parse'
         readonly suggestion: string

         constructor(url: string) {
           super(`Failed to parse response from ${url} as JSON.`)
           this.name = 'ParseError'
           this.suggestion = 'The API did not return valid JSON. Ensure the URL points to a JSON API endpoint.'
         }
       }
       ```

    5. `src/services/api/fetcher.ts` -- Fetch with error classification:
       ```typescript
       import { CORSError, NetworkError, APIError, ParseError } from './errors'

       /**
        * Fetch JSON data from an API URL with typed error handling.
        * Detects CORS, network, HTTP, and parse errors.
        */
       export async function fetchAPI(url: string): Promise<unknown> {
         let response: Response

         try {
           response = await fetch(url, {
             mode: 'cors',
             credentials: 'omit',
             headers: {
               'Accept': 'application/json',
             },
           })
         } catch (error) {
           // TypeError: Failed to fetch indicates CORS or network issue
           if (error instanceof TypeError) {
             // Heuristic: if we can't distinguish CORS from network,
             // try a HEAD request to check connectivity
             const isCORS = await detectCORS(url)
             if (isCORS) throw new CORSError(url)
             throw new NetworkError(url)
           }
           throw new NetworkError(url)
         }

         if (!response.ok) {
           throw new APIError(url, response.status, response.statusText)
         }

         try {
           return await response.json()
         } catch {
           throw new ParseError(url)
         }
       }

       /**
        * Heuristic CORS detection: attempt fetch with no-cors mode.
        * If no-cors succeeds (opaque response), the server exists but blocks CORS.
        * If it also fails, it's likely a network error.
        */
       async function detectCORS(url: string): Promise<boolean> {
         try {
           const response = await fetch(url, { mode: 'no-cors' })
           // Opaque response = server exists, CORS blocked
           return response.type === 'opaque'
         } catch {
           // Both modes failed = network error
           return false
         }
       }
       ```

    IMPORTANT: Use `export` on all types and functions -- they are consumed by every other module in the project.
    IMPORTANT: Do NOT use `any` type anywhere. Use `unknown` for untyped API data.
    IMPORTANT: Error classes MUST extend Error AND implement AppError for both instanceof checks and discriminated unions to work.
  </action>
  <verify>
    1. `npm run build` -- compiles with zero TypeScript errors
    2. Manually verify that `src/types/schema.ts` exports UnifiedSchema, FieldDefinition, TypeSignature, FieldType
    3. Manually verify that `src/services/api/fetcher.ts` imports from `./errors` (not from types directly)
    4. Grep for `any` in src/ -- should find zero occurrences in new files
  </verify>
  <done>
    Type system defines UnifiedSchema with nested TypeSignature (primitive | array | object), FieldDefinition with confidence levels, ComponentType/ComponentMapping for the registry, and AppError/ErrorKind for error discrimination. API fetch service classifies fetch failures into CORSError, NetworkError, APIError, or ParseError with user-friendly suggestions. All types are exported and consumed by downstream modules.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` exits 0 with no TypeScript errors
2. `npm run test:run` exits 0 (vitest configured, no test failures)
3. Dev server starts: `npm run dev` shows "Local: http://localhost:5173"
4. No `any` types in src/types/ or src/services/
5. All error classes are instanceof Error and implement AppError
</verification>

<success_criteria>
- Vite dev server runs with React 19 + TypeScript strict mode + Tailwind CSS 4
- Complete type system for schema inference, component mapping, and error handling
- API fetch service with CORS detection heuristic and 4 typed error classes
- Project structure directories created for all Phase 1 modules
- Zero TypeScript errors on build
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-rendering/01-01-SUMMARY.md`
</output>
