---
phase: 14-smart-component-selection
plan: 03
type: execute
wave: 1
depends_on: ["14-01", "14-02"]
files_modified:
  - src/hooks/useSchemaAnalysis.ts
  - src/App.tsx
  - src/components/DynamicRenderer.tsx
  - src/types/components.ts
autonomous: true

must_haves:
  truths:
    - "Analysis pipeline runs when schema/data changes"
    - "Analysis cache is populated with semantics, importance, and selection"
    - "Smart defaults apply for arrays (review → cards)"
    - "Importance prop passed to renderers for tier filtering"
    - "CardListRenderer filters tertiary fields"
    - "v1.2 behavior preserved (user overrides still work)"
  artifacts:
    - path: "src/hooks/useSchemaAnalysis.ts"
      provides: "Analysis pipeline hook"
      exports: ["useSchemaAnalysis"]
    - path: "src/App.tsx"
      contains: "useSchemaAnalysis"
    - path: "src/components/DynamicRenderer.tsx"
      contains: "importance="
  key_links:
    - from: "src/App.tsx"
      to: "src/hooks/useSchemaAnalysis.ts"
      via: "useSchemaAnalysis import"
      pattern: "import.*useSchemaAnalysis"
    - from: "src/hooks/useSchemaAnalysis.ts"
      to: "src/store/appStore.ts"
      via: "setAnalysisCache call"
      pattern: "setAnalysisCache"
---

<objective>
Wire the analysis pipeline to close gaps identified in VERIFICATION.md

**Gap Closure:**
1. Analysis pipeline never invoked → Create useSchemaAnalysis hook
2. Analysis cache never populated → Hook calls setAnalysisCache
3. Importance prop never passed → DynamicRenderer passes to renderers
</objective>

<tasks>

<task type="auto">
  <name>Task 1: Create useSchemaAnalysis hook</name>
  <files>
    src/hooks/useSchemaAnalysis.ts
  </files>
  <action>
Create a hook that runs the analysis pipeline when schema/data changes:

1. Accept schema (UnifiedSchema | null) and data (unknown) as parameters
2. Track schema identity to avoid re-running on every render
3. Find all array-of-objects paths in the schema
4. For each array path:
   - Build FieldInfo[] from schema fields
   - Extract sample values from data
   - Run detectSemantics for each field
   - Run analyzeFields for importance scores
   - Run selectComponent for component selection
   - Store results via setAnalysisCache
5. Clear cache when schema changes
  </action>
  <done>
    - Hook runs when schema identity changes
    - Cache populated with semantics, importance, selection
    - Only runs once per API response
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hook and pass importance prop</name>
  <files>
    src/App.tsx
    src/components/DynamicRenderer.tsx
    src/types/components.ts
  </files>
  <action>
1. App.tsx: Import and call useSchemaAnalysis(schema, data)
2. types/components.ts: Add importance? prop to RendererProps
3. DynamicRenderer.tsx: Pass importance={getAnalysisCache(activePath)?.importance} to Component
  </action>
  <done>
    - Hook called in App.tsx
    - RendererProps includes importance
    - DynamicRenderer passes importance to all renderers
    - CardListRenderer receives and uses importance for filtering
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. All tests pass: `npm test`
3. Build succeeds: `npm run build`
4. Manual: Load any API → check analysisCache has entries
5. Manual: Review arrays default to cards instead of tables
</verification>

<success_criteria>
- [ ] Analysis cache populated when schema available
- [ ] Smart defaults apply (review arrays → cards)
- [ ] CardListRenderer filters tertiary fields
- [ ] User overrides still take precedence
- [ ] No breaking changes to v1.2 behavior
</success_criteria>
