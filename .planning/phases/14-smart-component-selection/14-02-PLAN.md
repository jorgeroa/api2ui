---
phase: 14-smart-component-selection
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/components/DynamicRenderer.tsx
  - src/components/renderers/CardListRenderer.tsx
  - src/store/appStore.ts
autonomous: true

must_haves:
  truths:
    - "DynamicRenderer uses smart defaults when no user override exists"
    - "User overrides (configStore) always take precedence over smart defaults"
    - "v0.2 behavior preserved when smart selection returns low confidence"
    - "CardListRenderer displays only primary + secondary tier fields"
    - "Component switcher continues to work for user overrides"
    - "Smart defaults only apply when confidence >= 0.75"
  artifacts:
    - path: "src/components/DynamicRenderer.tsx"
      provides: "Smart component selection integration"
      contains: "selectComponent"
    - path: "src/components/renderers/CardListRenderer.tsx"
      provides: "Tier-aware field filtering"
      contains: "importance.*tier"
    - path: "src/store/appStore.ts"
      provides: "Analysis cache storage"
      contains: "analysisCache"
  key_links:
    - from: "src/components/DynamicRenderer.tsx"
      to: "src/services/selection/index.ts"
      via: "selectComponent import"
      pattern: "import.*selectComponent.*selection"
    - from: "src/components/DynamicRenderer.tsx"
      to: "src/store/configStore.ts"
      via: "override check before smart default"
      pattern: "override.*\\|\\|.*smartDefault"
    - from: "src/components/renderers/CardListRenderer.tsx"
      to: "src/services/analysis/types.ts"
      via: "ImportanceScore tier check"
      pattern: "tier.*primary.*secondary"
---

<objective>
Integrate smart component selection into DynamicRenderer and update CardListRenderer for tier-aware display

Purpose: Connect the selection service to the rendering pipeline so arrays automatically render with context-appropriate components. Ensure v0.2 behavior is preserved (user overrides always win) and cards show only relevant fields (primary + secondary tiers).

Output: DynamicRenderer using smart defaults, CardListRenderer filtering by importance tier, analysis cache in appStore
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-smart-component-selection/14-CONTEXT.md
@.planning/phases/14-smart-component-selection/14-RESEARCH.md
@.planning/phases/14-smart-component-selection/14-01-SUMMARY.md
@src/components/DynamicRenderer.tsx
@src/components/renderers/CardListRenderer.tsx
@src/store/appStore.ts
@src/services/selection/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate smart selection into DynamicRenderer</name>
  <files>
    src/components/DynamicRenderer.tsx
    src/store/appStore.ts
  </files>
  <action>
Wire the selection service into DynamicRenderer to provide smart defaults while preserving v0.2 behavior.

**src/store/appStore.ts:**

Add analysis cache to store selection results (run once per API response):

```typescript
interface AppState {
  // ... existing state
  analysisCache: Map<string, {
    semantics: Map<string, SemanticMetadata>
    importance: Map<string, ImportanceScore>
    selection: ComponentSelection | null
  }>
  setAnalysisCache: (path: string, data: AppState['analysisCache'] extends Map<string, infer V> ? V : never) => void
  getAnalysisCache: (path: string) => AppState['analysisCache'] extends Map<string, infer V> ? V : null
  clearAnalysisCache: () => void
}
```

Initialize analysisCache as new Map() in the store.
Add setAnalysisCache, getAnalysisCache, clearAnalysisCache actions.

**src/components/DynamicRenderer.tsx:**

1. Import selectComponent from '@/services/selection'

2. Move getDefaultTypeName to a shared location or import from selection service (it's already exported from selection/index.ts in Plan 01)

3. Modify the component selection logic:

```typescript
// BEFORE (v0.2 behavior):
const config = fieldConfigs[activePath]
const override = config?.componentType
const defaultType = getDefaultTypeName(activeSchema)
const currentType = override || defaultType

// AFTER (v0.3 with smart defaults):
const config = fieldConfigs[activePath]
const override = config?.componentType

// User override always wins (INT-01, INT-05)
if (override) {
  currentType = override
} else {
  // Try smart selection
  const cached = getAnalysisCache(activePath)
  if (cached?.selection && cached.selection.confidence >= 0.75) {
    currentType = cached.selection.componentType
  } else {
    // Fall back to type-based default (v0.2 behavior preserved)
    currentType = getDefaultTypeName(activeSchema)
  }
}
```

4. The analysis cache should be populated elsewhere (App.tsx or a hook) when API data is fetched. For now, DynamicRenderer should gracefully handle missing cache (fall back to type-based default).

5. Ensure getComponent receives the correct type.

**Critical requirements:**
- INT-01: Smart defaults must NOT break v0.2 behavior
- INT-05: Component switcher continues to work (user overrides stored in configStore)
- ARR-09: Fall back to type-based defaults when confidence < 0.75
- Override precedence: User override > Smart default > Type-based default
  </action>
  <verify>
    npx tsc --noEmit src/components/DynamicRenderer.tsx
    npm test -- --testPathPattern="DynamicRenderer" --passWithNoTests
    # TypeScript compiles, existing tests pass
  </verify>
  <done>
    - DynamicRenderer imports selectComponent from selection service
    - User override check happens BEFORE smart default
    - Smart default only applies when confidence >= 0.75
    - Falls back to getDefaultTypeName when no cache or low confidence
    - appStore has analysisCache with set/get/clear methods
    - Component switcher still works (override stored in configStore)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CardListRenderer for tier-aware display</name>
  <files>
    src/components/renderers/CardListRenderer.tsx
  </files>
  <action>
Update CardListRenderer to filter fields by importance tier, showing only primary and secondary fields.

**User decision from CONTEXT.md:**
- "Cards display primary + secondary tier fields only; tertiary fields hidden from card view"
- "Card selection is about content type, not about showing all fields"

**Implementation:**

1. Accept optional importance prop (Map of path to ImportanceScore):
```typescript
interface CardListRendererProps {
  data: unknown[]
  schema: ArraySchema
  path: string
  depth: number
  importance?: Map<string, ImportanceScore>  // New optional prop
}
```

2. If importance map provided, filter displayed fields:
```typescript
const fieldsToDisplay = useMemo(() => {
  if (!importance) {
    // No importance data - show all fields (v0.2 behavior preserved)
    return Array.from(schema.items.fields.entries())
  }

  return Array.from(schema.items.fields.entries()).filter(([fieldName]) => {
    const fieldPath = `${path}[].${fieldName}`
    const score = importance.get(fieldPath)
    // Show primary and secondary, hide tertiary
    return !score || score.tier === 'primary' || score.tier === 'secondary'
  })
}, [schema, importance, path])
```

3. Use fieldsToDisplay instead of all fields when rendering card content.

4. Update the card rendering logic to use the filtered field list:
- Keep hero image detection (still use all fields for this)
- Filter content fields for card body
- Preserve existing card layout and styling

**Important:** This is backward compatible. When importance prop is undefined, all fields display (v0.2 behavior).

**Do NOT change:**
- Card layout structure
- Pagination behavior
- Click/navigation behavior
- Hero image detection logic
  </action>
  <verify>
    npx tsc --noEmit src/components/renderers/CardListRenderer.tsx
    npm test -- --testPathPattern="CardListRenderer" --passWithNoTests
  </verify>
  <done>
    - CardListRenderer accepts optional importance prop
    - When importance provided, only primary + secondary tier fields displayed in card body
    - When importance undefined, all fields displayed (v0.2 compatibility)
    - Hero image detection unchanged
    - Existing card layout and behavior preserved
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript compilation: `npx tsc --noEmit`

2. All tests pass: `npm test`

3. Manual verification in browser:
   - Load an API with product data
   - Verify cards/tables render as before (v0.2 baseline)
   - Use component switcher to change type
   - Verify override persists after page refresh
   - Verify component switcher still cycles through options

4. Integration smoke test:
```bash
npx tsx -e "
import { selectComponent, getDefaultTypeName } from './src/services/selection';
import type { TypeSignature } from './src/types/schema';

// Test that getDefaultTypeName is exported and works
const arraySchema: TypeSignature = { kind: 'array', items: { kind: 'object', fields: new Map() } };
console.log('Array of objects default:', getDefaultTypeName(arraySchema));

const objectSchema: TypeSignature = { kind: 'object', fields: new Map() };
console.log('Object default:', getDefaultTypeName(objectSchema));

const primitiveSchema: TypeSignature = { kind: 'primitive', type: 'string' };
console.log('Primitive default:', getDefaultTypeName(primitiveSchema));
"
# Should output:
# Array of objects default: table
# Object default: detail
# Primitive default: primitive
```

5. Verify INT-01 (v0.2 behavior preserved):
   - Existing configurations in localStorage should still work
   - No breaking changes to component rendering
   - User overrides take precedence
</verification>

<success_criteria>
- DynamicRenderer uses smart defaults when no override exists
- User overrides (configStore) always win over smart defaults
- Confidence threshold of 0.75 enforced before applying smart default
- Falls back to type-based default when no cache or low confidence
- CardListRenderer filters fields by importance tier when prop provided
- CardListRenderer shows all fields when importance prop undefined (v0.2 compat)
- Component switcher continues to work (INT-05)
- No breaking changes to existing v0.2 behavior (INT-01)
- TypeScript compiles without errors
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-smart-component-selection/14-02-SUMMARY.md`
</output>
