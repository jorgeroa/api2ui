---
phase: 09-url-parsing-type-inference
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/parameterStore.ts
  - src/hooks/useDebouncedPersist.ts
autonomous: true

must_haves:
  truths:
    - "Parameter values persist per endpoint across browser sessions"
    - "Persistence is silent (no 'Saved' indicators)"
    - "Values auto-save on input change with debouncing"
    - "Per-field clear (X button) removes single parameter value"
    - "Reset all clears all values for an endpoint"
    - "Multi-tab uses last-write-wins strategy"
  artifacts:
    - path: "src/store/parameterStore.ts"
      provides: "Per-endpoint parameter persistence store"
      exports: ["useParameterStore"]
    - path: "src/hooks/useDebouncedPersist.ts"
      provides: "Debounced autosave hook"
      exports: ["useDebouncedPersist"]
  key_links:
    - from: "src/store/parameterStore.ts"
      to: "localStorage via Zustand persist"
      via: "persist middleware with api2ui-parameters key"
      pattern: "persist.*api2ui-parameters"
---

<objective>
Create parameter persistence store for per-endpoint parameter value storage with debounced autosave.

Purpose: Parameter values persist across browser sessions per endpoint, enabling users to return to previously entered values. Silent autosave provides seamless UX without save buttons or confirmations.

Output: useParameterStore Zustand store with persist middleware, useDebouncedPersist hook for autosave.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-url-parsing-type-inference/09-RESEARCH.md

# Existing store pattern to follow
@src/store/configStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Parameter Store</name>
  <files>src/store/parameterStore.ts</files>
  <action>
Create Zustand store with persist middleware following the configStore.ts pattern.

**State structure:**
```typescript
interface ParameterState {
  // endpoint -> param name -> value
  values: Record<string, Record<string, string>>
  // endpoint -> param name -> user-overridden type (when inference is wrong)
  typeOverrides: Record<string, Record<string, string>>
}
```

**Actions:**
- `getValues(endpoint: string): Record<string, string>` - Get all values for endpoint
- `getValue(endpoint: string, name: string): string | undefined` - Get single value
- `setValue(endpoint: string, name: string, value: string): void` - Set single value
- `setValues(endpoint: string, values: Record<string, string>): void` - Batch set values
- `clearValue(endpoint: string, name: string): void` - Clear single value (for X button)
- `clearEndpoint(endpoint: string): void` - Clear all values for endpoint (Reset all)
- `getTypeOverride(endpoint: string, name: string): string | undefined` - Get overridden type
- `setTypeOverride(endpoint: string, name: string, type: string): void` - Set type override

**Persist config:**
- Storage key: `api2ui-parameters`
- Version: 1
- Use createJSONStorage(() => localStorage)
- Partialize to only persist values and typeOverrides (not functions)

**Note:** No version timestamps needed per user decision (last-write-wins for multi-tab).
  </action>
  <verify>
```bash
# Verify file exists and exports useParameterStore
grep -l "export const useParameterStore" src/store/parameterStore.ts
# Verify persist middleware usage
grep "persist.*api2ui-parameters" src/store/parameterStore.ts
```
  </verify>
  <done>
- useParameterStore exports all actions listed above
- Store persists to localStorage with key 'api2ui-parameters'
- State shape matches interface (values, typeOverrides)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Debounced Persist Hook</name>
  <files>src/hooks/useDebouncedPersist.ts</files>
  <action>
Create custom hook for debounced autosave of parameter values.

**Hook signature:**
```typescript
function useDebouncedPersist(
  endpoint: string,
  values: Record<string, string>,
  delay?: number  // default 300ms
): void
```

**Implementation:**
1. Use useRef to store timeout ID
2. Use useEffect to set up debounce
3. On values change, clear existing timeout and set new one
4. After delay, call setValues from useParameterStore
5. Clean up timeout on unmount

**Key behaviors:**
- Default delay: 300ms (per research recommendation)
- Clears pending persist on component unmount
- Only persists if values actually changed (shallow compare)
- Does not persist empty objects (skip if no values)

**Usage pattern (for downstream integration):**
```typescript
// In ParameterForm.tsx
const [values, setValues] = useState<Record<string, string>>({})
useDebouncedPersist(endpoint, values) // Auto-saves after 300ms of no changes
```
  </action>
  <verify>
```bash
# Verify file exists and exports hook
grep -l "export function useDebouncedPersist" src/hooks/useDebouncedPersist.ts
# Verify it uses useParameterStore
grep "useParameterStore" src/hooks/useDebouncedPersist.ts
```
  </verify>
  <done>
- useDebouncedPersist hook exported with correct signature
- Uses setTimeout for debouncing with cleanup
- Integrates with useParameterStore.setValues
- Default delay is 300ms
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation
npx tsc --noEmit

# Verify both files created
ls -la src/store/parameterStore.ts src/hooks/useDebouncedPersist.ts
```
</verification>

<success_criteria>
- useParameterStore provides all CRUD operations for per-endpoint parameter storage
- Store persists to localStorage via Zustand persist middleware
- useDebouncedPersist hook provides 300ms debounced autosave
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-url-parsing-type-inference/09-03-SUMMARY.md`
</output>
