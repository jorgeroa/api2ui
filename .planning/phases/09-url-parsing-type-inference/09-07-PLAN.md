---
phase: 09-url-parsing-type-inference
plan: 07
type: execute
wave: 4
depends_on: ["09-06"]
files_modified:
  - src/App.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Parameter values persist across browser sessions per endpoint"
    - "User can paste any URL with query params and see them parsed into editable form fields"
  artifacts:
    - path: "src/App.tsx"
      provides: "Integration wiring for persistence and URL parsing"
      contains: "endpoint="
  key_links:
    - from: "src/App.tsx"
      to: "ParameterForm"
      via: "endpoint prop"
      pattern: "endpoint=\\{.*selectedOperation"
    - from: "src/App.tsx"
      to: "ParameterForm"
      via: "rawUrl prop for direct API"
      pattern: "rawUrl=\\{url\\}"
---

<objective>
Wire App.tsx to close Phase 9 integration gaps: enable parameter persistence by passing endpoint prop, and expose URL parsing by showing ParameterForm for direct API URLs with query params.

Purpose: Phase 9 components (persistence store, URL parser) are fully implemented and tested but not wired in App.tsx. This plan completes the integration.

Output: App.tsx passes endpoint prop to ParameterForm for persistence, and shows parsed URL parameters for direct API URLs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-url-parsing-type-inference/09-VERIFICATION.md
@.planning/phases/09-url-parsing-type-inference/09-06-SUMMARY.md
@src/App.tsx
@src/components/forms/ParameterForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire endpoint prop for parameter persistence</name>
  <files>src/App.tsx</files>
  <action>
Add endpoint prop to both ParameterForm instances in App.tsx to enable parameter persistence.

**Sidebar layout (line ~161):**
```tsx
<ParameterForm
  parameters={selectedOperation.parameters}
  onSubmit={handleParameterSubmit}
  loading={loading}
  endpoint={`${parsedSpec.baseUrl}${selectedOperation.path}`}
/>
```

**Centered layout (line ~258):**
```tsx
<ParameterForm
  parameters={selectedOperation.parameters}
  onSubmit={handleParameterSubmit}
  loading={loading}
  endpoint={`${parsedSpec.baseUrl}${selectedOperation.path}`}
/>
```

The endpoint key format `{baseUrl}{path}` ensures:
- Persistence is per-operation (different endpoints have different saved values)
- Same operation across sessions gets restored values
- Type overrides are also persisted per-endpoint

This is purely additive - no changes to existing props.
  </action>
  <verify>
1. `npm run build` succeeds without errors
2. `grep -n "endpoint=" src/App.tsx` shows both ParameterForm instances have endpoint prop
3. Manual test: Load an OpenAPI spec, fill in parameters, refresh browser - values should persist
  </verify>
  <done>
Both ParameterForm instances in App.tsx pass endpoint prop, enabling:
- Parameter value persistence across sessions
- Type override persistence
- Reset All button visibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ParameterForm for direct API URLs with query params</name>
  <files>src/App.tsx</files>
  <action>
Add ParameterForm with rawUrl prop for direct API mode when URL has query params. This exposes the URL parsing feature to users.

**Conditional tree for direct API flow (rendering states):**

The direct API section should handle four distinct states:

```
Direct API Flow (!parsedSpec):
├── Loading state (loading === true)
│   └── Show loading indicator only
├── Error state (error !== null)
│   └── Show error message only
├── URL with params, no data yet (!loading && !error && url?.includes('?') && data === null)
│   └── Show ParameterForm with rawUrl (allows editing before first fetch)
├── URL with params, data present (!loading && !error && url?.includes('?') && data !== null)
│   └── Show ParameterForm with rawUrl + DynamicRenderer with data
├── URL without params, data present (!loading && !error && !url?.includes('?') && data !== null)
│   └── Show DynamicRenderer only (no params to edit)
└── No URL or no data
    └── Show nothing (handled by outer conditions)
```

**Implementation - modify the direct API URL flow section (around line ~289):**

```tsx
{/* Direct API URL flow */}
{!parsedSpec && !loading && !error && (
  <>
    {/* Show parsed URL parameters when URL has query string */}
    {url && url.includes('?') && (
      <div className="mb-6">
        <h3 className="text-lg font-semibold text-text mb-4">URL Parameters</h3>
        <ParameterForm
          parameters={[]}
          rawUrl={url}
          onSubmit={(values) => {
            // Reconstruct URL with modified params and re-fetch
            const baseUrl = url.split('?')[0]
            const params = new URLSearchParams(values).toString()
            const newUrl = params ? `${baseUrl}?${params}` : baseUrl
            fetchAndInfer(newUrl)
          }}
          loading={loading}
          endpoint={url.split('?')[0]}
        />
      </div>
    )}

    {/* Data rendering - show when data is present */}
    {schema && data !== null && (
      <DynamicRenderer
        data={data}
        schema={schema.rootType}
        path="$"
        depth={0}
      />
    )}
  </>
)}
```

**Key behavior for each state:**
1. **URL with params, no data:** User can edit params in form, click "Fetch Data" to make first request
2. **URL with params, data present:** User sees both form AND results - can modify params and re-fetch
3. **URL without params, data present:** No form shown (no params to edit), just the data
4. **Loading:** Neither form nor data (handled by outer !loading condition)
5. **Error:** Neither form nor data (handled by outer !error condition)

**Implementation details:**
- `parameters={[]}` is required prop but rawUrl takes precedence when provided
- `rawUrl={url}` triggers URL parsing via parseUrlParameters
- `endpoint={url.split('?')[0]}` uses base URL for persistence key
- onSubmit reconstructs URL with modified params and calls fetchAndInfer
- Condition `url.includes('?')` ensures we only show when there are query params
- "URL Parameters" heading provides context for the form section
  </action>
  <verify>
1. `npm run build` succeeds without errors
2. `grep -n "rawUrl=" src/App.tsx` shows ParameterForm with rawUrl prop
3. Manual test state verification:
   - Paste URL with query params (e.g., `https://jsonplaceholder.typicode.com/posts?userId=1`)
   - Before fetch completes: See "URL Parameters" section with editable fields
   - After fetch completes: See both parameter form AND data results
   - URL without params (e.g., `https://jsonplaceholder.typicode.com/posts`): No parameter form shown, just data
4. Modify a parameter value and click "Fetch Data" - request should use modified value
  </verify>
  <done>
Direct API URLs with query params show editable parameter form in all appropriate states:
- URL like `?page=1&limit=10` shows page and limit as editable fields
- Form visible both before and after data loads
- Users can modify values and re-fetch with updated params
- Parameter values persist for the base URL endpoint
- URLs without query params show data only (no empty form)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Build verification:**
   ```bash
   npm run build
   ```
   Must succeed without errors or type issues.

2. **Persistence verification (OpenAPI mode):**
   - Open app, paste an OpenAPI spec URL (e.g., Petstore)
   - Fill in parameter values
   - Refresh the page
   - Parameter values should be restored

3. **URL parsing verification (Direct API mode):**
   - Open app fresh (no spec loaded)
   - Paste URL with query params: `https://jsonplaceholder.typicode.com/posts?userId=1&_limit=5`
   - See "URL Parameters" section with userId and _limit as editable fields
   - Modify _limit to 10 and click "Fetch Data"
   - Request should use `_limit=10`

4. **Reset verification:**
   - In either mode, fill in values
   - "Reset All" button should appear
   - Click Reset All - values should clear
   - Refresh - values should stay cleared (not restore old values)

5. **Key link verification:**
   ```bash
   grep -E "endpoint=|rawUrl=" src/App.tsx
   ```
   Should show both props in use.
</verification>

<success_criteria>
1. Both ParameterForm instances in App.tsx have endpoint prop
2. Direct API flow includes ParameterForm with rawUrl when URL has query params
3. npm run build succeeds
4. Parameter values persist across browser refresh (OpenAPI mode)
5. URL query params display as editable fields (direct API mode)
6. Modified params are used when re-fetching
</success_criteria>

<output>
After completion, create `.planning/phases/09-url-parsing-type-inference/09-07-SUMMARY.md`
</output>
