---
phase: 09-url-parsing-type-inference
plan: 06
type: execute
wave: 3
depends_on: ["09-01", "09-02", "09-03", "09-04", "09-05"]
files_modified:
  - src/components/forms/ParameterForm.tsx
  - src/services/openapi/types.ts
autonomous: true

must_haves:
  truths:
    - "User can paste any URL with query params and see them parsed into editable form fields"
    - "Parameters are grouped by prefix into collapsible sections"
    - "Ungrouped parameters show at top, grouped sections follow"
    - "Parameter values persist across browser sessions per endpoint"
    - "Type inference determines input rendering (date picker, email input, etc.)"
    - "User can override inferred type via icon dropdown"
    - "Per-field clear (X button) removes single parameter value"
  artifacts:
    - path: "src/components/forms/ParameterForm.tsx"
      provides: "Integrated form with parsing, grouping, persistence, type icons"
      contains: "parseUrlParameters"
    - path: "src/services/openapi/types.ts"
      provides: "Extended ParsedParameter with inferredType field"
      contains: "inferredType"
  key_links:
    - from: "src/components/forms/ParameterForm.tsx"
      to: "parseUrlParameters"
      via: "import from urlParser"
      pattern: "import.*parseUrlParameters"
    - from: "src/components/forms/ParameterForm.tsx"
      to: "useParameterStore"
      via: "import from store"
      pattern: "import.*useParameterStore"
    - from: "src/components/forms/ParameterForm.tsx"
      to: "ParameterGroup"
      via: "renders grouped params in accordions"
      pattern: "<ParameterGroup"
    - from: "src/components/forms/ParameterForm.tsx"
      to: "useDebouncedPersist"
      via: "auto-save values"
      pattern: "useDebouncedPersist"
---

<objective>
Integrate URL parsing, type inference, grouping, and persistence into ParameterForm.

Purpose: This is the final integration that brings together all Phase 9 components. Users paste a URL and see smart, grouped, persistent form fields with type-appropriate inputs.

Output: ParameterForm that handles both OpenAPI params and raw URL params with full Phase 9 functionality.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-url-parsing-type-inference/09-CONTEXT.md

# All Phase 9 dependencies
@src/services/urlParser/parser.ts
@src/services/urlParser/typeInferrer.ts
@src/store/parameterStore.ts
@src/hooks/useDebouncedPersist.ts
@src/components/forms/ParameterGroup.tsx
@src/components/forms/TypeIcon.tsx
@src/components/forms/ParameterInput.tsx

# Existing form to extend
@src/components/forms/ParameterForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ParsedParameter Type</name>
  <files>src/services/openapi/types.ts</files>
  <action>
Add inferredType field to ParsedParameter for type inference results.

**Add to ParsedParameter interface:**
```typescript
export interface ParsedParameter {
  name: string
  in: 'query' | 'path' | 'header' | 'cookie'
  required: boolean
  description: string
  schema: {
    type: string
    format?: string
    enum?: unknown[]
    default?: unknown
    example?: unknown
    minimum?: number
    maximum?: number
    maxLength?: number
  }
  // NEW: Type inferred from value (for URL-parsed params)
  inferredType?: 'string' | 'number' | 'boolean' | 'date' | 'email' | 'url' | 'coordinates' | 'zip'
  // NEW: Array of values for array params (from URL parsing)
  values?: string[]
  // NEW: Whether this is an array parameter
  isArray?: boolean
}
```

This extends the existing type while maintaining backward compatibility with OpenAPI parsing.
  </action>
  <verify>
```bash
# Verify inferredType field added
grep "inferredType" src/services/openapi/types.ts
# TypeScript check
npx tsc --noEmit
```
  </verify>
  <done>
- ParsedParameter includes inferredType, values, isArray optional fields
- Existing OpenAPI parsing code unaffected (fields are optional)
- Type compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate All Components into ParameterForm</name>
  <files>src/components/forms/ParameterForm.tsx</files>
  <action>
Refactor ParameterForm to integrate URL parsing, grouping, persistence, and type inference.

**New props:**
```typescript
interface ParameterFormProps {
  parameters: ParsedParameter[]
  onSubmit: (values: Record<string, string>) => void
  loading?: boolean
  endpoint?: string           // NEW: For persistence key
  rawUrl?: string             // NEW: Raw URL to parse (alternative to parameters)
}
```

**Implementation flow:**

1. **Determine parameters source:**
   ```typescript
   const effectiveParams = useMemo(() => {
     if (rawUrl) {
       const parsed = parseUrlParameters(rawUrl)
       // Store warnings for display
       return parsed.parameters
     }
     return parameters
   }, [rawUrl, parameters])
   ```

2. **Apply type inference to all params:**
   ```typescript
   const paramsWithTypes = useMemo(() => {
     return effectiveParams.map(param => ({
       ...param,
       inferredType: param.inferredType ?? inferParameterType(param.name, values[param.name]).type
     }))
   }, [effectiveParams, values])
   ```

3. **Extract groups:**
   ```typescript
   const { grouped, ungrouped } = useMemo(() => {
     const groups = new Map<string, ParsedParameter[]>()
     const ungroupedList: ParsedParameter[] = []

     for (const param of paramsWithTypes) {
       const prefix = extractGroupPrefix(param.name)
       if (prefix) {
         if (!groups.has(prefix)) groups.set(prefix, [])
         groups.get(prefix)!.push(param)
       } else {
         ungroupedList.push(param)
       }
     }

     return { grouped: groups, ungrouped: ungroupedList }
   }, [paramsWithTypes])
   ```

4. **Load persisted values:**
   ```typescript
   const { getValues, setValue, clearValue, getTypeOverride, setTypeOverride } = useParameterStore()
   const persistedValues = endpoint ? getValues(endpoint) : {}

   // Initialize state with persisted values
   const [values, setValues] = useState<Record<string, string>>(() => ({
     ...getDefaultValues(effectiveParams),
     ...persistedValues
   }))
   ```

5. **Auto-save with debounce:**
   ```typescript
   useDebouncedPersist(endpoint ?? '', values)
   ```

6. **Handle type overrides:**
   ```typescript
   const handleTypeOverride = (name: string, type: string) => {
     if (endpoint) {
       setTypeOverride(endpoint, name, type)
     }
   }
   ```

7. **Render structure:**
   ```tsx
   <form onSubmit={handleSubmit}>
     {/* Parse warnings (if any) */}
     {warnings.length > 0 && <WarningBanner warnings={warnings} />}

     {/* Ungrouped params (required first, then optional) */}
     {ungroupedRequired.map(param => (
       <ParameterInput
         key={param.name}
         parameter={param}
         value={values[param.name] ?? ''}
         onChange={(v) => handleChange(param.name, v)}
         inferredType={param.inferredType}
         typeOverride={endpoint ? getTypeOverride(endpoint, param.name) : undefined}
         onTypeOverride={(t) => handleTypeOverride(param.name, t)}
         onClear={() => handleClear(param.name)}
       />
     ))}

     {/* Grouped params in accordions */}
     {Array.from(grouped.entries()).map(([groupName, groupParams]) => (
       <ParameterGroup key={groupName} groupName={groupName}>
         {groupParams.map(param => (
           <ParameterInput
             key={param.name}
             parameter={param}
             value={values[param.name] ?? ''}
             onChange={(v) => handleChange(param.name, v)}
             inferredType={param.inferredType}
             typeOverride={endpoint ? getTypeOverride(endpoint, param.name) : undefined}
             onTypeOverride={(t) => handleTypeOverride(param.name, t)}
             onClear={() => handleClear(param.name)}
           />
         ))}
       </ParameterGroup>
     ))}

     {/* Reset all button */}
     {endpoint && (
       <button type="button" onClick={handleResetAll}>Reset All</button>
     )}

     {/* Submit */}
     <button type="submit">Fetch Data</button>
   </form>
   ```

8. **Add clear handlers:**
   ```typescript
   const handleClear = (name: string) => {
     setValues(prev => {
       const { [name]: _, ...rest } = prev
       return rest
     })
     if (endpoint) {
       clearValue(endpoint, name)
     }
   }

   const handleResetAll = () => {
     setValues({})
     if (endpoint) {
       clearEndpoint(endpoint)
     }
   }
   ```

**Also update ParameterInput to add onClear prop and X button.**
  </action>
  <verify>
```bash
# Verify all imports
grep "parseUrlParameters" src/components/forms/ParameterForm.tsx
grep "useParameterStore" src/components/forms/ParameterForm.tsx
grep "useDebouncedPersist" src/components/forms/ParameterForm.tsx
grep "ParameterGroup" src/components/forms/ParameterForm.tsx
grep "inferParameterType" src/components/forms/ParameterForm.tsx

# TypeScript check
npx tsc --noEmit

# Build check
npm run build
```
  </verify>
  <done>
- ParameterForm accepts rawUrl prop for URL parsing
- Parameters grouped into accordion sections
- Values persisted per endpoint with debounced autosave
- Type inference applied to all parameters
- Type override dropdown functional
- Per-field clear (X button) working
- Reset all clears endpoint values
- Build passes without errors
  </done>
</task>

</tasks>

<verification>
```bash
# Full build verification
npm run build

# TypeScript compilation
npx tsc --noEmit

# Run all tests
npm test
```
</verification>

<success_criteria>
- User can paste URL and see parsed parameters as form fields
- Parameters grouped by prefix into collapsible accordions
- Ungrouped parameters appear at top, groups below
- Values persist across sessions (verify in localStorage)
- Type icons appear for inferred types
- Type dropdown allows override
- Per-field clear removes single value
- Reset all clears endpoint
- Build and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-url-parsing-type-inference/09-06-SUMMARY.md`
</output>
