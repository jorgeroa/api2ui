---
phase: 10-layout-system
plan: 05
type: execute
wave: 3
depends_on: ["10-04"]
files_modified:
  - src/App.tsx
autonomous: false

must_haves:
  truths:
    - "User can switch between sidebar, top bar, split view layouts with a visible control"
    - "Layout choice persists per endpoint across sessions"
    - "On mobile (viewport < 768px), layout defaults to collapsible drawer"
    - "Layout transitions are smooth without losing form state"
  artifacts:
    - path: "src/App.tsx"
      provides: "Main app with layout system integrated"
      contains: "LayoutContainer"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/layout/LayoutContainer.tsx"
      via: "import and usage"
      pattern: "import.*LayoutContainer"
---

<objective>
Integrate the LayoutContainer into App.tsx, replacing the current fixed layout with the new user-switchable layout system. Includes human verification checkpoint to test all layouts.

Purpose: This is the final integration that makes the layout system available to users. Covers all LAYOUT requirements working together.

Output: Working app with layout switching capability.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-layout-system/10-CONTEXT.md
@.planning/phases/10-layout-system/10-04-SUMMARY.md
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate LayoutContainer into App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Modify App.tsx to use LayoutContainer for the main content area.

**Current structure (simplified):**
```tsx
// Multi-endpoint (OpenAPI) mode
<div className="flex min-h-screen">
  <Sidebar ... />
  <main>
    <URLInput />
    <ParameterForm ... />
    <DynamicRenderer ... />
  </main>
</div>

// Single endpoint / direct URL mode
<div className="min-h-screen">
  <URLInput />
  <ParameterForm ... />
  <DynamicRenderer ... />
</div>
```

**New structure:**
Wrap the ParameterForm and results (DynamicRenderer) in LayoutContainer.

**Key changes:**

1. **Import LayoutContainer:**
```typescript
import { LayoutContainer } from './components/layout/LayoutContainer'
```

2. **Derive endpoint for layout preference:**
For OpenAPI mode: `${parsedSpec.baseUrl}${selectedOperation.path}`
For direct URL mode: base URL without query params

3. **Separate parameters and results into distinct ReactNode:**
```tsx
const parametersUI = (
  <ParameterForm
    parameters={selectedOperation.parameters}
    onSubmit={handleParameterSubmit}
    loading={loading}
    endpoint={endpoint}
  />
)

const resultsUI = (
  <>
    {error && <ErrorDisplay error={error} />}
    {loading && <SkeletonTable />}
    {schema && data !== null && (
      <DynamicRenderer data={data} schema={schema.rootType} path="$" depth={0} />
    )}
  </>
)
```

4. **Use LayoutContainer:**
```tsx
<LayoutContainer
  parameters={parametersUI}
  results={resultsUI}
  endpoint={endpoint}
/>
```

5. **Multi-endpoint (OpenAPI with Sidebar):**
Keep the existing Sidebar component for operation navigation. The layout switcher applies to the parameter/results area within the main content, not the operation sidebar.

```tsx
<div className="flex min-h-screen">
  <Sidebar ... />
  <main className="flex-1">
    {/* Header, URLInput stay outside LayoutContainer */}
    <LayoutContainer
      parameters={parametersUI}
      results={resultsUI}
      endpoint={endpoint}
    />
  </main>
</div>
```

6. **Single endpoint / direct URL mode:**
Same pattern - wrap parameter form and results in LayoutContainer.

**Preserve existing functionality:**
- Configure mode indicator bar
- Skip to main content link
- ThemeApplier
- ConfigToggle and ConfigPanel
- Error handling
- Loading states

**Where LayoutSwitcher appears:**
LayoutSwitcher is rendered by LayoutContainer, so it will appear at the top of the content area (above parameters/results). This aligns with CONTEXT.md: "Lives in top toolbar alongside existing controls".

Actually, looking at the context more carefully - it should be in the "top toolbar". Current App.tsx doesn't have an explicit toolbar. For now, LayoutContainer renders the switcher at the top of its own area. Future enhancement could move it to a proper toolbar.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
App runs without errors: `npm run dev` and check browser console
  </verify>
  <done>
App.tsx uses LayoutContainer to wrap parameters and results. Layout switcher visible on desktop. Mobile triggers drawer.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Layout System</name>
  <what-built>
Complete layout system with four modes:
- Sidebar layout (parameters left, results right)
- Top bar layout (parameters in grid above results)
- Split view layout (30/70 vertical split)
- Mobile drawer (slide-up bottom sheet on mobile)
  </what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Open browser to http://localhost:5173

**Desktop Tests (viewport > 768px):**
3. Paste an API URL with parameters (e.g., https://pokeapi.co/api/v2/pokemon?limit=10)
4. Verify layout switcher appears (3 icon buttons in top area)
5. Click each layout icon and verify:
   - Sidebar: Parameters on left (256px wide), results on right
   - Top bar: Parameters in grid at top, results below
   - Split: 30% parameters, 70% results (vertical split)
6. Switch layouts and verify:
   - Form values are preserved (no data loss)
   - Transitions are smooth (no jarring jumps)
7. Refresh page - verify selected layout persists

**Mobile Tests (viewport < 768px or use DevTools mobile emulation):**
8. Resize to mobile width (< 768px) or use Chrome DevTools device emulation
9. Verify layout switcher is hidden
10. Verify floating button appears to open drawer
11. Tap button - drawer should slide up from bottom
12. Verify drawer has visible handle at top
13. Tap backdrop - drawer should close
14. Verify results are visible when drawer is closed

**OpenAPI Spec Tests:**
15. Paste an OpenAPI spec URL (e.g., https://petstore3.swagger.io/api/v3/openapi.json)
16. Verify operation sidebar still works
17. Verify layout switching applies to the parameter/results area (not the operation sidebar)

**Edge Cases:**
18. Try layout with no parameters - should still work
19. Try layout with many parameters - should scroll properly
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. App.tsx imports and uses LayoutContainer
2. TypeScript compiles without errors
3. Layout switcher visible on desktop
4. Mobile shows drawer trigger and drawer works
5. Layout persists per endpoint
6. Form state preserved during layout switches
</verification>

<success_criteria>
- User can switch between sidebar, top bar, and split view layouts
- Layout choice persists per endpoint across browser sessions
- Mobile automatically uses drawer layout
- Smooth transitions without form state loss
- All existing functionality preserved (config mode, theming, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/10-layout-system/10-05-SUMMARY.md`
</output>
