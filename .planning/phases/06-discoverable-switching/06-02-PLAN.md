---
phase: 06-discoverable-switching
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/config/FieldConfigPopover.tsx
  - src/hooks/useLongPress.ts
  - src/components/renderers/TableRenderer.tsx
  - src/components/renderers/CardListRenderer.tsx
  - src/components/renderers/DetailRenderer.tsx
  - src/components/renderers/ListRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "Right-clicking a field in any renderer opens a contextual config popover"
    - "Long-pressing a field on mobile opens the same popover"
    - "Popover contains visibility toggle, custom label input, and component type selector"
    - "Changes are staged in the popover and only committed when Apply is clicked"
    - "Canceling or closing the popover discards staged changes"
    - "Popover initializes from current configStore values on open and resets on close"
  artifacts:
    - path: "src/components/config/FieldConfigPopover.tsx"
      provides: "Right-click config popover with staged visibility, label, and component type controls"
      exports: ["FieldConfigPopover"]
    - path: "src/hooks/useLongPress.ts"
      provides: "Mobile long-press detection hook"
      exports: ["useLongPress"]
  key_links:
    - from: "src/components/config/FieldConfigPopover.tsx"
      to: "src/store/configStore.ts"
      via: "Apply button calls setFieldConfig to commit staged changes"
      pattern: "setFieldConfig|setFieldLabel|toggleFieldVisibility|setFieldComponentType"
    - from: "src/components/renderers/TableRenderer.tsx"
      to: "src/components/config/FieldConfigPopover.tsx"
      via: "onContextMenu handler opens popover"
      pattern: "onContextMenu|FieldConfigPopover"
---

<objective>
Create a FieldConfigPopover for right-click/long-press contextual field configuration and integrate it into all renderers. Users can right-click any field to configure visibility, label, and component type with staged changes.

Purpose: Provides per-element inline configuration without entering Configure mode, making field customization contextual and discoverable (DSC-03).
Output: FieldConfigPopover component, useLongPress hook, and renderer integrations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/config/FieldControls.tsx
@src/store/configStore.ts
@src/types/config.ts
@src/components/renderers/TableRenderer.tsx
@src/components/renderers/CardListRenderer.tsx
@src/components/renderers/DetailRenderer.tsx
@src/components/renderers/PrimitiveRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLongPress hook and FieldConfigPopover component</name>
  <files>src/hooks/useLongPress.ts, src/components/config/FieldConfigPopover.tsx</files>
  <action>
    **1. Create src/hooks/useLongPress.ts:**

    Custom hook for mobile long-press detection:
    - Takes a callback function and optional duration (default 800ms)
    - Returns { onTouchStart, onTouchEnd, onTouchMove } event handlers
    - onTouchStart starts a setTimeout timer
    - onTouchEnd and onTouchMove cancel the timer (prevents scroll conflict)
    - Stores timer ID in useRef for proper cleanup
    - Returns cleanup-safe handlers

    **2. Create src/components/config/FieldConfigPopover.tsx:**

    Props interface:
    - fieldPath: string
    - fieldName: string
    - fieldValue: unknown (for determining available component types)
    - position: { x: number; y: number } (click coordinates)
    - onClose: () => void
    - onOpenConfigPanel?: (fieldPath: string) => void (for cross-navigation, optional)

    Component behavior:
    1. On mount, initialize staged state from configStore.getFieldConfig(fieldPath):
       - stagedVisible: boolean (from config.visible)
       - stagedLabel: string (from config.label || '')
       - stagedComponentType: string (from config.componentType || '')

    2. Render a fixed-position panel at click coordinates:
       - Use a simple div with `fixed` positioning at (position.x, position.y)
       - Add viewport boundary detection: if position.x + 256 > window.innerWidth, flip to left side; if position.y + panelHeight > window.innerHeight, flip upward
       - Tailwind: `fixed bg-white rounded-lg shadow-xl border border-gray-200 p-4 z-50 w-64`

    3. Popover content:
       a. Header: "Configure Field" + field name in mono text
       b. Visibility toggle: checkbox with label "Visible"
       c. Custom label: text input with placeholder "Custom label..." and the original fieldName shown as gray helper text
       d. Component type: select dropdown populated from getAvailableRenderModes(fieldValue, fieldName) for primitives. For non-primitive fields, either hide or show appropriate options.
       e. Divider
       f. Footer buttons: "Apply" (blue, commits changes) and "Cancel" (gray, discards)
       g. "More settings..." link at bottom (calls onOpenConfigPanel if provided)

    4. Apply button handler:
       - Call configStore methods to commit staged changes:
         - If stagedVisible !== currentConfig.visible: toggleFieldVisibility
         - If stagedLabel !== (currentConfig.label || ''): setFieldLabel
         - If stagedComponentType !== (currentConfig.componentType || ''): setFieldComponentType
       - Then call onClose()

    5. Cancel/close: just call onClose() without committing

    6. Click-outside detection: add a transparent backdrop div behind the popover that calls onClose on click

    7. Escape key: add keydown listener for Escape to close

    Important:
    - Do NOT use Headless UI Popover here since we need manual position control at click coordinates. A simple div with fixed positioning and a backdrop is sufficient.
    - Import getAvailableRenderModes from '../renderers/PrimitiveRenderer' for component type options
    - Prevent right-click event propagation on the popover itself
  </action>
  <verify>
    - Both files exist
    - `npx tsc --noEmit` passes
    - FieldConfigPopover exports correctly
    - useLongPress exports correctly
    - Popover has Apply/Cancel buttons
    - Staged state pattern implemented (not live updates)
  </verify>
  <done>FieldConfigPopover renders at click position with staged visibility, label, and component type controls; useLongPress hook handles mobile long-press detection</done>
</task>

<task type="auto">
  <name>Task 2: Integrate FieldConfigPopover into renderers via right-click and long-press</name>
  <files>src/components/renderers/TableRenderer.tsx, src/components/renderers/CardListRenderer.tsx, src/components/renderers/DetailRenderer.tsx, src/components/renderers/ListRenderer.tsx</files>
  <action>
    Add right-click (contextmenu) and long-press support to field elements across all four renderers. The pattern is the same for each:

    **Shared pattern for each renderer:**

    1. Add state to track popover: `const [popoverState, setPopoverState] = useState<{ fieldPath: string; fieldName: string; fieldValue: unknown; position: { x: number; y: number } } | null>(null)`

    2. Create handler:
    ```tsx
    const handleFieldContextMenu = (e: React.MouseEvent, fieldPath: string, fieldName: string, fieldValue: unknown) => {
      e.preventDefault()
      e.stopPropagation()
      setPopoverState({ fieldPath, fieldName, fieldValue, position: { x: e.clientX, y: e.clientY } })
    }
    ```

    3. Import useLongPress and create per-field long-press handlers using the same callback pattern

    4. Render FieldConfigPopover conditionally when popoverState is not null

    **Per-renderer specifics:**

    **TableRenderer.tsx:**
    - Add onContextMenu to each `<td>` cell that renders field data
    - The fieldPath is the cell's field path (e.g., `$[].fieldName`)
    - Import useLongPress, attach touch handlers to same cells

    **CardListRenderer.tsx:**
    - Add onContextMenu to each field row/element within cards
    - The fieldPath follows the card field pattern
    - Attach touch handlers for mobile

    **DetailRenderer.tsx:**
    - Add onContextMenu to each field value element in the detail view
    - The fieldPath is the detail field path
    - Attach touch handlers for mobile

    **ListRenderer.tsx:**
    - Add onContextMenu to each list item's content area
    - Attach touch handlers for mobile

    Important:
    - Only prevent default context menu on the specific field elements, NOT on the entire renderer
    - Each renderer should only have ONE FieldConfigPopover rendered at a time (popoverState stores the single active field)
    - When popover closes, set popoverState to null
    - Import FieldConfigPopover from '../config/FieldConfigPopover' and useLongPress from '../../hooks/useLongPress'
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All four renderers import FieldConfigPopover
    - All four renderers have onContextMenu handlers on field elements
    - All four renderers conditionally render FieldConfigPopover
    - `npm run build` succeeds
  </verify>
  <done>Right-clicking any field in any renderer opens the FieldConfigPopover at click position; long-press works on mobile; only one popover open at a time per renderer</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` succeeds
3. FieldConfigPopover.tsx exists with Apply/Cancel staged change pattern
4. useLongPress.ts exists with timer-based touch detection
5. All four renderers (Table, CardList, Detail, List) have contextmenu handlers
6. Right-click on a field opens popover at cursor position
7. Changes are only applied when Apply is clicked
8. Cancel/Escape/click-outside closes popover without applying
</verification>

<success_criteria>
- Right-clicking any field in any renderer opens a contextual config popover
- Popover shows visibility toggle, label input, and component type selector
- Changes are staged and only committed on Apply
- Cancel discards changes
- Mobile long-press triggers the same popover
- Popover respects viewport boundaries
</success_criteria>

<output>
After completion, create `.planning/phases/06-discoverable-switching/06-02-SUMMARY.md`
</output>
