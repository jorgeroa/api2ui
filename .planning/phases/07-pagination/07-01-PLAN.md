---
phase: 07-pagination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/usePagination.ts
  - src/types/config.ts
  - src/store/configStore.ts
autonomous: true

must_haves:
  truths:
    - "usePagination hook calculates correct page boundaries, total pages, and smart page numbers"
    - "ConfigStore persists per-path pagination preferences (itemsPerPage, currentPage) in localStorage"
    - "Changing itemsPerPage resets currentPage to 1"
  artifacts:
    - path: "src/hooks/usePagination.ts"
      provides: "Pagination state calculation hook"
      exports: ["usePagination"]
    - path: "src/types/config.ts"
      provides: "PaginationConfig interface"
      contains: "PaginationConfig"
    - path: "src/store/configStore.ts"
      provides: "Pagination state and actions in ConfigStore"
      contains: "paginationConfigs"
  key_links:
    - from: "src/store/configStore.ts"
      to: "src/types/config.ts"
      via: "PaginationConfig type import"
      pattern: "import.*PaginationConfig.*config"
    - from: "src/store/configStore.ts"
      to: "zustand/middleware persist partialize"
      via: "paginationConfigs included in persisted state"
      pattern: "paginationConfigs"
---

<objective>
Create the pagination foundation: a reusable usePagination hook for calculating page state, PaginationConfig type for persistence, and ConfigStore extensions for per-endpoint pagination preferences.

Purpose: Provides all the logic and state management needed before building pagination UI and integrating with renderers.
Output: Three files — hook, type, store extension — ready for Plan 02 to consume.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-pagination/07-RESEARCH.md
@src/types/config.ts
@src/store/configStore.ts
@src/hooks/useAPIFetch.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePagination hook</name>
  <files>src/hooks/usePagination.ts</files>
  <action>
Create a new file `src/hooks/usePagination.ts` with a custom React hook that encapsulates pagination logic.

Interface for the hook input:
```typescript
interface UsePaginationProps {
  totalItems: number
  itemsPerPage: number
  currentPage: number
}
```

Interface for the hook return:
```typescript
interface UsePaginationReturn {
  currentPage: number    // Clamped to valid range [1, totalPages]
  totalPages: number     // Math.ceil(totalItems / itemsPerPage)
  firstIndex: number     // (currentPage - 1) * itemsPerPage
  lastIndex: number      // Math.min(firstIndex + itemsPerPage, totalItems)
  hasNextPage: boolean
  hasPrevPage: boolean
  pageNumbers: (number | '...')[]  // Smart truncation array
}
```

Implementation details:
- Clamp currentPage to `Math.max(1, Math.min(currentPage, totalPages))` to handle stale page values
- Handle edge case where totalPages is 0 (empty data): return currentPage=1, totalPages=0, empty pageNumbers
- Use `useMemo` for the pageNumbers calculation (depends on totalPages and validPage)
- Smart page number truncation algorithm: if totalPages <= 7, show all; otherwise show first page, last page, current +/- 1, with '...' ellipses where gaps exist
- Export both the hook function and the interfaces (for use in PaginationControls props)

Do NOT use useState — this hook is a pure calculation from inputs. The state lives in ConfigStore.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/hooks/usePagination.ts` (or full project build `npm run build` passes).
Verify exported types and function exist.
  </verify>
  <done>usePagination hook exists, exports UsePaginationProps, UsePaginationReturn, and usePagination function. Calculates correct boundaries and smart page numbers.</done>
</task>

<task type="auto">
  <name>Task 2: Add PaginationConfig type and extend ConfigStore</name>
  <files>src/types/config.ts, src/store/configStore.ts</files>
  <action>
**In `src/types/config.ts`:**

Add a new `PaginationConfig` interface:
```typescript
export interface PaginationConfig {
  itemsPerPage: number
  currentPage: number
}
```

Add `paginationConfigs` to ConfigState:
```typescript
export interface ConfigState {
  // ... existing fields unchanged
  paginationConfigs: Record<string, PaginationConfig>  // keyed by field path (e.g., "$")
}
```

**In `src/store/configStore.ts`:**

1. Import `PaginationConfig` from config types.

2. Add to the ConfigStore interface:
```typescript
// Pagination
setPaginationConfig: (path: string, config: Partial<PaginationConfig>) => void
getPaginationConfig: (path: string, defaultItemsPerPage: number) => PaginationConfig
```

3. Add initial state in the create block:
```typescript
paginationConfigs: {},
```

4. Implement the actions:
- `setPaginationConfig`: merges partial config into existing config for path, with defaults `{ itemsPerPage: 20, currentPage: 1 }` as base
- `getPaginationConfig`: returns stored config for path, or `{ itemsPerPage: defaultItemsPerPage, currentPage: 1 }` if none exists

5. Add `paginationConfigs` to the `partialize` function in the persist config so it gets saved to localStorage.

6. Add `paginationConfigs` clearing in `resetConfig` action (set to `{}`).

7. Bump persist version from 1 to 2 (since we added new persisted state).

Do NOT add paginationConfigs to `clearFieldConfigs` — that's field-specific, not pagination.
  </action>
  <verify>
`npm run build` passes with no type errors. Verify the store exports the new actions by checking types compile.
  </verify>
  <done>PaginationConfig type exported from config.ts. ConfigStore has paginationConfigs state, setPaginationConfig and getPaginationConfig actions, and paginationConfigs is persisted to localStorage.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes with no errors
2. `src/hooks/usePagination.ts` exports usePagination function
3. `src/types/config.ts` exports PaginationConfig interface
4. `src/store/configStore.ts` includes paginationConfigs in state and partialize
</verification>

<success_criteria>
- usePagination hook calculates correct firstIndex/lastIndex for any page
- usePagination clamps page to valid range (no page 5 when only 2 pages exist)
- Smart page numbers produce correct truncation (e.g., [1, '...', 4, 5, 6, '...', 10])
- ConfigStore persists paginationConfigs to localStorage via Zustand persist
- getPaginationConfig returns sensible defaults when no config exists
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-pagination/07-01-SUMMARY.md`
</output>
