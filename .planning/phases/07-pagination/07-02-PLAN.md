---
phase: 07-pagination
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/components/pagination/PaginationControls.tsx
  - src/components/renderers/TableRenderer.tsx
  - src/components/renderers/CardListRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "Tables with >20 items show pagination controls at the bottom"
    - "Cards with >12 items show pagination controls at the bottom"
    - "Page navigation has prev/next buttons, clickable page numbers, and 'Showing X-Y of Z' status"
    - "Items-per-page selector allows choosing density (10, 20, 50, 100)"
    - "Changing items-per-page resets to page 1"
    - "Pagination preferences persist across page refresh"
  artifacts:
    - path: "src/components/pagination/PaginationControls.tsx"
      provides: "Shared pagination UI component"
      exports: ["PaginationControls"]
    - path: "src/components/renderers/TableRenderer.tsx"
      provides: "Paginated table rendering"
      contains: "usePagination"
    - path: "src/components/renderers/CardListRenderer.tsx"
      provides: "Paginated card rendering"
      contains: "usePagination"
  key_links:
    - from: "src/components/renderers/TableRenderer.tsx"
      to: "src/hooks/usePagination.ts"
      via: "usePagination hook import"
      pattern: "import.*usePagination"
    - from: "src/components/renderers/TableRenderer.tsx"
      to: "src/store/configStore.ts"
      via: "getPaginationConfig and setPaginationConfig"
      pattern: "getPaginationConfig|setPaginationConfig"
    - from: "src/components/renderers/CardListRenderer.tsx"
      to: "src/hooks/usePagination.ts"
      via: "usePagination hook import"
      pattern: "import.*usePagination"
    - from: "src/components/renderers/CardListRenderer.tsx"
      to: "src/store/configStore.ts"
      via: "getPaginationConfig and setPaginationConfig"
      pattern: "getPaginationConfig|setPaginationConfig"
    - from: "src/components/pagination/PaginationControls.tsx"
      to: "renderers"
      via: "rendered conditionally when data.length > itemsPerPage"
      pattern: "PaginationControls"
---

<objective>
Build the PaginationControls component and integrate pagination into TableRenderer and CardListRenderer, completing the full pagination feature.

Purpose: Users see paginated data when arrays exceed thresholds (20 for tables, 12 for cards), with full navigation controls and persistent preferences.
Output: Working pagination in both table and card views with shared accessible controls.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-pagination/07-RESEARCH.md
@.planning/phases/07-pagination/07-01-SUMMARY.md
@src/hooks/usePagination.ts
@src/types/config.ts
@src/store/configStore.ts
@src/components/renderers/TableRenderer.tsx
@src/components/renderers/CardListRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PaginationControls component</name>
  <files>src/components/pagination/PaginationControls.tsx</files>
  <action>
Create directory `src/components/pagination/` and file `PaginationControls.tsx`.

Props interface:
```typescript
interface PaginationControlsProps {
  currentPage: number
  totalPages: number
  totalItems: number
  itemsPerPage: number
  pageNumbers: (number | '...')[]
  onPageChange: (page: number) => void
  onItemsPerPageChange: (items: number) => void
  itemsPerPageOptions?: number[]  // Default: [10, 20, 50, 100]
}
```

Implementation:
- Wrap in `<nav aria-label="Pagination Navigation">` for accessibility
- Three sections in a flex row (justify-between):
  1. **Left — Status:** "Showing {firstItem}-{lastItem} of {totalItems}" (text-sm, text-gray-600). Calculate firstItem = (currentPage - 1) * itemsPerPage + 1, lastItem = Math.min(currentPage * itemsPerPage, totalItems).
  2. **Center — Page navigation:**
     - "Prev" button: calls onPageChange(currentPage - 1), disabled when currentPage === 1, aria-label="Previous page"
     - Page number buttons: map over pageNumbers array. For '...' entries, render `<span aria-hidden="true">...</span>`. For number entries, render `<button>` with aria-label="Go to page {n}", aria-current="page" when active, visual highlight (bg-blue-600 text-white) for active page, border-border hover:bg-surface for inactive.
     - "Next" button: calls onPageChange(currentPage + 1), disabled when currentPage === totalPages, aria-label="Next page"
     - All buttons: min-w-[36px] for consistent sizing, px-2 py-1 text-sm
  3. **Right — Items per page:** `<label>` "Per page:" + `<select>` with options [10, 20, 50, 100]. Select calls onItemsPerPageChange(Number(value)). Style: border border-border rounded px-2 py-1 text-sm bg-background.

- Disabled buttons: opacity-50 cursor-not-allowed
- Responsive: On small screens, hide the status text (hidden sm:block on the status div). Page numbers and per-page selector always visible.
- Use theme-aware classes: bg-background, text-text, border-border, bg-surface for hover states — consistent with existing renderers.
- The component is purely presentational — no state, no store access. All state comes through props.
  </action>
  <verify>
`npm run build` passes. Component file exists and exports PaginationControls.
  </verify>
  <done>PaginationControls component renders accessible pagination nav with prev/next, page numbers, status indicator, and items-per-page selector.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate pagination into TableRenderer and CardListRenderer</name>
  <files>src/components/renderers/TableRenderer.tsx, src/components/renderers/CardListRenderer.tsx</files>
  <action>
**In both renderers, apply the same integration pattern:**

1. Add imports at the top:
```typescript
import { usePagination } from '../../hooks/usePagination'
import { PaginationControls } from '../pagination/PaginationControls'
```

2. Add `getPaginationConfig` and `setPaginationConfig` to the destructured useConfigStore() call (alongside existing destructured values).

3. After the early returns (schema/data validation, empty array check) and before the rendering logic, add pagination state:

**For TableRenderer** (default 20 items per page):
```typescript
const paginationConfig = getPaginationConfig(path, 20)
const pagination = usePagination({
  totalItems: data.length,
  itemsPerPage: paginationConfig.itemsPerPage,
  currentPage: paginationConfig.currentPage,
})

const paginatedData = data.slice(pagination.firstIndex, pagination.lastIndex)

const handlePageChange = (page: number) => {
  setPaginationConfig(path, { currentPage: page })
}

const handleItemsPerPageChange = (items: number) => {
  setPaginationConfig(path, { itemsPerPage: items, currentPage: 1 })
}
```

**For CardListRenderer** (default 12 items per page):
Same pattern but with `getPaginationConfig(path, 12)`.

4. **TableRenderer changes:**
   - Replace `data.map((item, rowIndex) => {` with `paginatedData.map((item, paginatedIndex) => {`
   - IMPORTANT: The `rowIndex` used for zebra striping (`isEven`) should use `paginatedIndex` (local to the page)
   - The `rowIndex` used for path construction and drilldown must be the GLOBAL index: `const globalIndex = pagination.firstIndex + paginatedIndex`
   - Update path references: `${path}[${globalIndex}]` instead of `${path}[${rowIndex}]`
   - Use `globalIndex` for key as well: `key={globalIndex}`
   - After the scroll container div's closing tag (after `</div>` that wraps header+rows), add the PaginationControls conditionally:
   ```tsx
   {data.length > paginationConfig.itemsPerPage && (
     <PaginationControls
       currentPage={pagination.currentPage}
       totalPages={pagination.totalPages}
       totalItems={data.length}
       itemsPerPage={paginationConfig.itemsPerPage}
       pageNumbers={pagination.pageNumbers}
       onPageChange={handlePageChange}
       onItemsPerPageChange={handleItemsPerPageChange}
     />
   )}
   ```
   Place this INSIDE the outer border div, after the scroll container but before the DetailModal.

5. **CardListRenderer changes:**
   - Replace `data.map((item, index) => {` with `paginatedData.map((item, paginatedIndex) => {`
   - Calculate `const globalIndex = pagination.firstIndex + paginatedIndex`
   - Update all `index` references to use `globalIndex` for paths and keys, `paginatedIndex` for anything page-local
   - After the grid div's closing `</div>`, add PaginationControls with same conditional pattern
   - Place PaginationControls between the grid and the DetailModal

6. **Do NOT paginate when data is below threshold.** The conditional rendering (`data.length > paginationConfig.itemsPerPage`) handles this — when below threshold, PaginationControls is hidden and paginatedData === data (since slice covers full array).

7. **Preserve all existing functionality:** popover state, context menus, cross-navigation events, field ordering, hero images, etc. Only change is data source (paginatedData instead of data) and adding PaginationControls at the bottom.
  </action>
  <verify>
1. `npm run build` passes with no errors
2. `npm run dev` — load an API with >20 items (e.g., JSONPlaceholder /posts which has 100 items)
3. Verify table shows first 20 rows with pagination controls at bottom
4. Click page 2 — rows 21-40 shown, "Showing 21-40 of 100" displayed
5. Change items per page to 50 — resets to page 1, shows 50 rows
6. Switch to card view — cards paginated at 12 per page
7. Refresh page — pagination preferences retained
  </verify>
  <done>TableRenderer paginates at 20 items, CardListRenderer at 12 items. Page navigation works with prev/next/numbers. Items-per-page is configurable. Preferences persist in localStorage.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes with zero errors
2. Table view: API with 100 items shows first 20 rows + pagination controls
3. Card view: Same API shows first 12 cards + pagination controls
4. "Showing 1-20 of 100" status text is visible
5. Prev button disabled on page 1, Next button disabled on last page
6. Clicking page number navigates correctly
7. Items-per-page selector changes density and resets to page 1
8. Page refresh retains items-per-page preference
9. APIs with ≤20 items (tables) or ≤12 items (cards) show NO pagination controls
10. Smart page truncation shows ellipsis for large page counts (test with 100 items, 10 per page = 10 pages)
</verification>

<success_criteria>
- Tables with >20 items are automatically paginated
- Cards with >12 items are automatically paginated
- Pagination shows prev/next, page numbers with smart truncation, and "Showing X-Y of Z"
- Items-per-page is configurable via dropdown selector
- Preferences persist per-path across page refresh via ConfigStore localStorage
- Small datasets show no pagination controls
- All existing renderer functionality preserved (drill-down, popovers, images, field ordering)
</success_criteria>

<output>
After completion, create `.planning/phases/07-pagination/07-02-SUMMARY.md`
</output>
