---
phase: 18-fetch-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/services/api/fetcher.ts
  - src/services/api/__tests__/fetcher.test.ts
autonomous: true

must_haves:
  truths:
    - "fetchWithAuth injects Bearer Token as Authorization: Bearer <token> header"
    - "fetchWithAuth injects Basic Auth as Authorization: Basic <base64> header"
    - "fetchWithAuth injects API Key as configurable custom header"
    - "fetchWithAuth appends Query Parameter to URL via URLSearchParams.set()"
    - "401/403 responses throw AuthError with status, authContext, and response body"
    - "URLs with no credentials configured pass through to existing fetchAPI unchanged"
    - "Invalid header names for API Key auth are rejected with clear error"
  artifacts:
    - path: "src/services/api/fetcher.ts"
      provides: "fetchWithAuth wrapper, buildAuthenticatedRequest, safeParseResponseBody, validateHeaderName, isAuthConfigured, maskCredential"
      exports: ["fetchWithAuth", "isAuthConfigured"]
    - path: "src/services/api/__tests__/fetcher.test.ts"
      provides: "Tests for all 4 auth types, passthrough, auth errors, header validation"
      min_lines: 100
  key_links:
    - from: "src/services/api/fetcher.ts"
      to: "src/store/authStore.ts"
      via: "useAuthStore.getState().getActiveCredential(url)"
      pattern: "useAuthStore\\.getState\\(\\)"
    - from: "src/services/api/fetcher.ts"
      to: "src/services/api/errors.ts"
      via: "throw new AuthError(url, status, authContext, responseBody)"
      pattern: "new AuthError"
---

<objective>
Implement `fetchWithAuth` wrapper with TDD for all 4 authentication credential injection types, 401/403 AuthError detection, passthrough for unauthenticated APIs, and helper utilities.

Purpose: Core fetch layer that makes authenticated API requests possible. This is the engine — Phase 19 adds UI, Phase 21 adds error UX.
Output: Working, tested `fetchWithAuth` function that drops in as a replacement for `fetchAPI`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/services/api/fetcher.ts
@src/services/api/errors.ts
@src/store/authStore.ts
@src/types/auth.ts
@src/types/errors.ts
</context>

<feature>
  <name>fetchWithAuth — Authenticated Fetch Wrapper</name>
  <files>src/services/api/fetcher.ts, src/services/api/__tests__/fetcher.test.ts</files>
  <behavior>
    fetchWithAuth(url: string) -> Promise<unknown>

    **Passthrough (no credentials):**
    - When `useAuthStore.getState().getActiveCredential(url)` returns null
    - Calls existing `fetchAPI(url)` with zero modifications
    - Identical behavior to v1.3

    **Bearer Token injection:**
    - credential.type === 'bearer' → header `Authorization: Bearer ${credential.token}`
    - URL unchanged

    **Basic Auth injection:**
    - credential.type === 'basic' → header `Authorization: Basic ${btoa(credential.username + ':' + credential.password)}`
    - URL unchanged

    **API Key injection:**
    - credential.type === 'apiKey' → header `[credential.headerName]: ${credential.value}`
    - Validate headerName matches /^[a-zA-Z][a-zA-Z0-9-]*$/ — reject with Error("Invalid header name: ...") if not
    - URL unchanged

    **Query Parameter injection:**
    - credential.type === 'queryParam' → `new URL(url).searchParams.set(credential.paramName, credential.value)`
    - Returns modified URL string via parsedUrl.toString()

    **401/403 detection:**
    - response.status === 401 → throw new AuthError(url, 401, authContext, responseBody)
    - response.status === 403 → throw new AuthError(url, 403, authContext, responseBody)
    - authContext: when credentials configured → `"${credential.type} auth"` (e.g., "bearer auth")
    - authContext: when no credentials (passthrough 401/403) → `"no credentials configured"`
    - responseBody: parsed via safeParseResponseBody (JSON stringified if JSON, raw text if not, empty string on failure)

    **Non-auth errors:**
    - Network/CORS errors: same as existing fetchAPI (TypeError → detectCORS → CORSError or NetworkError)
    - HTTP 4xx/5xx (non-401/403): throw APIError (same as existing)
    - Non-JSON response: throw ParseError (same as existing)

    **Helper functions:**
    - `buildAuthenticatedRequest(url, credential)` → `{ url: string, init: RequestInit }` — builds fetch args per credential type
    - `safeParseResponseBody(response)` → `Promise<string>` — safe JSON/text parsing with empty string fallback
    - `validateHeaderName(name)` → `boolean` — validates HTTP header name format
    - `isAuthConfigured(url)` → `boolean` — checks if auth store has active credential for URL origin
    - `maskCredential(credential)` → `string` — masks credential values for logging (bearer: first 4 chars + ***, basic: username:***, apiKey: headerName: ***, queryParam: ?paramName=***)

    Test cases:
    - Bearer: fetchWithAuth injects Authorization Bearer header → verify header present in fetch call
    - Basic: fetchWithAuth injects Authorization Basic header with btoa encoding → verify header value
    - API Key: fetchWithAuth injects custom header → verify custom header name and value
    - API Key invalid header: fetchWithAuth rejects header name "123-bad" → throws Error
    - Query Param: fetchWithAuth appends query param to URL → verify URL modified
    - Query Param replace: fetchWithAuth replaces existing param → verify no duplicate
    - Passthrough: no credential → fetchAPI called unchanged → verify no auth headers
    - 401 with credentials: response 401 → AuthError with "bearer auth" context
    - 403 with credentials: response 403 → AuthError with "apiKey auth" context
    - 401 without credentials: response 401 → AuthError with "no credentials configured" context
    - 401 with JSON body: response 401 + JSON body → AuthError.responseBody contains JSON string
    - 401 with non-JSON body: response 401 + HTML → AuthError.responseBody contains text
    - Network error: fetch throws TypeError → NetworkError (same as before)
    - isAuthConfigured returns true when credential exists
    - isAuthConfigured returns false when no credential
    - maskCredential masks bearer token
    - maskCredential masks basic auth password
    - validateHeaderName accepts valid names (X-API-Key, Authorization, x-custom-123)
    - validateHeaderName rejects invalid names (123bad, has space, empty string)
  </behavior>
  <implementation>
    In `src/services/api/fetcher.ts`:

    1. Add imports: `import { useAuthStore } from '../../store/authStore'` and `import { AuthError } from './errors'` and `import type { Credential } from '../../types/auth'`

    2. Add `fetchWithAuth(url: string): Promise<unknown>` as the main exported function:
       - Call `useAuthStore.getState().getActiveCredential(url)` synchronously
       - If credential is null: delegate entirely to existing `fetchAPI(url)` for passthrough BUT still check 401/403 on response (need to handle the case where public API returns 401)
       - Actually, for the "always detect 401/403" requirement: when no credentials exist, we still need auth error detection. So the passthrough path can't just call fetchAPI (which throws APIError for all non-ok). Instead: when no credential, execute the same fetch but without auth headers, still check for 401/403 before generic error handling.
       - When credential exists: call `buildAuthenticatedRequest(url, credential)` to get modified url + init, then fetch with those

    3. Internally refactor: extract the fetch execution + response handling into a shared path that both credentialed and non-credentialed requests use. The only difference is whether headers/URL are modified. Structure:
       - `fetchWithAuth(url)`: reads auth store, builds request (with or without auth), delegates to `executeFetch(modifiedUrl, init, credential)`
       - `executeFetch(url, init, credential)`: performs fetch, checks 401/403 (throws AuthError), checks other HTTP errors (throws APIError), parses JSON

    4. Add `buildAuthenticatedRequest(url, credential)`: switch on credential.type, return `{ url, init }`. For apiKey: validate header name first, throw Error if invalid.

    5. Add `safeParseResponseBody(response)`: check content-type for JSON, parse accordingly, fallback to text, fallback to empty string.

    6. Add `validateHeaderName(name)`: return `/^[a-zA-Z][a-zA-Z0-9-]*$/.test(name)`.

    7. Add `isAuthConfigured(url)`: export. Reads auth store, returns boolean.

    8. Add `maskCredential(credential)`: export. Switch on type, return masked string.

    9. Keep existing `fetchAPI` function unchanged (it's still used internally for the non-auth code path in other parts of the app, and as a reference).

    **Test setup:** Mock `fetch` globally with vi.fn(). Mock `useAuthStore.getState()` to return controlled credentials. Verify fetch was called with expected headers/URL. For auth errors, mock fetch to return Response with status 401/403.
  </implementation>
</feature>

<verification>
- `npx vitest run src/services/api/__tests__/fetcher.test.ts` — all tests pass
- `npx tsc --noEmit` — no type errors
- Tests cover all 4 auth types, passthrough, 401/403 detection, helper functions
</verification>

<success_criteria>
- All test cases listed in behavior section pass (RED -> GREEN cycle complete)
- fetchWithAuth exported from fetcher.ts
- isAuthConfigured exported from fetcher.ts
- TypeScript compiles without errors
- Existing fetchAPI function unchanged (no regression risk)
</success_criteria>

<output>
After completion, create `.planning/phases/18-fetch-integration/18-01-SUMMARY.md`
</output>
