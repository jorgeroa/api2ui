---
phase: 14.1-smart-object-and-primitive-selection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/services/selection/heuristics.ts
  - src/services/selection/heuristics.test.ts
  - src/services/selection/index.ts
autonomous: true

must_haves:
  truths:
    - "Objects with name + 2+ contact fields (email/phone/address) select hero with confidence >= 0.75"
    - "Objects with 3+ nested object/array fields select tabs with confidence >= 0.75"
    - "Objects with 1 primary content field + 3+ metadata fields select split with confidence >= 0.75"
    - "Primitive string arrays with short values (avg <=20, max <=30, <=10 items) select chips with confidence >= 0.75"
    - "Primitive arrays with tags/status semantic category select chips with confidence >= 0.75"
    - "Objects that don't match any pattern fall back to detail with confidence 0"
    - "Primitive arrays without data fall back to primitive-list with confidence 0"
    - "Non-object schemas return detail fallback from selectObjectComponent"
    - "Non-primitive-array schemas return primitive-list fallback from selectPrimitiveArrayComponent"
  artifacts:
    - path: "src/services/selection/heuristics.ts"
      provides: "checkProfilePattern, checkComplexObjectPattern, checkSplitPattern, checkChipsPattern functions"
    - path: "src/services/selection/heuristics.test.ts"
      provides: "Tests for all object and primitive array heuristics"
    - path: "src/services/selection/index.ts"
      provides: "selectObjectComponent and selectPrimitiveArrayComponent public API"
      exports: ["selectObjectComponent", "selectPrimitiveArrayComponent"]
  key_links:
    - from: "src/services/selection/index.ts"
      to: "src/services/selection/heuristics.ts"
      via: "imports checkProfilePattern, checkComplexObjectPattern, checkSplitPattern, checkChipsPattern"
      pattern: "import.*check(Profile|ComplexObject|Split|Chips)Pattern"
---

<objective>
Add object and primitive array selection heuristics to the selection service using TDD.

Purpose: Objects currently always render as "detail" and primitive arrays as "primitive-list" regardless of semantic content. This plan adds four heuristic functions (profile, complex nested, split, chips) and two public selector functions that apply them in priority order with confidence scoring.

Output: Tested heuristic functions exported from the selection service, ready for integration with useSchemaAnalysis hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/selection/heuristics.ts
@src/services/selection/heuristics.test.ts
@src/services/selection/index.ts
@src/services/selection/types.ts
@src/types/schema.ts
@src/services/analysis/types.ts
@.planning/phases/14.1-smart-object-and-primitive-selection/14.1-RESEARCH.md
</context>

<feature>
  <name>Object and Primitive Array Selection Heuristics</name>
  <files>
    src/services/selection/heuristics.ts
    src/services/selection/heuristics.test.ts
    src/services/selection/index.ts
  </files>
  <behavior>
    Four new heuristic functions plus two public selector functions:

    **checkProfilePattern(schema, context) -> ComponentSelection | null**
    - schema.kind === 'object' with fields containing name + 2+ contact semantics (email, phone, address, url) → { componentType: 'hero', confidence: 0.85, reason: 'profile-pattern-detected' }
    - schema.kind === 'object' with name + 1 contact → null (below threshold, don't return weak match)
    - schema.kind !== 'object' → null
    - No name field → null

    **checkComplexObjectPattern(schema, context) -> ComponentSelection | null**
    - schema.kind === 'object' with 3+ fields whose type.kind is 'array' or 'object' → { componentType: 'tabs', confidence: 0.8, reason: 'complex-nested-structure' }
    - schema.kind === 'object' with <3 nested fields → null
    - schema.kind !== 'object' → null

    **checkSplitPattern(schema, context) -> ComponentSelection | null**
    - schema.kind === 'object' with exactly 1 primary-tier content field (semantic category 'description' OR name matches /^(description|content|body|summary|text)$/i) AND 3+ metadata fields (tertiary tier OR name matches /^(id|created|updated|timestamp|_)/) AND total fields >= 5 → { componentType: 'split', confidence: 0.75, reason: 'content-metadata-split-detected' }
    - Otherwise → null

    **checkChipsPattern(data, schema, context) -> ComponentSelection | null**
    - schema.items.kind === 'primitive' AND schema.items.type === 'string' required (non-string → null)
    - Semantic category 'tags' or 'status' on parent path → { componentType: 'chips', confidence: 0.9, reason: 'semantic-tags-or-status' }
    - String values with avg length <=20, max <=30, array length <=10 → { componentType: 'chips', confidence: 0.8, reason: 'short-enum-like-values' }
    - Empty data → null

    **selectObjectComponent(schema, context) -> ComponentSelection**
    - Tries heuristics in order: profile → complex → split
    - Returns first match with confidence >= 0.75
    - Falls back to { componentType: 'detail', confidence: 0, reason: 'fallback-to-default' }
    - Non-object schema returns fallback immediately

    **selectPrimitiveArrayComponent(schema, data, context) -> ComponentSelection**
    - Only applies when schema.kind === 'array' AND schema.items.kind === 'primitive'
    - Tries chips heuristic
    - Returns match if confidence >= 0.75
    - Falls back to { componentType: 'primitive-list', confidence: 0, reason: 'fallback-to-default' }
    - No data or empty array returns fallback with reason 'no-data'

    **Test structure (add to existing heuristics.test.ts):**

    New describe blocks at end of file:
    - "Object Heuristics" containing:
      - "checkProfilePattern" (5-6 tests: profile match, weak profile no match, no name, non-object, name + 3 contacts)
      - "checkComplexObjectPattern" (4 tests: 3+ nested, 2 nested no match, non-object, mixed nested types)
      - "checkSplitPattern" (5 tests: content+metadata match, no content field, <3 metadata, <5 total fields, non-object)
      - "selectObjectComponent" (4 tests: profile wins over tabs, tabs match, split match, fallback)
    - "Primitive Array Heuristics" containing:
      - "checkChipsPattern" (5 tests: semantic tags, short values, long values no match, non-string, empty data)
      - "selectPrimitiveArrayComponent" (4 tests: chips match, no match fallback, no data, non-primitive-array)

    **Mock helpers needed:**

    createMockObjectSchema(fields: Array<{ name: string; type: TypeSignature }>): TypeSignature
    - Creates { kind: 'object', fields: Map with FieldDefinition entries }

    createMockPrimitiveArraySchema(primitiveType: string): TypeSignature
    - Creates { kind: 'array', items: { kind: 'primitive', type: primitiveType } }

    Reuse existing createMockContext from the test file.

    **Path format for object field semantics:** Use `$.fieldName` (NOT `$[].fieldName` which is for array items).

    **Path format for primitive array parent semantics:** Use the parent field name path (e.g., `$.tags`). When checking chips, iterate context.semantics looking for entries with 'tags' or 'status' category since the exact path varies.
  </behavior>
  <implementation>
    1. Add four heuristic functions to heuristics.ts:
       - checkProfilePattern: iterate schema.fields, check semantic categories for name + contact fields using `$.fieldName` paths. Contact categories: ['email', 'phone', 'address', 'url']. Also check field name regex /^(name|title|full_?name)$/i as fallback for name detection.
       - checkComplexObjectPattern: count fields whose fieldDef.type.kind is 'array' or 'object'. Threshold: 3+.
       - checkSplitPattern: check importance tiers and semantic categories. Primary content = tier 'primary' AND (semantic 'description' OR name regex). Metadata = tier 'tertiary' OR name regex /^(id|created|updated|timestamp|_)/. Need exactly 1 primary content + 3+ metadata + 5+ total fields.
       - checkChipsPattern: accepts data as first param (unlike object heuristics). Check string type, then semantic category, then value length heuristics.

    2. Add helper function getObjectFields(schema: TypeSignature) that returns Array<[string, FieldDefinition]> | null (returns null if not an object). Similar to existing getArrayItemFields but for objects. Uses schema.fields.entries() directly.

    3. Add two public selector functions to index.ts:
       - selectObjectComponent(schema, context) → loops through [checkProfilePattern, checkComplexObjectPattern, checkSplitPattern], returns first >= 0.75 or fallback
       - selectPrimitiveArrayComponent(schema, data, context) → checks chips, returns if >= 0.75 or fallback

    4. Export both new functions from index.ts alongside existing selectComponent.

    IMPORTANT: Do NOT modify the existing selectComponent function or any existing heuristics. This is additive only.
    IMPORTANT: checkChipsPattern signature differs from object heuristics — it takes (data, schema, context) not (schema, context) because primitive arrays need actual data for length/value analysis.
    IMPORTANT: Use FieldDefinition type from schema.ts when accessing schema.fields entries (Map<string, FieldDefinition>). Access the nested type via fieldDef.type.
  </implementation>
</feature>

<verification>
```bash
# Run all selection tests (existing + new)
npx vitest run src/services/selection/heuristics.test.ts

# Verify exports
npx tsx -e "import { selectObjectComponent, selectPrimitiveArrayComponent } from './src/services/selection'; console.log('Exports OK:', typeof selectObjectComponent, typeof selectPrimitiveArrayComponent)"

# Verify existing tests still pass
npx vitest run src/services/selection/
```
</verification>

<success_criteria>
1. All new heuristic tests pass (RED → GREEN cycle completed)
2. All existing 34 heuristic tests still pass (no regressions)
3. selectObjectComponent and selectPrimitiveArrayComponent exported from selection service
4. Profile pattern returns hero with 0.85 confidence for name + 2+ contact fields
5. Complex pattern returns tabs with 0.8 confidence for 3+ nested structures
6. Split pattern returns split with 0.75 confidence for content + metadata objects
7. Chips pattern returns chips with 0.8-0.9 confidence for short enum-like string arrays
8. All fallback cases return appropriate default with confidence 0
</success_criteria>

<output>
After completion, create `.planning/phases/14.1-smart-object-and-primitive-selection/14.1-01-SUMMARY.md`
</output>
