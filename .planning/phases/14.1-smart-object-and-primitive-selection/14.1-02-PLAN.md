---
phase: 14.1-smart-object-and-primitive-selection
plan: 02
type: execute
wave: 2
depends_on: ["14.1-01"]
files_modified:
  - src/hooks/useSchemaAnalysis.ts
autonomous: true

must_haves:
  truths:
    - "Objects at any schema path get analyzed and cached with ComponentSelection result"
    - "Primitive arrays at any schema path get analyzed and cached with ComponentSelection result"
    - "DynamicRenderer picks up cached object selections (hero, tabs, split) via existing three-tier precedence"
    - "DynamicRenderer picks up cached primitive array selections (chips) via existing three-tier precedence"
    - "Existing array-of-objects analysis still works (no regression)"
    - "User overrides via component switcher still take precedence over smart defaults"
    - "Fallback to detail (objects) or primitive-list (arrays) when confidence < 0.75"
  artifacts:
    - path: "src/hooks/useSchemaAnalysis.ts"
      provides: "Extended analysis pipeline covering objects and primitive arrays"
  key_links:
    - from: "src/hooks/useSchemaAnalysis.ts"
      to: "src/services/selection/index.ts"
      via: "imports selectObjectComponent, selectPrimitiveArrayComponent"
      pattern: "import.*select(Object|PrimitiveArray)Component"
    - from: "src/hooks/useSchemaAnalysis.ts"
      to: "src/store/appStore.ts"
      via: "setAnalysisCache populates cache for object/primitive-array paths"
      pattern: "setAnalysisCache\\(path"
---

<objective>
Extend useSchemaAnalysis hook to analyze objects and primitive arrays, populating the analysis cache so DynamicRenderer applies smart defaults.

Purpose: Plan 01 created the heuristic functions but they are not called yet. This plan wires them into the analysis pipeline so objects and primitive arrays actually get smart component selection at runtime.

Output: useSchemaAnalysis hook that analyzes all schema kinds (arrays of objects, objects, primitive arrays), populating the cache that DynamicRenderer already reads.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/useSchemaAnalysis.ts
@src/services/selection/index.ts
@src/components/DynamicRenderer.tsx
@src/store/appStore.ts
@src/types/schema.ts
@.planning/phases/14.1-smart-object-and-primitive-selection/14.1-01-SUMMARY.md
@.planning/phases/14.1-smart-object-and-primitive-selection/14.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useSchemaAnalysis to analyze objects and primitive arrays</name>
  <files>src/hooks/useSchemaAnalysis.ts</files>
  <action>
    Update `useSchemaAnalysis.ts` to handle three schema kinds instead of just arrays of objects.

    **Step 1: Add imports**
    Import `selectObjectComponent` and `selectPrimitiveArrayComponent` from `../services/selection`.

    **Step 2: Rename findArrayPaths → findAnalyzablePaths**
    Extend the existing `findArrayPaths` function to also discover:
    - Object paths (schema.kind === 'object'): add to results
    - Primitive array paths (schema.kind === 'array' && schema.items.kind === 'primitive'): add to results

    The function should return `{ path, schema, data, schemaKind }` where schemaKind is 'array-of-objects' | 'object' | 'primitive-array'. This discriminator tells the analysis loop which selector to call.

    Keep existing array-of-objects discovery logic unchanged. Add object and primitive-array discovery alongside it.

    **Important path handling:**
    - Objects use `$.fieldName` paths for their field semantics (not `$[].fieldName`)
    - Primitive arrays use their parent path for cache key (e.g., `$.tags`)
    - The root path `$` can be an object or array — handle both

    **Step 3: Add buildObjectFieldInfos function**
    Create a new function `buildObjectFieldInfos(schema, data, basePath)` similar to existing `buildFieldInfos` but for object schemas:
    - Iterates over schema.fields (Map<string, FieldDefinition>)
    - Field path format: `${basePath}.${fieldName}` (NOT `${basePath}[].${fieldName}`)
    - Extracts sample values from data object (data[fieldName]) — data is a plain object, not an array
    - Returns { fieldInfos, semanticsMap } same as buildFieldInfos

    extractSampleValues won't work for objects (it expects array data). Create a simpler inline extraction:
    ```typescript
    const sampleValues = data && typeof data === 'object' && !Array.isArray(data) && fieldName in (data as Record<string, unknown>)
      ? [(data as Record<string, unknown>)[fieldName]]
      : []
    ```

    **Step 4: Update the analysis loop in useEffect**
    After the existing array-of-objects analysis loop, add two new blocks:

    For objects:
    ```
    if (schemaKind === 'object') {
      const { fieldInfos, semanticsMap } = buildObjectFieldInfos(schema, data, path)
      if (fieldInfos.length === 0) continue
      const analysisResult = analyzeFields(fieldInfos)
      const selectionContext = { semantics: semanticsMap, importance: analysisResult.importance }
      const selection = selectObjectComponent(schema, selectionContext)
      setAnalysisCache(path, { semantics: semanticsMap, importance: analysisResult.importance, selection })
    }
    ```

    For primitive arrays:
    ```
    if (schemaKind === 'primitive-array') {
      // Primitive arrays have minimal field analysis but need data for chips heuristic
      // Build a minimal semantics map from parent path semantic detection
      const semanticsMap = new Map()
      const importanceMap = new Map()

      // Detect semantics on the array itself (e.g., "tags", "status")
      // Use the field name from the path (last segment)
      const fieldName = path.split('.').pop() || path
      const semanticResults = detectSemantics(path, fieldName, 'array', Array.isArray(data) ? data.slice(0, 10) : [])
      const bestMatch = getBestMatch(semanticResults)
      if (bestMatch) {
        semanticsMap.set(path, {
          detectedCategory: bestMatch.category,
          confidence: bestMatch.confidence,
          level: bestMatch.level,
          appliedAt: 'smart-default',
          alternatives: []
        })
      }

      const selectionContext = { semantics: semanticsMap, importance: importanceMap }
      const selection = selectPrimitiveArrayComponent(schema, data, selectionContext)
      setAnalysisCache(path, { semantics: semanticsMap, importance: importanceMap, selection })
    }
    ```

    **Step 5: Keep existing array-of-objects block as-is**
    The existing code for `schemaKind === 'array-of-objects'` should remain unchanged. Only add the two new blocks.

    IMPORTANT: Do NOT change the DynamicRenderer. It already reads from the analysis cache with the three-tier precedence (override → smart → fallback). Once the cache is populated for objects and primitive arrays, DynamicRenderer will automatically use the smart defaults.
  </action>
  <verify>
    ```bash
    # TypeScript compiles
    npx tsc --noEmit

    # Existing tests still pass
    npx vitest run src/services/selection/

    # Manual verification: check that the hook exports and function signatures are correct
    npx tsx -e "import { useSchemaAnalysis } from './src/hooks/useSchemaAnalysis'; console.log('Hook exported:', typeof useSchemaAnalysis)"
    ```
  </verify>
  <done>
    useSchemaAnalysis hook discovers and analyzes objects and primitive arrays in addition to arrays of objects. Cache is populated for all schema kinds. Existing array-of-objects analysis unchanged. TypeScript compiles. All selection tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end smart selection for objects and primitive arrays</name>
  <files>src/hooks/useSchemaAnalysis.ts</files>
  <action>
    Run the full test suite to verify no regressions. Then do a build verification:

    ```bash
    npx vitest run
    npm run build
    ```

    If any tests fail, fix them. The build must succeed.

    Additionally, verify the integration works by tracing the data flow:
    1. useSchemaAnalysis finds object/primitive-array paths via findAnalyzablePaths
    2. For objects: buildObjectFieldInfos → analyzeFields → selectObjectComponent → setAnalysisCache
    3. For primitive arrays: detectSemantics on array → selectPrimitiveArrayComponent → setAnalysisCache
    4. DynamicRenderer reads cache via getAnalysisCache → applies smart default if confidence >= 0.75

    If build or tests fail, diagnose and fix the issues in useSchemaAnalysis.ts.
  </action>
  <verify>
    ```bash
    npx vitest run
    npm run build
    ```
  </verify>
  <done>
    All tests pass. Build succeeds. useSchemaAnalysis populates analysis cache for objects and primitive arrays. DynamicRenderer reads cached selections and applies smart defaults via existing three-tier precedence.
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
npx vitest run

# Build succeeds
npm run build

# Selection service exports all selectors
npx tsx -e "
import { selectComponent, selectObjectComponent, selectPrimitiveArrayComponent } from './src/services/selection';
console.log('selectComponent:', typeof selectComponent);
console.log('selectObjectComponent:', typeof selectObjectComponent);
console.log('selectPrimitiveArrayComponent:', typeof selectPrimitiveArrayComponent);
"

# Hook exports
npx tsx -e "import { useSchemaAnalysis } from './src/hooks/useSchemaAnalysis'; console.log('useSchemaAnalysis:', typeof useSchemaAnalysis)"
```
</verification>

<success_criteria>
1. useSchemaAnalysis discovers objects and primitive arrays in any schema tree
2. Object paths get semantic detection, importance scoring, and component selection cached
3. Primitive array paths get semantic detection and component selection cached
4. Existing array-of-objects analysis unchanged (no regression)
5. All tests pass, build succeeds
6. DynamicRenderer automatically uses cached smart defaults (no DynamicRenderer changes needed)
</success_criteria>

<output>
After completion, create `.planning/phases/14.1-smart-object-and-primitive-selection/14.1-02-SUMMARY.md`
</output>
