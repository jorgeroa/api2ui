# Phase 14.1: Smart Object & Primitive Selection - Research

**Researched:** 2026-02-08
**Domain:** Semantic-driven component selection for objects and primitive arrays
**Confidence:** HIGH

## Summary

Phase 14.1 extends Phase 14's smart component selection to cover objects and primitive arrays. Phase 14 only implemented smart selection for arrays of objects, leaving objects always defaulting to "detail" and primitive arrays always to "primitive-list" regardless of semantic content. This gap was discovered during Phase 14 UAT when user profiles with name/email/phone rendered as flat detail views instead of hero/profile layout.

The research identifies three object selection patterns (profile-like → hero, complex nested → tabs, content+metadata split → split view) and two primitive array patterns (short enum-like values → chips, long/mixed values → primitive-list). These patterns reuse existing detection infrastructure from Phase 12 (semantic categories) and Phase 13 (importance scoring).

The implementation follows the same architecture as Phase 14: zero-dependency heuristic pattern matching with confidence scoring (>=0.75 triggers smart defaults), falling back to type-based defaults when uncertain. The three-tier precedence (user override > smart default > fallback) remains unchanged.

**Primary recommendation:** Extend the existing selection service (src/services/selection/) with two new heuristic functions: selectObjectComponent() for objects and selectPrimitiveArrayComponent() for primitive arrays. Integrate with DynamicRenderer using the same cache lookup pattern established in Phase 14.

## Standard Stack

No new libraries required. This phase extends existing Phase 14 infrastructure.

### Core (Already in Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React 18 | 18.x | UI framework | Project foundation |
| TypeScript | 5.x | Type safety | Project-wide typing |
| Tailwind CSS | 3.x | Responsive layouts | Current styling approach |

### Supporting (Already Implemented)
| Component | Location | Purpose | Current Status |
|-----------|----------|---------|----------------|
| DetailRenderer | src/components/renderers/DetailRenderer.tsx | Default object view | ✓ Exists |
| HeroRenderer | src/components/renderers/HeroRenderer.tsx | Profile/hero layout | ✓ Exists (v1.1) |
| TabsRenderer | src/components/renderers/TabsRenderer.tsx | Tabbed sections | ✓ Exists (v1.1) |
| SplitRenderer | src/components/renderers/SplitRenderer.tsx | Content + metadata | ✓ Exists (v1.1) |
| PrimitiveListRenderer | src/components/renderers/PrimitiveListRenderer.tsx | Default primitive array | ✓ Exists |
| ChipsRenderer | src/components/renderers/ChipsRenderer.tsx | Colored tag chips | ✓ Exists (v1.1) |

### Analysis Infrastructure (From Phase 12-14)
| Module | Purpose | Status |
|--------|---------|--------|
| src/services/semantic | Field semantic detection | ✓ Complete (22 patterns) |
| src/services/analysis | Importance scoring + grouping | ✓ Complete |
| src/services/selection | Smart component selection | ✓ Exists (arrays of objects only) |
| src/hooks/useSchemaAnalysis | Analysis pipeline hook | ✓ Exists (Phase 14.3) |
| src/store/appStore | Analysis cache storage | ✓ Exists |

### No External Dependencies
This phase requires no new npm packages. All required components and infrastructure exist.

## Architecture Patterns

### Recommended Project Structure
```
src/
├── services/
│   └── selection/
│       ├── index.ts          # UPDATE: Export new selectors
│       ├── heuristics.ts     # UPDATE: Add object + primitive array heuristics
│       └── types.ts          # Same (no changes)
├── hooks/
│   └── useSchemaAnalysis.ts  # UPDATE: Run selection for objects + primitive arrays
├── components/
│   └── DynamicRenderer.tsx   # UPDATE: Apply smart selection to all schema kinds
```

### Pattern 1: Object Component Selection Heuristics
**What:** Evaluate object structure and semantic signals to choose between detail, hero, tabs, and split renderers.
**When to use:** When rendering a single object (not an array item).
**Example:**
```typescript
// Source: Phase 14 patterns extended to objects
interface SelectionResult {
  componentType: string
  confidence: number
  reason: string
}

function selectObjectComponent(
  schema: TypeSignature,
  context: SelectionContext
): SelectionResult {
  if (schema.kind !== 'object') {
    return { componentType: 'detail', confidence: 0, reason: 'not-applicable' }
  }

  // Priority 1: Profile-like pattern (name + contact info)
  const profileCheck = checkProfilePattern(schema, context)
  if (profileCheck && profileCheck.confidence >= 0.75) {
    return profileCheck
  }

  // Priority 2: Complex nested structure (many nested objects/arrays)
  const complexCheck = checkComplexObjectPattern(schema, context)
  if (complexCheck && complexCheck.confidence >= 0.75) {
    return complexCheck
  }

  // Priority 3: Split pattern (clear primary content + metadata)
  const splitCheck = checkSplitPattern(schema, context)
  if (splitCheck && splitCheck.confidence >= 0.75) {
    return splitCheck
  }

  // Fallback to detail (current v1.2 behavior)
  return { componentType: 'detail', confidence: 0, reason: 'fallback-to-default' }
}
```

### Pattern 2: Profile Pattern Detection
**What:** Detect objects with profile-like semantics (name + email/phone/address).
**When to use:** For objects representing user profiles, contacts, or identity records.
**Example:**
```typescript
// Source: Phase 12 semantic categories + UX research
function checkProfilePattern(
  schema: TypeSignature,
  context: SelectionContext
): SelectionResult | null {
  if (schema.kind !== 'object') return null

  const fields = Array.from(schema.fields.entries())

  // Profile signals: name + contact info
  let hasName = false
  let contactFieldCount = 0

  for (const [fieldName] of fields) {
    const fieldPath = `$.${fieldName}`
    const semantic = context.semantics.get(fieldPath)

    // Check for name field
    if (semantic?.detectedCategory === 'name' || /^(name|title|full_?name)$/i.test(fieldName)) {
      hasName = true
    }

    // Check for contact fields
    const contactCategories = ['email', 'phone', 'address', 'url']
    if (contactCategories.includes(semantic?.detectedCategory ?? '')) {
      contactFieldCount++
    }
  }

  // Profile pattern: name + 2+ contact fields
  // Confidence: 0.85 when both signals present
  if (hasName && contactFieldCount >= 2) {
    return {
      componentType: 'hero',
      confidence: 0.85,
      reason: 'profile-pattern-detected',
    }
  }

  // Weak profile: name + 1 contact field
  // Confidence: 0.65 (below threshold, won't trigger)
  if (hasName && contactFieldCount === 1) {
    return {
      componentType: 'hero',
      confidence: 0.65,
      reason: 'weak-profile-pattern',
    }
  }

  return null
}
```

### Pattern 3: Complex Object Detection (Many Nested Fields)
**What:** Detect objects with many nested objects/arrays that benefit from tabbed organization.
**When to use:** For complex structured data with multiple nested sections.
**Example:**
```typescript
// Source: UX research (complexity threshold studies)
function checkComplexObjectPattern(
  schema: TypeSignature,
  context: SelectionContext
): SelectionResult | null {
  if (schema.kind !== 'object') return null

  const fields = Array.from(schema.fields.entries())

  // Count nested structures (arrays + objects)
  const nestedFields = fields.filter(([, def]) =>
    def.type.kind === 'array' || def.type.kind === 'object'
  )

  // Threshold: 3+ nested structures
  // Rationale: Tabs make sense when multiple complex sections exist
  if (nestedFields.length >= 3) {
    return {
      componentType: 'tabs',
      confidence: 0.8,
      reason: 'complex-nested-structure',
    }
  }

  return null
}
```

### Pattern 4: Split View Pattern Detection
**What:** Detect objects with clear primary content field + metadata fields.
**When to use:** For objects with one dominant field (description, content) plus supporting metadata.
**Example:**
```typescript
// Source: Importance tier analysis from Phase 13
function checkSplitPattern(
  schema: TypeSignature,
  context: SelectionContext
): SelectionResult | null {
  if (schema.kind !== 'object') return null

  const fields = Array.from(schema.fields.entries())

  // Look for a single dominant primary field (description/content/body)
  let primaryContentField: string | null = null
  let primaryCount = 0
  let metadataCount = 0

  for (const [fieldName] of fields) {
    const fieldPath = `$.${fieldName}`
    const importance = context.importance.get(fieldPath)
    const semantic = context.semantics.get(fieldPath)

    // Check for primary content field
    if (importance?.tier === 'primary' &&
        (semantic?.detectedCategory === 'description' ||
         /^(description|content|body|summary|text)$/i.test(fieldName))) {
      primaryContentField = fieldName
      primaryCount++
    }

    // Check for metadata fields (timestamps, IDs)
    if (importance?.tier === 'tertiary' ||
        /^(id|created|updated|timestamp|_)/.test(fieldName)) {
      metadataCount++
    }
  }

  // Split pattern: 1 primary content field + 3+ metadata fields
  // Confidence: 0.75 (threshold)
  if (primaryCount === 1 && metadataCount >= 3 && fields.length >= 5) {
    return {
      componentType: 'split',
      confidence: 0.75,
      reason: 'content-metadata-split-detected',
    }
  }

  return null
}
```

### Pattern 5: Primitive Array Component Selection
**What:** Choose between primitive-list and chips based on array characteristics.
**When to use:** When rendering arrays of primitives (strings, numbers, booleans).
**Example:**
```typescript
// Source: Phase 14 patterns adapted for primitive arrays
function selectPrimitiveArrayComponent(
  schema: TypeSignature,
  data: unknown,
  context: SelectionContext
): SelectionResult {
  if (schema.kind !== 'array' || schema.items.kind !== 'primitive') {
    return { componentType: 'primitive-list', confidence: 0, reason: 'not-applicable' }
  }

  // Safety: Require actual array data
  if (!Array.isArray(data) || data.length === 0) {
    return { componentType: 'primitive-list', confidence: 0, reason: 'no-data' }
  }

  // Check for chips pattern: short enum-like values
  const chipsCheck = checkChipsPattern(data, schema, context)
  if (chipsCheck && chipsCheck.confidence >= 0.75) {
    return chipsCheck
  }

  // Fallback to primitive-list (current v1.2 behavior)
  return { componentType: 'primitive-list', confidence: 0, reason: 'fallback-to-default' }
}
```

### Pattern 6: Chips Pattern Detection
**What:** Detect short enum-like values that display better as colored chips than a list.
**When to use:** For tags, categories, statuses, or other short label arrays.
**Example:**
```typescript
// Source: UX research on tag/chip displays + Phase 12 semantic detection
function checkChipsPattern(
  data: unknown[],
  schema: TypeSignature,
  context: SelectionContext
): SelectionResult | null {
  // Only strings make sense as chips
  if (schema.items.kind !== 'primitive' || schema.items.type !== 'string') {
    return null
  }

  // Safety: At least one value to analyze
  if (data.length === 0) return null

  // Heuristic 1: Check semantic category (tags, status)
  // Note: Primitive arrays don't have per-item paths, check parent path
  const parentPath = '$' // Could be nested, but start with root
  const semantic = context.semantics.get(parentPath)

  if (semantic?.detectedCategory === 'tags' || semantic?.detectedCategory === 'status') {
    return {
      componentType: 'chips',
      confidence: 0.9,
      reason: 'semantic-tags-or-status',
    }
  }

  // Heuristic 2: Short string values (<=30 chars) + small array (<=10 items)
  const sampleValues = data.slice(0, 10).filter(v => typeof v === 'string')
  const avgLength = sampleValues.reduce((sum, v) => sum + v.length, 0) / sampleValues.length
  const maxLength = Math.max(...sampleValues.map(v => v.length))

  // Chips criteria: avg <=20 chars, max <=30 chars, <=10 items
  if (avgLength <= 20 && maxLength <= 30 && data.length <= 10) {
    return {
      componentType: 'chips',
      confidence: 0.8,
      reason: 'short-enum-like-values',
    }
  }

  // Heuristic 3: Small distinct set (<=5 unique values, repeated)
  const uniqueValues = new Set(data)
  if (uniqueValues.size <= 5 && data.length >= uniqueValues.size * 2) {
    return {
      componentType: 'chips',
      confidence: 0.75,
      reason: 'small-repeated-enum',
    }
  }

  return null
}
```

### Pattern 7: Integration with DynamicRenderer
**What:** Extend DynamicRenderer's smart selection logic to cover all schema kinds.
**When to use:** Universal pattern for all component rendering decisions.
**Example:**
```typescript
// Source: Phase 14 DynamicRenderer.tsx extended
// In DynamicRenderer component:

let currentType: string
if (override) {
  // User override always wins (INT-01, INT-05)
  currentType = override
} else {
  // Try smart selection from cache
  const cached = getAnalysisCache(activePath)
  if (cached?.selection && cached.selection.confidence >= 0.75) {
    // High-confidence smart default
    currentType = cached.selection.componentType
  } else {
    // Fall back to type-based default (v1.2 behavior preserved)
    currentType = getDefaultTypeName(activeSchema)
  }
}

// Note: This pattern is ALREADY implemented in Phase 14
// Phase 14.1 just needs to ensure objects and primitive arrays
// are also analyzed and cached by useSchemaAnalysis hook
```

### Anti-Patterns to Avoid

- **Don't analyze every render:** Analysis should run once when schema changes (via useSchemaAnalysis hook), not on every component render. Results are cached in appStore.
- **Don't ignore confidence threshold:** Only apply smart defaults when confidence >= 0.75. Lower confidence should fall back to type-based defaults to avoid false positives.
- **Don't bypass user overrides:** The three-tier precedence (user override > smart default > fallback) is critical. User selections from the component switcher must always win.
- **Don't analyze without data:** Primitive array heuristics need actual data (for length checks, value sampling). Objects can be analyzed from schema alone, but primitives cannot.

## Don't Hand-Roll

Problems that already have solutions in the existing codebase:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Semantic field detection | Custom pattern matching | Phase 12 semantic patterns (22 patterns, multi-signal detection) | Already detects name, email, phone, address, tags, status, etc. |
| Importance scoring | Field weight calculation | Phase 13 importance algorithm (4-signal scoring) | Already classifies fields as primary/secondary/tertiary |
| Component registry | Type-to-component mapping | ComponentRegistry.getComponent() | Already maps type names to components with override support |
| Analysis caching | Custom memoization | appStore.analysisCache + useSchemaAnalysis hook | Already caches results per path with schema identity tracking |
| Confidence scoring | Ad-hoc thresholds | Existing 0.75 threshold from Phase 12-14 | Consistent confidence model across all smart defaults |

**Key insight:** Phase 14.1 is an extension, not a rewrite. The entire analysis pipeline (semantic detection, importance scoring, component selection, caching) already exists for arrays of objects. This phase simply extends the heuristics to cover two more schema kinds: objects and primitive arrays.

## Common Pitfalls

### Pitfall 1: Path Mismatch in Object Analysis
**What goes wrong:** Objects use `$.fieldName` paths while arrays use `$[].fieldName` paths. Heuristics that don't account for this will fail to find semantic metadata.
**Why it happens:** Copy-pasting array heuristics without updating path construction.
**How to avoid:** Use path construction helpers or string matching patterns that work for both.
```typescript
// WRONG: Assumes array path
const fieldPath = `$[].${fieldName}`

// RIGHT: Construct based on schema context
const fieldPath = basePath === '$' ? `$.${fieldName}` : `${basePath}.${fieldName}`
```
**Warning signs:** Profile pattern never triggers despite correct semantic detection in cache.

### Pitfall 2: Analyzing Primitive Arrays Without Data
**What goes wrong:** Heuristics try to check array length or value characteristics but data is undefined/null.
**Why it happens:** Schema analysis runs before data is available, or during schema-only operations.
**How to avoid:** Primitive array selection must be data-aware. Return low confidence when data is missing.
```typescript
// WRONG: Assumes data exists
const avgLength = data.reduce((sum, v) => sum + v.length, 0) / data.length

// RIGHT: Guard against missing data
if (!Array.isArray(data) || data.length === 0) {
  return { componentType: 'primitive-list', confidence: 0, reason: 'no-data' }
}
```
**Warning signs:** Runtime errors when rendering primitive arrays, or chips showing for empty arrays.

### Pitfall 3: Over-Triggering Smart Defaults
**What goes wrong:** Heuristics with confidence scores just below 0.75 cause inconsistent behavior as small changes flip the selection.
**Why it happens:** Using arbitrary thresholds or summing weak signals to reach 0.75.
**How to avoid:** Each heuristic should have clear high-confidence criteria (>=0.8) or fall back gracefully. Confidence of 0.65-0.74 is a code smell.
```typescript
// WRONG: Weak pattern that barely triggers
if (hasName && contactFieldCount === 1) {
  return { componentType: 'hero', confidence: 0.74, reason: 'weak-profile' }
}

// RIGHT: Clear high-confidence pattern or don't trigger
if (hasName && contactFieldCount >= 2) {
  return { componentType: 'hero', confidence: 0.85, reason: 'profile-pattern-detected' }
}
return null // Fall back to detail
```
**Warning signs:** Component selection changes with minor data variations, user confusion about why layouts differ.

### Pitfall 4: Ignoring Existing Component Capabilities
**What goes wrong:** Trying to detect patterns for components that don't support them (e.g., "tabs for primitive arrays").
**Why it happens:** Not understanding what each renderer component actually displays.
**How to avoid:** Review existing renderer implementations before writing heuristics. Only select components that make semantic sense for the schema kind.
```typescript
// WRONG: TabsRenderer requires object schema with nested fields
if (schema.kind === 'array') {
  return { componentType: 'tabs', confidence: 0.8, reason: 'complex-data' }
}

// RIGHT: Match heuristic to component capabilities
if (schema.kind === 'object' && nestedFieldCount >= 3) {
  return { componentType: 'tabs', confidence: 0.8, reason: 'complex-nested-structure' }
}
```
**Warning signs:** Runtime errors from renderers, "expects object schema" errors in console.

### Pitfall 5: Not Updating useSchemaAnalysis Hook
**What goes wrong:** New heuristics are written but useSchemaAnalysis hook still only analyzes arrays of objects. Objects and primitive arrays never get smart selection.
**Why it happens:** Forgetting to update the analysis pipeline to call new selector functions.
**How to avoid:** Update useSchemaAnalysis to call selectObjectComponent() for objects and selectPrimitiveArrayComponent() for primitive arrays, storing results in cache.
```typescript
// In useSchemaAnalysis hook:
// BEFORE (Phase 14):
if (schema.kind === 'array' && schema.items.kind === 'object') {
  const selection = selectComponent(schema, context)
  // ... store in cache
}

// AFTER (Phase 14.1):
if (schema.kind === 'array' && schema.items.kind === 'object') {
  const selection = selectComponent(schema, context)
  // ... store in cache
} else if (schema.kind === 'object') {
  const selection = selectObjectComponent(schema, context)
  // ... store in cache
} else if (schema.kind === 'array' && schema.items.kind === 'primitive') {
  const selection = selectPrimitiveArrayComponent(schema, data, context)
  // ... store in cache
}
```
**Warning signs:** Heuristics pass tests but nothing changes in the UI, cache never populated for objects/primitive arrays.

## Code Examples

Verified patterns from existing codebase:

### Existing Pattern: Array of Objects Selection (Phase 14)
```typescript
// Source: src/services/selection/index.ts
export function selectComponent(
  schema: TypeSignature,
  context: SelectionContext
): ComponentSelection {
  // Only apply smart selection for arrays of objects
  if (schema.kind !== 'array' || schema.items.kind !== 'object') {
    return {
      componentType: getDefaultTypeName(schema),
      confidence: 0,
      reason: 'not-applicable',
    }
  }

  // Try heuristics in priority order
  const heuristics = [
    checkReviewPattern,
    checkImageGalleryPattern,
    checkTimelinePattern,
    selectCardOrTable,
  ]

  for (const heuristic of heuristics) {
    const result = heuristic(schema, context)
    if (result && result.confidence >= 0.75) {
      return result
    }
  }

  // Fallback to type-based default
  return {
    componentType: 'table',
    confidence: 0,
    reason: 'fallback-to-default',
  }
}
```

### Existing Pattern: Available Component Types (DynamicRenderer)
```typescript
// Source: src/components/DynamicRenderer.tsx (lines 26-36)
function getAvailableTypes(schema: TypeSignature): string[] {
  if (schema.kind === 'array' && schema.items.kind === 'object') {
    return ['table', 'card-list', 'list', 'gallery', 'timeline', 'stats', 'json']
  }
  if (schema.kind === 'array' && schema.items.kind === 'primitive') {
    return ['primitive-list', 'chips', 'inline', 'grid', 'json']
  }
  if (schema.kind === 'object') {
    return ['detail', 'hero', 'tabs', 'split', 'json']
  }
  return [getDefaultTypeName(schema)]
}
```

### Existing Pattern: Cache Lookup (DynamicRenderer)
```typescript
// Source: src/components/DynamicRenderer.tsx (lines 117-132)
// Determine current component type with precedence: User override > Smart default > Type-based default
let currentType: string
if (override) {
  // User override always wins (INT-01, INT-05)
  currentType = override
} else {
  // Try smart selection from cache
  const cached = getAnalysisCache(activePath)
  if (cached?.selection && cached.selection.confidence >= 0.75) {
    // High-confidence smart default
    currentType = cached.selection.componentType
  } else {
    // Fall back to type-based default (v1.2 behavior preserved)
    currentType = getDefaultTypeName(activeSchema)
  }
}
```

### Existing Pattern: Semantic Detection (Phase 12)
```typescript
// Source: Conceptual from Phase 12 semantic detection
// Field path: $.name
// Semantic result: { detectedCategory: 'name', confidence: 0.9, level: 'high' }

// Field path: $.email
// Semantic result: { detectedCategory: 'email', confidence: 0.95, level: 'high' }

// Field path: $.tags (array of strings)
// Semantic result: { detectedCategory: 'tags', confidence: 0.85, level: 'high' }
```

### Existing Pattern: Importance Scoring (Phase 13)
```typescript
// Source: Conceptual from Phase 13 importance analysis
// Field: name ($.name)
// Importance: { tier: 'primary', score: 0.95, signals: ['namePattern:high', 'position:early'] }

// Field: id ($.id)
// Importance: { tier: 'tertiary', score: 0.15, signals: ['metadata:true', 'position:first'] }
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Objects always render as detail view | Objects can render as hero, tabs, or split based on semantics | Phase 14.1 (this phase) | Profile objects get proper hero layout, complex objects organized into tabs |
| Primitive arrays always render as list | Primitive arrays can render as chips for short enum-like values | Phase 14.1 (this phase) | Tag arrays, status lists display as colored chips instead of boring lists |
| Smart selection only for arrays of objects | Smart selection for all schema kinds (arrays of objects, objects, primitive arrays) | Phase 14.1 (this phase) | Complete coverage of smart default system |
| No selection heuristics | 4 heuristics for arrays (Phase 14) | Phase 14 (2026-02-08) | Review arrays, image galleries, timelines, card vs table |
| Type-based defaults only | Three-tier precedence: override > smart > fallback | Phase 14 (2026-02-08) | User control preserved while adding intelligence |

**Deprecated/outdated:**
- **Fixed object → detail mapping:** No longer hardcoded fallback. Objects should be analyzed for hero/tabs/split patterns before falling back to detail.
- **Fixed primitive array → primitive-list mapping:** No longer the only option. Chips renderer available for short enum-like values.

## Open Questions

Things that couldn't be fully resolved:

1. **Nested Object Analysis Depth**
   - What we know: Top-level objects can be analyzed via useSchemaAnalysis. Nested objects within arrays are not analyzed in Phase 14.
   - What's unclear: Should nested objects (like `$.items[].author`) also get smart selection, or only top-level objects?
   - Recommendation: Start with top-level only (simpler). Extend to nested objects in Phase 15 if user testing shows value. The analysis cache already supports arbitrary paths, so extension is straightforward.

2. **Primitive Array Data Requirement**
   - What we know: Chips heuristic needs actual data to check value lengths and uniqueness. Schema analysis runs once when data loads.
   - What's unclear: What if primitive array data loads later (async nested data)? Selection will use fallback.
   - Recommendation: Accept this limitation. Primitive arrays without data default to primitive-list (safe fallback). Re-analysis on data change is out of scope (performance concern).

3. **Profile Pattern Ambiguity**
   - What we know: Clear profile pattern = name + 2+ contact fields. Weak pattern = name + 1 contact field.
   - What's unclear: Should objects with name + image (but no contact fields) trigger hero? What about name + description?
   - Recommendation: Be conservative. Only trigger hero for clear contact-oriented profiles. Name + image alone doesn't imply profile semantics (could be product, article, etc.). Defer expansion to user testing feedback.

4. **Empty Object/Array Handling**
   - What we know: Empty objects {} and empty arrays [] currently render as "Empty object" / "No items" messages.
   - What's unclear: Should smart selection still apply to empty objects (for consistent UI), or always fall back?
   - Recommendation: Fall back to type-based defaults for empty data. No analysis possible without fields/items. This is consistent with existing behavior.

## Sources

### Primary (HIGH confidence)
- Phase 14 implementation: src/services/selection/ (heuristics.ts, index.ts, types.ts)
- Phase 14 research: .planning/phases/14-smart-component-selection/14-RESEARCH.md
- Existing renderers: src/components/renderers/ (HeroRenderer, TabsRenderer, SplitRenderer, ChipsRenderer)
- DynamicRenderer: src/components/DynamicRenderer.tsx (lines 117-132, precedence logic)
- Component registry: src/components/registry/ComponentRegistry.tsx (component type map)
- Schema analysis: src/hooks/useSchemaAnalysis.ts (analysis pipeline)

### Secondary (MEDIUM confidence)
- Phase 12 semantic patterns: src/services/semantic/patterns/ (22 patterns for name, email, phone, tags, etc.)
- Phase 13 importance scoring: src/services/analysis/importance.ts (4-signal algorithm)
- STATE.md context: .planning/STATE.md (lines 69-71, Phase 14.1 insertion rationale)

### Tertiary (LOW confidence)
- None. All findings verified with existing codebase or prior phase documentation.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new dependencies, all components exist
- Architecture: HIGH - Extends proven Phase 14 patterns, same infrastructure
- Pitfalls: HIGH - Documented from Phase 14 implementation experience

**Research date:** 2026-02-08
**Valid until:** 30 days (stable infrastructure, patterns unlikely to change)

**Research gap coverage:**
- ✓ Object selection patterns identified (hero, tabs, split)
- ✓ Primitive array selection patterns identified (chips vs list)
- ✓ Integration with existing pipeline documented
- ✓ No new dependencies required
- ✓ Confidence scoring consistent with Phase 14
- ✓ User override precedence preserved
- ✓ Fallback behavior specified
