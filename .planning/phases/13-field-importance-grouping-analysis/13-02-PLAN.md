---
phase: 13-field-importance-grouping-analysis
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/services/analysis/grouping.ts
  - src/services/analysis/grouping.test.ts
  - src/services/analysis/index.ts
autonomous: true

must_haves:
  truths:
    - "Prefix-based grouping detects common patterns (billing_*, shipping_*, contact_*)"
    - "Semantic clustering groups related fields (email + phone + address -> Contact)"
    - "Grouping only runs when 8+ fields present"
    - "Groups require minimum 3 fields (no tiny groups)"
    - "Grouping skipped if it leaves 1-2 orphan fields"
    - "Group names use title case with suffixes stripped"
  artifacts:
    - path: "src/services/analysis/grouping.ts"
      provides: "detectPrefixGroups, detectSemanticClusters, analyzeGrouping functions"
      exports: ["detectPrefixGroups", "detectSemanticClusters", "analyzeGrouping"]
    - path: "src/services/analysis/grouping.test.ts"
      provides: "Comprehensive tests for grouping detection"
      min_lines: 120
    - path: "src/services/analysis/index.ts"
      provides: "Public API: analyzeFields combining importance + grouping"
      exports: ["analyzeFields", "calculateImportance", "analyzeGrouping"]
  key_links:
    - from: "src/services/analysis/grouping.ts"
      to: "src/services/analysis/config.ts"
      via: "import GROUPING_CONFIG"
      pattern: "import.*GROUPING_CONFIG.*from.*config"
    - from: "src/services/analysis/index.ts"
      to: "src/services/analysis/importance.ts"
      via: "import calculateImportance"
      pattern: "import.*calculateImportance.*from.*importance"
    - from: "src/services/analysis/index.ts"
      to: "src/services/analysis/grouping.ts"
      via: "import analyzeGrouping"
      pattern: "import.*analyzeGrouping.*from.*grouping"
---

<objective>
Implement grouping detection (prefix + semantic clustering) and create the public API for field analysis.

Purpose: Enable automatic field grouping for better organization in detail views. Prefix matching handles naming conventions (billing_*), semantic clustering handles related fields without shared prefix (email+phone+address->Contact).

Output: Grouping detector with hybrid approach, comprehensive tests, and unified analyzeFields() public API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-field-importance-grouping-analysis/13-CONTEXT.md
@.planning/phases/13-field-importance-grouping-analysis/13-RESEARCH.md
@.planning/phases/13-field-importance-grouping-analysis/13-01-SUMMARY.md
@src/services/analysis/types.ts
@src/services/analysis/config.ts
@src/services/analysis/importance.ts
@src/services/semantic/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement grouping detection algorithms</name>
  <files>
    src/services/analysis/grouping.ts
  </files>
  <action>
Implement the hybrid grouping detector with prefix matching and semantic clustering.

**Helper: formatGroupLabel(prefix: string): string**
- Remove trailing separator (_, .)
- Strip common suffixes from config: info, details, data, config, settings, options
- Convert to title case: split by _, capitalize each word, join with space
- Example: billing_info_ -> "Billing", contact_details_ -> "Contact"

**detectPrefixGroups(fields: FieldInfo[], config = GROUPING_CONFIG): PrefixGroup[]**
1. Return empty array if fields.length < config.minFieldsForGrouping (8)
2. Build prefix map: for each field, extract prefix up to last _ or .
3. Filter to prefixes with >= config.minFieldsPerGroup (3) fields
4. Return array of PrefixGroup: { type: 'prefix', prefix, label: formatGroupLabel(prefix), fields }

**detectSemanticClusters(fields: FieldInfo[], config = GROUPING_CONFIG): SemanticCluster[]**
1. Return empty array if fields.length < config.minFieldsForGrouping (8)
2. For each rule in config.semanticClusters:
   - Filter fields where field.semanticCategory is in rule.categories
   - If matching fields >= rule.minFields, create cluster
3. Return array of SemanticCluster: { type: 'semantic', label: rule.name, categories: rule.categories, fields }

Semantic cluster rules from config:
- Contact: ['email', 'phone', 'address'], minFields: 2
- Identity: ['name', 'email', 'avatar'], minFields: 2
- Pricing: ['price', 'currency_code', 'quantity'], minFields: 2
- Temporal: ['date', 'timestamp'], minFields: 2

**analyzeGrouping(fields: FieldInfo[], config = GROUPING_CONFIG): GroupingResult**
1. Return { groups: [], ungrouped: fields } if fields.length < minFieldsForGrouping
2. Run prefix grouping first, track which fields are grouped
3. Run semantic clustering on remaining (non-prefix-grouped) fields to avoid conflicts
4. Calculate ungrouped = fields not in any prefix group or semantic cluster
5. **Orphan check (CRITICAL):** If ungrouped.length is 1 or 2 AND some fields are grouped, return { groups: [], ungrouped: fields } - skip grouping entirely
6. Return { groups: [...prefixGroups, ...semanticClusters], ungrouped }
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/services/analysis/grouping.ts`
  </verify>
  <done>
    - detectPrefixGroups finds billing_*, shipping_*, contact_* patterns
    - detectSemanticClusters groups email+phone+address into "Contact"
    - Grouping skipped if <8 fields total
    - Groups require minimum 3 fields
    - Orphan check prevents grouping that leaves 1-2 fields ungrouped
    - Prefix grouping runs first, semantic clustering excludes those fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive grouping tests</name>
  <files>
    src/services/analysis/grouping.test.ts
  </files>
  <action>
Write comprehensive tests for the grouping detector covering all logic and edge cases.

**Test Categories:**

1. **Prefix Group Detection Tests:**
   - 3 billing_* fields creates "Billing" group
   - 4 shipping_* fields creates "Shipping" group
   - 2 billing_* fields (below min) creates no group
   - Mixed separators: user_name, user.email both group under user
   - No prefix fields returns empty groups

2. **Group Label Formatting Tests:**
   - billing_ -> "Billing"
   - shipping_address_ -> "Shipping Address"
   - contact_info_ -> "Contact" (info suffix stripped)
   - user_details_ -> "User" (details suffix stripped)
   - order_data_ -> "Order" (data suffix stripped)

3. **Semantic Cluster Detection Tests:**
   - email + phone + address -> "Contact" cluster
   - name + email + avatar -> "Identity" cluster
   - price + currency_code -> "Pricing" cluster (with 2 min)
   - date + timestamp -> "Temporal" cluster
   - Single email field -> no cluster (below minFields)

4. **Minimum Field Threshold Tests:**
   - 7 fields total -> no grouping (below 8 threshold)
   - 8 fields with clear groups -> grouping applied
   - 10 fields with 3 prefix matches -> group created

5. **Orphan Prevention Tests (CRITICAL):**
   - 8 fields: 6 grouped, 2 ungrouped -> skip grouping entirely
   - 8 fields: 5 grouped, 3 ungrouped -> grouping allowed
   - 8 fields: 7 grouped, 1 ungrouped -> skip grouping entirely
   - 8 fields: 8 grouped, 0 ungrouped -> grouping allowed

6. **Prefix vs Semantic Conflict Prevention:**
   - contact_email, contact_phone, contact_address: prefix group only, not also semantic
   - email, phone, address (no prefix): semantic cluster "Contact" created
   - Mix: some prefix, some not: prefix fields excluded from semantic clustering

7. **Integration Tests:**
   - Realistic e-commerce object with billing_, shipping_, and identity fields
   - Realistic user profile with contact info and metadata
   - Object with no groupable patterns returns empty groups

Use Vitest: `import { describe, it, expect } from 'vitest'`
  </action>
  <verify>
    Run tests: `npm test src/services/analysis/grouping.test.ts`
  </verify>
  <done>
    - All test categories pass
    - Orphan prevention confirmed working
    - Prefix vs semantic conflict handling verified
    - At least 30 individual test cases
  </done>
</task>

<task type="auto">
  <name>Task 3: Create public API and integration exports</name>
  <files>
    src/services/analysis/index.ts
  </files>
  <action>
Create the public API for the analysis module that combines importance scoring and grouping.

**analyzeFields(fields: FieldInfo[], config = ANALYSIS_CONFIG): AnalysisResult**
1. Create importance Map<string, ImportanceScore>: for each field, call calculateImportance
2. Create grouping result by calling analyzeGrouping(fields, config.grouping)
3. Return { importance, grouping }

**Exports:**
- Types: ImportanceTier, ImportanceScore, FieldInfo, GroupingResult, FieldGroup, AnalysisResult
- Config: ANALYSIS_CONFIG, IMPORTANCE_CONFIG, GROUPING_CONFIG
- Functions: analyzeFields (main), calculateImportance, analyzeGrouping
- Helpers: isMetadataField, detectPrefixGroups, detectSemanticClusters

This is the public API for Phase 14+ consumption. All other modules should import from 'src/services/analysis' not from individual files.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/services/analysis/index.ts`
    Integration test: Run `npm test src/services/analysis`
  </verify>
  <done>
    - analyzeFields returns both importance Map and grouping result
    - All types exported from index.ts
    - All key functions exported
    - Module can be imported as `import { analyzeFields } from '@/services/analysis'`
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All grouping tests pass: `npm test src/services/analysis/grouping.test.ts`
3. All analysis tests pass: `npm test src/services/analysis`
4. Orphan prevention works: grouping skipped when 1-2 fields would be orphaned
5. Prefix/semantic conflict avoided: fields grouped by prefix not re-grouped semantically
</verification>

<success_criteria>
- grouping.ts implements hybrid prefix + semantic clustering
- analyzeGrouping handles orphan prevention correctly
- detectPrefixGroups and detectSemanticClusters work independently
- index.ts exports unified analyzeFields() API
- All tests pass with comprehensive coverage
- Module ready for Phase 14 integration with DynamicRenderer
</success_criteria>

<output>
After completion, create `.planning/phases/13-field-importance-grouping-analysis/13-02-SUMMARY.md`
</output>
