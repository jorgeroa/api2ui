---
phase: 13-field-importance-grouping-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/analysis/types.ts
  - src/services/analysis/config.ts
  - src/services/analysis/importance.ts
  - src/services/analysis/importance.test.ts
autonomous: true

must_haves:
  truths:
    - "Fields with important names (title, name, headline) score as primary (>=80%)"
    - "Metadata fields (id, _prefixed, timestamps) are forced to tertiary regardless of other signals"
    - "Importance scoring uses configurable weights that sum to 1.0 (40/25/20/15)"
    - "Tier thresholds are >=80% primary, 50-79% secondary, <50% tertiary"
  artifacts:
    - path: "src/services/analysis/types.ts"
      provides: "ImportanceTier, ImportanceScore, FieldInfo, SignalMatch types"
      exports: ["ImportanceTier", "ImportanceScore", "FieldInfo", "ImportanceSignalMatch"]
    - path: "src/services/analysis/config.ts"
      provides: "ANALYSIS_CONFIG with all weights, thresholds, metadata patterns"
      exports: ["ANALYSIS_CONFIG", "IMPORTANCE_CONFIG", "GROUPING_CONFIG"]
    - path: "src/services/analysis/importance.ts"
      provides: "calculateImportance function with 4-signal scoring"
      exports: ["calculateImportance", "isMetadataField"]
    - path: "src/services/analysis/importance.test.ts"
      provides: "Comprehensive tests for importance scoring"
      min_lines: 100
  key_links:
    - from: "src/services/analysis/importance.ts"
      to: "src/services/analysis/config.ts"
      via: "import IMPORTANCE_CONFIG"
      pattern: "import.*IMPORTANCE_CONFIG.*from.*config"
    - from: "src/services/analysis/importance.ts"
      to: "src/services/semantic/types.ts"
      via: "import SemanticCategory"
      pattern: "import.*SemanticCategory.*from.*semantic"
---

<objective>
Create the foundation types and importance scoring algorithm for field analysis.

Purpose: Enable automatic detection of primary/secondary/tertiary fields based on multi-signal scoring, with forced metadata de-emphasis. This is the first half of the Phase 13 analysis layer.

Output: Types, configurable weights/thresholds, and importance scorer with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-field-importance-grouping-analysis/13-CONTEXT.md
@.planning/phases/13-field-importance-grouping-analysis/13-RESEARCH.md
@src/services/semantic/types.ts
@src/services/semantic/scorer.ts
@src/types/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create analysis types and configuration</name>
  <files>
    src/services/analysis/types.ts
    src/services/analysis/config.ts
  </files>
  <action>
Create the analysis module foundation following Phase 12's pattern structure.

**types.ts:**
- `ImportanceTier = 'primary' | 'secondary' | 'tertiary'`
- `ImportanceSignalMatch` interface (name, matched, weight, contribution) - similar to semantic SignalMatch
- `ImportanceScore` interface with tier, score (0.0-1.0), and signals array
- `FieldInfo` interface for input to scoring: path, name, semanticCategory (from Phase 12), sampleValues, position, totalFields
- `GroupingResult`, `FieldGroup`, `PrefixGroup`, `SemanticCluster` types (for Plan 02)
- `AnalysisResult` combining importance Map and grouping result

**config.ts:**
- `ANALYSIS_CONFIG` as const object with importance and grouping sections
- importance.weights: { namePattern: 0.40, visualRichness: 0.25, dataPresence: 0.20, position: 0.15 }
- importance.tierThresholds: { primary: 0.80, secondary: 0.50 }
- importance.metadataPatterns: array of RegExp for id, _prefix, foreign keys, internal timestamps
- importance.primaryIndicators: RegExp array for name/title/headline patterns
- grouping section with minFieldsForGrouping: 8, minFieldsPerGroup: 3, suffixesToStrip, semanticClusters
- Export `IMPORTANCE_CONFIG` and `GROUPING_CONFIG` as typed subsets

Follow the exact structure from RESEARCH.md but ensure all weights sum to 1.0.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/services/analysis/types.ts src/services/analysis/config.ts`
  </verify>
  <done>
    - types.ts exports ImportanceTier, ImportanceScore, FieldInfo, all group types
    - config.ts exports ANALYSIS_CONFIG with weights summing to 1.0
    - IMPORTANCE_CONFIG.weights values sum to exactly 1.0
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement importance scoring algorithm</name>
  <files>
    src/services/analysis/importance.ts
  </files>
  <action>
Implement the 4-signal importance scorer following Phase 12's scorer.ts pattern.

**calculateImportance(field: FieldInfo, config = IMPORTANCE_CONFIG): ImportanceScore**

1. **Name pattern signal (40%):**
   - Check field.name against primaryIndicators regex array
   - Return 1.0 if any match, 0.0 otherwise
   - Multiply by config.weights.namePattern

2. **Visual richness signal (25%):**
   - Use field.semanticCategory (from Phase 12)
   - High richness (1.0): image, video, thumbnail, avatar
   - Medium richness (0.6): title, name, description
   - Low richness (0.2): uuid, timestamp, date
   - Default: 0.4
   - Multiply by config.weights.visualRichness

3. **Data presence signal (20%):**
   - Count non-null/undefined/empty values in field.sampleValues
   - Score = nonNullCount / sampleValues.length
   - Multiply by config.weights.dataPresence

4. **Position signal (15%):**
   - Use logarithmic decay: Math.max(0.2, 1.0 - Math.log10(normalizedPosition * 10 + 1) * 0.5)
   - normalizedPosition = field.position / field.totalFields
   - Multiply by config.weights.position

5. **Tier determination:**
   - Sum all weighted signals to get totalScore (0.0-1.0)
   - If totalScore >= tierThresholds.primary (0.80): tier = 'primary'
   - Else if totalScore >= tierThresholds.secondary (0.50): tier = 'secondary'
   - Else: tier = 'tertiary'

6. **Metadata override (CRITICAL):**
   - After tier determination, check if field.name matches any metadataPatterns
   - If true: force tier = 'tertiary' regardless of score
   - Helper: `isMetadataField(name: string, patterns: RegExp[]): boolean`

Return { tier, score: totalScore, signals } where signals tracks each of the 4 contributions.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/services/analysis/importance.ts`
  </verify>
  <done>
    - calculateImportance returns correct tier based on weighted signals
    - Metadata fields forced to tertiary (id, _internal, user_id, created_at)
    - Primary indicators (name, title, headline) boost score appropriately
    - Position scoring uses logarithmic decay, not linear
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive importance scoring tests</name>
  <files>
    src/services/analysis/importance.test.ts
  </files>
  <action>
Write comprehensive tests for the importance scorer covering all signals and edge cases.

**Test Categories:**

1. **Name Pattern Signal Tests:**
   - 'title' field gets high name pattern contribution
   - 'name' field gets high name pattern contribution
   - 'headline' field gets high name pattern contribution
   - Random field name (e.g., 'foo') gets zero contribution
   - Case insensitivity: 'Title', 'NAME' should match

2. **Visual Richness Signal Tests:**
   - Image semantic category returns 1.0 richness
   - Avatar semantic category returns 1.0 richness
   - Title category returns 0.6 richness
   - UUID category returns 0.2 richness
   - Null category returns 0.4 default

3. **Data Presence Signal Tests:**
   - All non-null values returns 1.0
   - Half null values returns 0.5
   - All null/empty values returns 0.0
   - Empty sampleValues array returns 0.0

4. **Position Signal Tests:**
   - Position 0 of 10 returns high score (~1.0)
   - Position 5 of 10 returns medium score (~0.7)
   - Position 9 of 10 returns low score (~0.4)
   - Single field (position 0, total 1) returns 1.0

5. **Tier Assignment Tests:**
   - Score >= 0.80 returns 'primary'
   - Score 0.50-0.79 returns 'secondary'
   - Score < 0.50 returns 'tertiary'
   - Combined high signals (name + image + full data + first position) = primary

6. **Metadata Override Tests (CRITICAL):**
   - 'id' field forced to tertiary even with high score
   - '_internal' field forced to tertiary
   - 'user_id' (foreign key pattern) forced to tertiary
   - 'created_at' forced to tertiary
   - 'updated_at' forced to tertiary
   - 'title' NOT forced to tertiary (not metadata)

7. **Integration Tests:**
   - Typical product object: title=primary, price=secondary, id=tertiary
   - Typical user object: name=primary, email=secondary, uuid=tertiary
   - All weights sum to 1.0 (config validation test)

Use Vitest: `import { describe, it, expect } from 'vitest'`
  </action>
  <verify>
    Run tests: `npm test src/services/analysis/importance.test.ts`
  </verify>
  <done>
    - All test categories pass
    - Metadata override tests confirm forced tertiary
    - No test using hardcoded weights (use config values)
    - At least 25 individual test cases
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All importance tests pass: `npm test src/services/analysis/importance.test.ts`
3. Config weights sum to 1.0: IMPORTANCE_CONFIG.weights values sum equals 1.0
4. Metadata fields correctly forced to tertiary tier
</verification>

<success_criteria>
- src/services/analysis/ directory created with types.ts, config.ts, importance.ts, importance.test.ts
- calculateImportance correctly scores fields using 4 weighted signals
- Metadata fields (id, _prefix, foreign keys, timestamps) always return tertiary tier
- All tests pass with comprehensive coverage of signals and edge cases
- Configuration is type-safe and easily adjustable
</success_criteria>

<output>
After completion, create `.planning/phases/13-field-importance-grouping-analysis/13-01-SUMMARY.md`
</output>
