---
phase: 16-context-aware-components
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/components/renderers/PrimitiveRenderer.tsx
  - src/components/renderers/FieldRow.tsx
  - src/components/renderers/ChipsRenderer.tsx
autonomous: false

must_haves:
  truths:
    - "Status fields with high-confidence semantic detection render as colored StatusBadge instead of plain text"
    - "Rating fields with high-confidence detection render as StarRating with stars instead of plain number"
    - "Price fields with high-confidence detection render as CurrencyValue with locale formatting instead of $X.XX"
    - "Date/timestamp fields with high-confidence detection render as FormattedDate with Intl formatting"
    - "Boolean fields with status-like names render as StatusBadge with check/X icons"
    - "Tag/category primitive arrays render as TagChips with copy-on-click when detected"
    - "Fields fall back to existing rendering when semantic detection is low confidence (<0.75)"
    - "User overrides via fieldConfigs still take precedence over semantic rendering"
  artifacts:
    - path: "src/components/renderers/PrimitiveRenderer.tsx"
      provides: "Semantic-aware rendering branches for status, rating, price, date, boolean"
    - path: "src/components/renderers/FieldRow.tsx"
      provides: "Passes semantic metadata to PrimitiveRenderer via analysis cache"
    - path: "src/components/renderers/ChipsRenderer.tsx"
      provides: "Enhanced with TagChips copy-on-click and truncation"
  key_links:
    - from: "src/components/renderers/PrimitiveRenderer.tsx"
      to: "src/components/renderers/semantic/StatusBadge.tsx"
      via: "import and render for status/boolean fields"
      pattern: "import.*StatusBadge.*from.*semantic/StatusBadge"
    - from: "src/components/renderers/PrimitiveRenderer.tsx"
      to: "src/store/appStore.ts"
      via: "getAnalysisCache for semantic metadata lookup"
      pattern: "getAnalysisCache"
    - from: "src/components/renderers/PrimitiveRenderer.tsx"
      to: "src/components/renderers/semantic/CurrencyValue.tsx"
      via: "import detectCurrencyFromSiblings + CurrencyValue"
      pattern: "import.*detectCurrencyFromSiblings.*from.*semantic/CurrencyValue"
---

<objective>
Wire semantic components into PrimitiveRenderer and ChipsRenderer so detected semantic types render with specialized formatting. PrimitiveRenderer checks the analysis cache for high-confidence semantic metadata and routes to the appropriate semantic component. ChipsRenderer gains copy-on-click and truncation via TagChips.

Purpose: This is the user-visible payoff of Phases 12-15. Status fields become colored badges, ratings show stars, prices get locale-aware formatting, and dates display human-readable text. Without this wiring, all the semantic detection infrastructure produces no visual change.

Output: Updated PrimitiveRenderer with semantic branches, enhanced ChipsRenderer, and a checkpoint for visual verification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-context-aware-components/16-CONTEXT.md
@.planning/phases/16-context-aware-components/16-RESEARCH.md
@.planning/phases/16-context-aware-components/16-01-SUMMARY.md
@src/components/renderers/PrimitiveRenderer.tsx
@src/components/renderers/FieldRow.tsx
@src/components/renderers/ChipsRenderer.tsx
@src/store/appStore.ts
@src/types/schema.ts
@src/services/semantic/types.ts
@src/hooks/useSchemaAnalysis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire PrimitiveRenderer with semantic-aware rendering branches</name>
  <files>
    src/components/renderers/PrimitiveRenderer.tsx
  </files>
  <action>
    **Integration approach:** PrimitiveRenderer receives a `path` prop. Use this path to look up semantic metadata from the analysis cache. The cache is keyed by the parent path (e.g., `$[]` for array items, `$` for root object). The semantics Map inside the cache entry is keyed by the full field path (e.g., `$[].status`).

    **Add imports at top of PrimitiveRenderer.tsx:**
    ```
    import { useAppStore } from '../../store/appStore'
    import { StatusBadge } from './semantic/StatusBadge'
    import { StarRating } from './semantic/StarRating'
    import { CurrencyValue, detectCurrencyFromSiblings } from './semantic/CurrencyValue'
    import { FormattedDate } from './semantic/FormattedDate'
    ```

    **Add path normalization helper** (same as in DetailRenderer.tsx):
    ```
    function normalizePath(path: string): string {
      return path.replace(/\[\d+\]/g, '[]')
    }
    ```

    **Add semantic lookup helper** inside PrimitiveRenderer component body, before rendering logic:
    ```
    // Semantic-aware rendering: check analysis cache for high-confidence detection
    const { getAnalysisCache, data: rootData } = useAppStore()

    // Determine parent path for cache lookup (e.g., "$[].status" -> "$[]")
    const pathParts = path.split('.')
    const fieldPath = path
    const parentPath = pathParts.length > 1 ? pathParts.slice(0, -1).join('.') : path

    // Try both exact and normalized parent paths for cache lookup
    const cached = getAnalysisCache(parentPath) || getAnalysisCache(normalizePath(parentPath))
    const semantics = cached?.semantics?.get(fieldPath) || cached?.semantics?.get(normalizePath(fieldPath))
    const hasHighConfidence = semantics && semantics.level === 'high'
    ```

    **Modify the boolean handler** (line ~97-109): Before the existing boolean rendering, check if the field name suggests a status boolean. If `hasHighConfidence && semantics.detectedCategory === 'status'`, OR if the field name matches `/^(is_|has_|can_)?(active|enabled|verified|published|approved|visible|available|blocked|banned|deleted|suspended)/i`, render `<StatusBadge value={data} />` instead of the existing green/gray span.

    **Modify the number handler** (line ~112-136): After getting `renderMode` from config/detectPrimitiveMode, add semantic-aware checks BEFORE the existing renderMode checks (but AFTER config override check). The precedence must be: user override (fieldConfigs) > semantic detection > existing heuristic detection.

    Specifically:
    - If NO user override AND `hasHighConfidence && semantics.detectedCategory === 'rating'`: render `<StarRating value={data} />`
    - If NO user override AND `hasHighConfidence && semantics.detectedCategory === 'price'`: detect currency from sibling fields. Navigate to parent object: traverse rootData using parentPath parts (handle array indices like `[0]`), then call `detectCurrencyFromSiblings(fieldName, parentObj)`. Render `<CurrencyValue amount={data} currencyCode={detectedCurrency} />`
    - If user HAS override (config.componentType exists), keep existing behavior

    **Modify the date handler** (line ~139-156): When rendering date-typed values, if `hasHighConfidence && (semantics.detectedCategory === 'date' || semantics.detectedCategory === 'timestamp')` AND no user override, render `<FormattedDate value={data as string} />` instead of `date.toLocaleString()`.

    **Modify the string date-like handler** (line ~205-223): When isDateLike detects a date string, if `hasHighConfidence && (semantics.detectedCategory === 'date' || semantics.detectedCategory === 'timestamp')` AND no user render mode override, render `<FormattedDate value={data} />` instead of the existing `date.toLocaleString()`.

    **Add status string handler** (before the "Apply auto-detection" section, ~line 225): If `hasHighConfidence && semantics.detectedCategory === 'status'` AND no user render mode override AND value is string, render `<StatusBadge value={data} />`.

    **Critical precedence rule:** User overrides (`fieldConfigs[path]?.componentType`) ALWAYS take precedence. Only apply semantic rendering when no explicit user override exists. This preserves the three-tier precedence: override > smart > fallback.

    **Important: Do NOT change getAvailableRenderModes.** The mode list stays the same — semantic rendering is automatic, not a selectable mode.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors.
    Run `npm test` to ensure no regressions.
    Check that PrimitiveRenderer imports all 4 semantic components.
  </verify>
  <done>
    PrimitiveRenderer renders semantic components for high-confidence fields.
    User overrides still take precedence over semantic rendering.
    Low-confidence fields fall back to existing rendering logic unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance ChipsRenderer with TagChips features</name>
  <files>
    src/components/renderers/ChipsRenderer.tsx
  </files>
  <action>
    **Goal:** Enhance ChipsRenderer to use the TagChips component for copy-on-click and +N more truncation, while preserving the existing API (it still receives RendererProps, not TagChipsProps).

    **Approach:** Import TagChips from the semantic components and delegate rendering to it when data is a string array.

    **Changes to ChipsRenderer.tsx:**
    1. Import: `import { TagChips } from './semantic/TagChips'`
    2. Keep existing validation (schema.kind check, array check, empty check)
    3. After validation, check if data is an array of strings: `const isStringArray = data.every(item => typeof item === 'string')`
    4. If `isStringArray`: render `<TagChips tags={data as string[]} maxVisible={8} />` — use maxVisible=8 for standalone renderer (more space than inline)
    5. If NOT all strings (mixed types, numbers): keep existing colorful chip rendering with `chipColors` array (existing behavior preserved for non-tag arrays)

    This means: tag-like arrays get monochrome chips with copy-on-click (per user decision). Mixed/non-string arrays keep colorful chips (existing behavior).
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors.
    Check that ChipsRenderer imports TagChips.
  </verify>
  <done>
    ChipsRenderer delegates to TagChips for string arrays (monochrome, copy-on-click, truncation).
    Non-string arrays keep existing colorful chip rendering.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Context-aware semantic rendering across the entire application:
    - Status fields render as colored badges (green for active/published, red for error/deleted, yellow for pending, gray for neutral)
    - Boolean fields (is_active, enabled) render as check/X badges
    - Rating fields render as Unicode star displays (filled/half/empty)
    - Price fields render with locale-aware currency formatting via Intl.NumberFormat
    - Date fields render with locale-aware formatting via Intl.DateTimeFormat (with time when ISO T present)
    - Tag arrays render as monochrome chips with copy-on-click and +N more truncation
  </what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Load dummyjson.com/products — verify:
       - Price fields show locale-formatted currency (e.g., "$549.99" or equivalent in your locale)
       - Rating fields show star displays (e.g., ★★★★☆ (4.1))
       - Tags show as monochrome chips, click one to verify clipboard copy + toast
       - "availabilityStatus" field shows as colored badge
    3. Load dummyjson.com/products/1 — drill into a single product, verify:
       - Same semantic rendering in detail view
       - Tags truncate with "+N more" if many items
    4. Load jsonplaceholder.typicode.com/users/1 — verify:
       - Date fields show locale-aware formatting
    5. Verify degradation: fields without high-confidence semantic detection should render exactly as before (plain text, existing heuristics)
    6. Test user override: right-click a price field, switch to "text" mode — verify it shows raw number, not formatted currency (override takes precedence)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm test` passes with no regressions
3. PrimitiveRenderer uses analysis cache for semantic routing
4. User overrides (fieldConfigs) still take precedence over semantic rendering
5. Low-confidence fields fall back to existing rendering unchanged
6. ChipsRenderer uses TagChips for string arrays
</verification>

<success_criteria>
- Status fields render as colored pill badges matching semantic color scheme
- Boolean status fields render as check/X icon badges
- Rating fields render as star displays with half-star precision
- Price fields render with Intl.NumberFormat currency formatting
- Date fields render with Intl.DateTimeFormat (absolute only, time when T present)
- Tag arrays render as monochrome chips with copy-on-click
- User overrides always take precedence over semantic rendering
- No regressions in existing field rendering
</success_criteria>

<output>
After completion, create `.planning/phases/16-context-aware-components/16-02-SUMMARY.md`
</output>
