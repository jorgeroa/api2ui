---
phase: 12-core-semantic-detection
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - src/services/semantic/detector.test.ts
  - src/services/semantic/scorer.test.ts
autonomous: true

must_haves:
  truths:
    - "Positive detection: 'price' field with numeric value gets >75% confidence"
    - "Positive detection: 'rating' field with value 4.5 gets >75% confidence"
    - "Negative test: generic names like 'data', 'value' get <75% confidence"
    - "Composite test: reviews array with rating+comment detected correctly"
    - "OpenAPI hints boost confidence for matching formats"
    - "Multilingual: 'precio' detected as price pattern"
  artifacts:
    - path: "src/services/semantic/detector.test.ts"
      provides: "Detection engine tests"
      min_lines: 100
    - path: "src/services/semantic/scorer.test.ts"
      provides: "Scorer tests"
      min_lines: 50
  key_links:
    - from: "src/services/semantic/detector.test.ts"
      to: "src/services/semantic"
      via: "imports detectSemantics"
      pattern: "import.*detectSemantics"
---

<objective>
Validate the semantic detection engine with comprehensive tests covering positive matches, negative cases, edge cases, and multilingual support.

Purpose: Ensure the detection engine meets SEM-01 through SEM-04 requirements with explicit test coverage.
Output: Test suites that validate pattern matching, confidence scoring, and edge case handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-core-semantic-detection/12-02-SUMMARY.md
@.planning/phases/12-core-semantic-detection/12-CONTEXT.md
@src/services/semantic/index.ts
@src/services/semantic/detector.ts
@src/services/semantic/scorer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core detection and scoring tests</name>
  <files>src/services/semantic/scorer.test.ts, src/services/semantic/detector.test.ts</files>
  <action>
Create `src/services/semantic/scorer.test.ts`:

Test calculateConfidence function:
1. Test with perfect match (name + type + value all match) -> high confidence (>= 0.90)
2. Test with partial match (name only matches) -> medium/low confidence
3. Test with no match at all -> confidence near 0, level 'none'
4. Test weight calculation correctness (verify math)
5. Test that formatHints boost confidence when OpenAPI format matches

Create `src/services/semantic/detector.test.ts`:

**Positive detection tests (should match with >75% confidence):**
```typescript
describe('positive detection', () => {
  test('price field with numeric value', () => {
    const results = detectSemantics('root.price', 'price', 'number', [29.99])
    expect(results[0].category).toBe('price')
    expect(results[0].confidence).toBeGreaterThanOrEqual(0.75)
  })
  // Similar tests for:
  // - { name: 'cost', type: 'number', value: 100 } -> 'price' (synonym)
  // - { name: 'rating', type: 'number', value: 4.5 } -> 'rating'
  // - { name: 'email', type: 'string', value: 'test@example.com' } -> 'email'
  // - { name: 'image_url', type: 'string', value: 'https://example.com/img.jpg' } -> 'image'
  // - { name: 'tags', type: 'array', value: ['tech', 'news'] } -> 'tags'
  // - { name: 'status', type: 'string', value: 'active' } -> 'status'
  // - { name: 'uuid', type: 'string', value: '123e4567-e89b-12d3-a456-426614174000' } -> 'uuid'
})
```

**Multilingual tests (should match with >75% confidence):**
```typescript
describe('multilingual detection', () => {
  test('Spanish: precio -> price', () => {
    const results = detectSemantics('root.precio', 'precio', 'number', [50])
    expect(results[0].category).toBe('price')
    expect(results[0].confidence).toBeGreaterThanOrEqual(0.75)
  })
  // - { name: 'prix', type: 'number', value: 50 } -> 'price' (French)
  // - { name: 'preis', type: 'number', value: 50 } -> 'price' (German)
  // - { name: 'nombre', type: 'string', value: 'Juan' } -> 'name' (Spanish)
})
```

**Negative tests (should NOT match with >75% confidence):**
```typescript
describe('negative detection', () => {
  test('generic name "data" should not match', () => {
    const results = detectSemantics('root.data', 'data', 'object', [{}])
    const highConfidence = results.filter(r => r.confidence >= 0.75)
    expect(highConfidence.length).toBe(0)
  })
  // - { name: 'value', type: 'string' } -> no confident match
  // - { name: 'item', type: 'object' } -> no confident match
  // - { name: 'result', type: 'string' } -> no confident match
  // - { name: 'price', type: 'string', value: 'expensive' } -> low confidence (type mismatch)
  // - { name: 'rating', type: 'string', value: 'good' } -> low confidence (type mismatch)
})
```

**OpenAPI format hint tests:**
```typescript
describe('OpenAPI format hints', () => {
  test('format email boosts confidence', () => {
    const results = detectSemantics('root.contact', 'contact', 'string', ['a@b.com'], { format: 'email' })
    expect(results[0].category).toBe('email')
    expect(results[0].confidence).toBeGreaterThanOrEqual(0.75)
  })
  // - { name: 'created', format: 'date-time' } -> 'date' boost
  // - { name: 'amount', format: 'currency' } -> 'price' boost
})
```

**Composite pattern tests:**
```typescript
describe('composite patterns', () => {
  test('reviews array with rating+comment fields', () => {
    const itemFields = [
      { name: 'rating', type: 'number' },
      { name: 'comment', type: 'string' }
    ]
    const result = detectCompositeSemantics('root.reviews', 'reviews', itemFields, [])
    expect(result?.category).toBe('reviews')
  })
  // - Array named 'comments' with { rating, text } -> 'reviews'
  // - Array named 'products' with { rating, name } -> NOT 'reviews' (missing comment)
})
```

Use Vitest for testing (project already uses it). Use describe/test blocks.
  </action>
  <verify>
    - `npm test src/services/semantic` passes all tests
    - At least 20 test cases covering positive, negative, multilingual, OpenAPI, composite
  </verify>
  <done>Comprehensive test suite validates detection accuracy and edge cases</done>
</task>

<task type="auto">
  <name>Task 2: Edge cases and performance validation</name>
  <files>src/services/semantic/detector.test.ts</files>
  <action>
Add additional test cases to detector.test.ts:

**Edge cases:**
```typescript
describe('edge cases', () => {
  test('empty field name returns no matches', () => {
    const results = detectSemantics('root.', '', 'string', ['value'])
    expect(results.filter(r => r.confidence >= 0.75).length).toBe(0)
  })

  test('empty sample values still detects by name', () => {
    const results = detectSemantics('root.price', 'price', 'number', [])
    expect(results[0].category).toBe('price')
    // Lower confidence without value validation
  })

  test('null values in sample array handled gracefully', () => {
    const results = detectSemantics('root.price', 'price', 'number', [null, 29.99, null])
    expect(results[0].category).toBe('price')
  })

  test('case insensitive: PRICE, Price, pRiCe all match', () => {
    for (const name of ['PRICE', 'Price', 'pRiCe']) {
      const results = detectSemantics(`root.${name}`, name, 'number', [10])
      expect(results[0].category).toBe('price')
    }
  })

  test('underscore naming: product_price matches price', () => {
    const results = detectSemantics('root.product_price', 'product_price', 'number', [29.99])
    expect(results[0].category).toBe('price')
  })

  test('camelCase: productPrice matches price', () => {
    const results = detectSemantics('root.productPrice', 'productPrice', 'number', [29.99])
    expect(results[0].category).toBe('price')
  })
})
```

**Type mismatch handling:**
```typescript
describe('type mismatch handling', () => {
  test('rating field with string value has lower confidence', () => {
    const goodResults = detectSemantics('root.rating', 'rating', 'number', [4.5])
    const badResults = detectSemantics('root.rating', 'rating', 'string', ['4.5'])
    expect(goodResults[0].confidence).toBeGreaterThan(badResults[0]?.confidence ?? 0)
  })

  test('price field with boolean value has very low confidence', () => {
    const results = detectSemantics('root.price', 'price', 'boolean', [true])
    expect(results[0]?.confidence ?? 0).toBeLessThan(0.5)
  })
})
```

**Cache/memoization tests:**
```typescript
describe('memoization', () => {
  beforeEach(() => {
    clearSemanticCache()
  })

  test('same field detected twice returns cached result', () => {
    const first = detectSemantics('root.price', 'price', 'number', [10])
    const second = detectSemantics('root.price', 'price', 'number', [10])
    expect(first).toBe(second) // Same reference = cached
  })

  test('different fields do not share cache', () => {
    const price = detectSemantics('root.price', 'price', 'number', [10])
    const rating = detectSemantics('root.rating', 'rating', 'number', [4])
    expect(price[0].category).not.toBe(rating[0].category)
  })

  test('cache can be cleared', () => {
    const first = detectSemantics('root.price', 'price', 'number', [10])
    clearSemanticCache()
    const second = detectSemantics('root.price', 'price', 'number', [10])
    expect(first).not.toBe(second) // Different reference after clear
  })
})
```

**Performance smoke test:**
```typescript
describe('performance', () => {
  test('detect 100 fields in under 100ms', () => {
    clearSemanticCache()
    const fields = Array.from({ length: 100 }, (_, i) => ({
      path: `root.field${i}`,
      name: i % 2 === 0 ? 'price' : 'rating',
      type: 'number',
      values: [i]
    }))

    const start = performance.now()
    for (const field of fields) {
      detectSemantics(field.path, field.name, field.type, field.values)
    }
    const duration = performance.now() - start

    expect(duration).toBeLessThan(100)
  })
})
```
  </action>
  <verify>
    - `npm test src/services/semantic` passes all tests
    - Edge cases documented and covered
    - Performance test confirms <100ms for 100 field batch detection
  </verify>
  <done>Edge cases and performance validated, test suite complete</done>
</task>

</tasks>

<verification>
1. `npm test src/services/semantic` - all tests pass
2. Test count: at least 30 test cases total
3. Coverage includes: positive, negative, multilingual, OpenAPI, composite, edge cases, performance
4. Performance: 100 fields detected in <100ms
</verification>

<success_criteria>
- All tests pass with `npm test src/services/semantic`
- Positive detection accuracy: all expected patterns matched with confidence >= 0.75
- Negative detection accuracy: generic names get confidence < 0.75
- Multilingual patterns work for en/es/fr/de
- OpenAPI hints properly boost confidence
- Composite patterns detect structured arrays correctly
- Performance under 100ms for typical API response (100 fields)
</success_criteria>

<output>
After completion, create `.planning/phases/12-core-semantic-detection/12-03-SUMMARY.md`
</output>
