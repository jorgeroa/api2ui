---
phase: 12-core-semantic-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/semantic/types.ts
  - src/services/semantic/scorer.ts
  - src/services/semantic/cache.ts
  - src/types/schema.ts
autonomous: true

must_haves:
  truths:
    - "SemanticPattern type defines multi-signal structure"
    - "ConfidenceResult type includes category, confidence, level"
    - "calculateConfidence function produces weighted score"
    - "FieldDefinition has optional semantics field"
  artifacts:
    - path: "src/services/semantic/types.ts"
      provides: "Core semantic types"
      exports: ["SemanticPattern", "ConfidenceResult", "SemanticCategory"]
    - path: "src/services/semantic/scorer.ts"
      provides: "Confidence calculation"
      exports: ["calculateConfidence"]
    - path: "src/services/semantic/cache.ts"
      provides: "Memoization utility"
      exports: ["createMemoizedDetector"]
    - path: "src/types/schema.ts"
      provides: "Extended FieldDefinition"
      contains: "semantics?:"
  key_links:
    - from: "src/services/semantic/scorer.ts"
      to: "src/services/semantic/types.ts"
      via: "imports SemanticPattern, ConfidenceResult"
      pattern: "import.*from.*types"
---

<objective>
Create the foundational types and utilities for semantic field detection.

Purpose: Establish the type system and core algorithms that all pattern definitions and detection logic will use.
Output: Type definitions, confidence scoring algorithm, memoization cache, and extended schema types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-core-semantic-detection/12-CONTEXT.md
@.planning/phases/12-core-semantic-detection/12-RESEARCH.md
@src/types/schema.ts
@src/utils/primitiveDetection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create semantic types and interfaces</name>
  <files>src/services/semantic/types.ts</files>
  <action>
Create `src/services/semantic/types.ts` with:

1. SemanticCategory type - union of all semantic categories:
   'price' | 'currency_code' | 'sku' | 'quantity' |
   'rating' | 'reviews' | 'tags' | 'status' |
   'image' | 'video' | 'thumbnail' | 'avatar' |
   'email' | 'phone' | 'uuid' | 'name' | 'address' | 'url' |
   'date' | 'timestamp' | 'description' | 'title'

2. ConfidenceLevel type: 'high' | 'medium' | 'low' | 'none'

3. SignalMatch interface:
   - name: string (signal identifier)
   - matched: boolean
   - weight: number (0.0-1.0)
   - contribution: number (actual score contributed)

4. ConfidenceResult interface:
   - category: SemanticCategory
   - confidence: number (0.0-1.0)
   - level: ConfidenceLevel
   - signals: SignalMatch[]

5. NamePattern interface:
   - regex: RegExp
   - weight: number
   - languages: string[] (e.g., ['en', 'es', 'fr', 'de'])

6. TypeConstraint interface:
   - allowed: string[] (field type names like 'string', 'number', 'array')
   - weight: number

7. ValueValidator interface:
   - name: string (for debugging)
   - validator: (value: unknown) => boolean
   - weight: number

8. FormatHint interface:
   - format: string (OpenAPI format)
   - weight: number

9. SemanticPattern interface:
   - category: SemanticCategory
   - namePatterns: NamePattern[]
   - typeConstraint: TypeConstraint
   - valueValidators: ValueValidator[]
   - formatHints: FormatHint[]
   - thresholds: { high: number; medium: number }

   **IMPORTANT (user decision from CONTEXT.md):** Default thresholds are { high: 0.75, medium: 0.50 }.
   The user chose 75% as the aggressive threshold for applying smart defaults (HIGH confidence).
   This is MORE aggressive than the original 90% in the roadmap. >= 0.75 = HIGH (apply smart default),
   >= 0.50 = MEDIUM (consider but not auto-apply), < 0.50 = LOW/NONE.

10. CompositePattern interface (extends SemanticPattern):
    - requiredFields: Array<{ nameRegex: RegExp; type: string }>
    - minItems: number (default 1)

Export all types. Use JSDoc comments for documentation.
  </action>
  <verify>
    - File exists at src/services/semantic/types.ts
    - `npx tsc --noEmit` passes
    - All types exported
    - Default thresholds are { high: 0.75, medium: 0.50 }
  </verify>
  <done>Type system for semantic detection defined and type-checks</done>
</task>

<task type="auto">
  <name>Task 2: Implement confidence scoring algorithm</name>
  <files>src/services/semantic/scorer.ts, src/services/semantic/cache.ts</files>
  <action>
Create `src/services/semantic/scorer.ts`:

1. Import types from ./types.ts

2. calculateConfidence function:
   ```typescript
   export function calculateConfidence(
     fieldName: string,
     fieldType: string,
     sampleValues: unknown[],
     openapiHints: { format?: string; description?: string } | undefined,
     pattern: SemanticPattern
   ): ConfidenceResult
   ```

3. Algorithm:
   - For each namePattern: test against fieldName, take best match weight (not sum)
   - Check typeConstraint: if fieldType in allowed, add weight
   - For each valueValidator: test against at least one sampleValue, add weight if any match
   - For each formatHint: if openapiHints.format matches, add weight
   - Calculate confidence = totalScore / maxPossibleScore
   - Determine level based on thresholds:
     **IMPORTANT:** high >= 0.75 (per user decision), medium >= 0.50, low > 0, none = 0
     This means >= 75% confidence triggers smart default application.

4. For name patterns with multiple languages, only count best match (don't sum all language matches)

Create `src/services/semantic/cache.ts`:

1. createMemoizedDetector function that wraps a detection function with memoization
2. Cache key: JSON.stringify({ fieldPath, fieldName, fieldType, sampleValues: first 3 values, openapiHints })
3. Use simple Map<string, ConfidenceResult[]> for cache
4. Include cache.clear() method for testing
5. Export DetectionCache type for the cache interface

Export both functions. Add JSDoc documentation.
  </action>
  <verify>
    - Files exist at src/services/semantic/scorer.ts and cache.ts
    - `npx tsc --noEmit` passes
    - Imports resolve correctly
    - Scorer uses 0.75 threshold for HIGH confidence level
  </verify>
  <done>Confidence scoring algorithm and memoization cache implemented</done>
</task>

<task type="auto">
  <name>Task 3: Extend FieldDefinition with semantics field</name>
  <files>src/types/schema.ts</files>
  <action>
Update `src/types/schema.ts`:

1. To avoid circular dependency, define the semantic metadata type inline in schema.ts:

2. Add SemanticMetadata interface:
   ```typescript
   export interface SemanticMetadata {
     detectedCategory: string | null
     confidence: number
     level: 'high' | 'medium' | 'low' | 'none'
     appliedAt: 'user' | 'smart-default' | 'type-based'
     alternatives: Array<{ category: string; confidence: number }>
   }
   ```

3. Extend FieldDefinition interface with optional semantics field:
   ```typescript
   export interface FieldDefinition {
     name: string
     type: TypeSignature
     optional: boolean
     nullable: boolean
     confidence: Confidence
     sampleValues: unknown[]
     semantics?: SemanticMetadata  // NEW
   }
   ```

Keep existing types unchanged. This is additive only - no breaking changes.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - FieldDefinition has optional semantics field
    - No breaking changes to existing code
  </verify>
  <done>FieldDefinition extended with semantic metadata support</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - all files type-check
2. Imports resolve: scorer.ts imports from types.ts
3. schema.ts has SemanticMetadata and updated FieldDefinition
4. No circular dependencies
5. Thresholds: high >= 0.75, medium >= 0.50 (per user's aggressive detection decision)
</verification>

<success_criteria>
- 3 new files created (types.ts, scorer.ts, cache.ts) + 1 modified (schema.ts)
- Type system supports multi-signal pattern definitions
- Confidence scorer produces weighted scores with level classification
- HIGH confidence threshold is 0.75 (not 0.90) per user decision
- FieldDefinition ready to store semantic detection results
</success_criteria>

<output>
After completion, create `.planning/phases/12-core-semantic-detection/12-01-SUMMARY.md`
</output>
