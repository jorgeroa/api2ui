---
phase: 02-advanced-rendering-openapi
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/services/openapi/parser.ts
  - src/services/openapi/types.ts
  - src/services/openapi/__tests__/parser.test.ts
autonomous: true

must_haves:
  truths:
    - "OpenAPI 3.0 spec URL can be parsed and dereferenced to extract GET operations"
    - "Swagger 2.0 spec URL can be parsed and dereferenced to extract GET operations"
    - "Each extracted operation includes path, method, summary, parameters, and response schema"
    - "Parameters are separated into required and optional groups"
    - "CORS errors during spec fetch produce a clear error message"
  artifacts:
    - path: "src/services/openapi/parser.ts"
      provides: "parseOpenAPISpec function that parses and extracts operations"
      exports: ["parseOpenAPISpec"]
      min_lines: 40
    - path: "src/services/openapi/types.ts"
      provides: "TypeScript types for parsed OpenAPI operations and parameters"
      exports: ["ParsedSpec", "ParsedOperation", "ParsedParameter"]
      min_lines: 20
    - path: "src/services/openapi/__tests__/parser.test.ts"
      provides: "Tests for OpenAPI parsing with fixtures"
      min_lines: 50
  key_links:
    - from: "src/services/openapi/parser.ts"
      to: "@apidevtools/swagger-parser"
      via: "SwaggerParser.dereference() for $ref resolution"
      pattern: "SwaggerParser"
    - from: "src/services/openapi/parser.ts"
      to: "src/services/openapi/types.ts"
      via: "Returns ParsedSpec type"
      pattern: "ParsedSpec"
---

<objective>
Build OpenAPI/Swagger spec parsing service with TDD.

Purpose: Parse OpenAPI/Swagger spec URLs to extract GET operations with their parameters and response schemas. This is the data layer for ENG-02 (OpenAPI spec support) and RND-05 (parameter forms). The parser converts raw OpenAPI specs into a clean, typed data structure the UI layer can consume.

Output: Tested parser service, typed interfaces for parsed specs/operations/parameters.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/services/api/fetcher.ts
@src/types/schema.ts
</context>

<feature>
  <name>OpenAPI Spec Parser</name>
  <files>
    src/services/openapi/parser.ts
    src/services/openapi/types.ts
    src/services/openapi/__tests__/parser.test.ts
  </files>
  <behavior>
    The parser takes a spec URL or spec object and returns a structured `ParsedSpec`:

    **Types (src/services/openapi/types.ts):**
    ```typescript
    export interface ParsedParameter {
      name: string
      in: 'query' | 'path' | 'header' | 'cookie'
      required: boolean
      description: string
      schema: {
        type: string          // 'string' | 'integer' | 'number' | 'boolean' | 'array'
        format?: string       // 'date', 'date-time', 'email', 'uri', 'password', etc.
        enum?: unknown[]      // For select inputs
        default?: unknown     // Default value
        minimum?: number
        maximum?: number
        maxLength?: number
      }
    }

    export interface ParsedOperation {
      path: string            // e.g., '/users', '/users/{userId}'
      method: string          // 'GET' (v1 only extracts GET)
      operationId?: string
      summary?: string
      description?: string
      parameters: ParsedParameter[]
      responseSchema: unknown // The dereferenced response schema (JSON Schema)
      tags: string[]
    }

    export interface ParsedSpec {
      title: string
      version: string
      specVersion: string    // '2.0', '3.0.x', '3.1.x'
      baseUrl: string        // Server URL or host+basePath
      operations: ParsedOperation[]
    }
    ```

    **Test cases:**

    1. `parseOpenAPISpec(openapi3Fixture)` → returns ParsedSpec with correct title, version, specVersion='3.0.x'
    2. `parseOpenAPISpec(swagger2Fixture)` → returns ParsedSpec with specVersion='2.0'
    3. Operations extraction: spec with 3 GET + 2 POST → returns only 3 GET operations
    4. Parameter extraction: operation with 2 required + 1 optional query params → all 3 in parameters array with correct required flag
    5. Path parameter detection: `/users/{userId}` → parameter with `in: 'path'`, `required: true`
    6. Enum parameter: param with enum values → `schema.enum` populated
    7. Base URL extraction: OpenAPI 3.x `servers[0].url` → baseUrl; Swagger 2.0 `host + basePath` → baseUrl
    8. Empty spec (no paths): returns empty operations array, does not throw
    9. Error handling: invalid spec → throws descriptive error

    **Fixtures:** Create inline test fixtures (small OpenAPI 3.0 and Swagger 2.0 spec objects) rather than external files. Keep them minimal — just enough paths/operations to test extraction logic.

    Use `vi.mock('@apidevtools/swagger-parser')` to mock the parser in unit tests. The mock returns the fixture directly (simulating successful dereference). This avoids network calls and tests our extraction logic, not the library.
  </behavior>
  <implementation>
    1. Run `npm install @apidevtools/swagger-parser` to add the parser library. Also install `openapi-types` for TypeScript types: `npm install -D openapi-types`.

    2. Create `src/services/openapi/types.ts` with the interfaces above.

    3. Create `src/services/openapi/parser.ts`:
       - Import `SwaggerParser` from `@apidevtools/swagger-parser`.
       - Import types from `openapi-types` for internal type assertions.
       - Export async function `parseOpenAPISpec(specUrlOrObject: string | object): Promise<ParsedSpec>`.
       - Call `SwaggerParser.dereference(specUrlOrObject)` to parse and resolve all $refs.
       - Detect spec version: check `api.openapi` (3.x) vs `api.swagger` (2.0).
       - Extract base URL: For 3.x use `api.servers?.[0]?.url ?? ''`. For 2.0 use `(api.schemes?.[0] ?? 'https') + '://' + api.host + (api.basePath ?? '')`.
       - Iterate `api.paths`, for each path item extract only `.get` operations.
       - For each GET operation: extract `operationId`, `summary`, `description`, `tags`, `parameters` (from both path-level and operation-level params, merged with operation taking precedence).
       - Map each parameter to `ParsedParameter` format — extract `name`, `in`, `required` (default false unless in=path), `description`, and schema fields.
       - Extract response schema from `responses['200']?.content?.['application/json']?.schema` (3.x) or `responses['200']?.schema` (2.0).
       - Wrap in try/catch: catch parser errors and rethrow with descriptive message including spec URL.

    4. Tests follow RED-GREEN-REFACTOR:
       - RED: Write all test cases with fixture data, mock SwaggerParser.dereference.
       - GREEN: Implement parser to pass all tests.
       - REFACTOR: Clean up any duplication in extraction logic.
  </implementation>
</feature>

<verification>
1. `npm run test:run -- src/services/openapi` — all tests pass
2. `npx tsc --noEmit` — no type errors
3. Tests cover: OpenAPI 3.0 parsing, Swagger 2.0 parsing, GET-only extraction, parameter grouping, enum params, path params, base URL extraction, empty spec, error handling
</verification>

<success_criteria>
- parseOpenAPISpec correctly parses OpenAPI 3.x and Swagger 2.0 specs
- Only GET operations are extracted (read-only v1)
- Parameters include type, format, enum, required flag
- Base URL correctly computed for both spec versions
- All tests pass with mocked parser
</success_criteria>

<output>
After completion, create `.planning/phases/02-advanced-rendering-openapi/02-02-SUMMARY.md`
</output>
