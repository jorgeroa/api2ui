---
phase: 02-advanced-rendering-openapi
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/components/forms/ParameterForm.tsx
  - src/components/forms/ParameterInput.tsx
  - src/store/appStore.ts
  - src/hooks/useAPIFetch.ts
  - src/App.tsx
  - src/components/openapi/OperationSelector.tsx
autonomous: true

must_haves:
  truths:
    - "User can paste an OpenAPI spec URL and see endpoint data rendered"
    - "Required API parameters render as prominent form inputs"
    - "Optional API parameters are in a collapsible section"
    - "User can select which GET operation to view from the parsed spec"
    - "Submitting parameter form fetches the API with those parameters and renders result"
  artifacts:
    - path: "src/components/forms/ParameterForm.tsx"
      provides: "Form that renders required params prominently and optional params in collapsible Disclosure"
      contains: "Disclosure"
      min_lines: 30
    - path: "src/components/forms/ParameterInput.tsx"
      provides: "Individual input component mapped from OpenAPI parameter schema"
      min_lines: 25
    - path: "src/store/appStore.ts"
      provides: "Extended store with OpenAPI spec state, selected operation, parameter values"
      contains: "parsedSpec"
    - path: "src/components/openapi/OperationSelector.tsx"
      provides: "Dropdown or list for selecting GET operation from parsed spec"
      min_lines: 15
    - path: "src/App.tsx"
      provides: "Wired app shell that detects spec URLs, shows operation selector and parameter form"
      contains: "ParameterForm"
  key_links:
    - from: "src/hooks/useAPIFetch.ts"
      to: "src/services/openapi/parser.ts"
      via: "Calls parseOpenAPISpec when URL looks like an OpenAPI spec"
      pattern: "parseOpenAPISpec"
    - from: "src/components/forms/ParameterForm.tsx"
      to: "src/services/openapi/types.ts"
      via: "Consumes ParsedParameter[] to render form controls"
      pattern: "ParsedParameter"
    - from: "src/App.tsx"
      to: "src/components/openapi/OperationSelector.tsx"
      via: "Shows operation selector when parsedSpec exists in store"
      pattern: "OperationSelector"
    - from: "src/components/forms/ParameterForm.tsx"
      to: "src/hooks/useAPIFetch.ts"
      via: "Submitting form triggers fetch with parameter values"
      pattern: "fetchAndInfer"
---

<objective>
Build parameter forms, extend store with OpenAPI state, and wire the full OpenAPI flow into the app shell.

Purpose: Complete the OpenAPI integration by connecting parser (Plan 02) output to parameter form UI and data rendering. Users can paste an OpenAPI spec URL, select a GET operation, fill in parameters, and see the response rendered. This addresses ENG-02 (OpenAPI spec support) and RND-05 (parameter form controls).

Output: ParameterForm/ParameterInput components, OperationSelector, extended Zustand store, wired useAPIFetch hook, updated App.tsx.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/02-advanced-rendering-openapi/02-01-SUMMARY.md
@.planning/phases/02-advanced-rendering-openapi/02-02-SUMMARY.md

@src/store/appStore.ts
@src/hooks/useAPIFetch.ts
@src/App.tsx
@src/services/openapi/types.ts
@src/services/openapi/parser.ts
@src/components/detail/DetailModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build ParameterInput, ParameterForm, and OperationSelector components</name>
  <files>
    src/components/forms/ParameterInput.tsx
    src/components/forms/ParameterForm.tsx
    src/components/openapi/OperationSelector.tsx
  </files>
  <action>
    **ParameterInput (src/components/forms/ParameterInput.tsx):**
    - Props: `parameter: ParsedParameter`, `value: string`, `onChange: (value: string) => void`.
    - Map parameter schema to HTML input type:
      - `schema.enum` → `<select>` with options
      - `schema.type === 'integer' | 'number'` → `<input type="number">` with min/max from schema
      - `schema.type === 'boolean'` → `<input type="checkbox">`
      - `schema.format === 'date' | 'date-time'` → `<input type="date">` or `datetime-local`
      - `schema.format === 'email'` → `<input type="email">`
      - `schema.format === 'uri'` → `<input type="url">`
      - Default → `<input type="text">`
    - Each input wrapped with label showing `parameter.name`, required indicator (`*` in red if required), and description text if available.
    - Use Tailwind classes: `w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500`.
    - Show `schema.default` as placeholder if present.

    **ParameterForm (src/components/forms/ParameterForm.tsx):**
    - Props: `parameters: ParsedParameter[]`, `onSubmit: (values: Record<string, string>) => void`, `loading?: boolean`.
    - Internal state: `Record<string, string>` for parameter values (keyed by param name).
    - Split parameters into `required = parameters.filter(p => p.required)` and `optional = parameters.filter(p => !p.required)`.
    - Only show query and path parameters (filter out `in: 'header'` and `in: 'cookie'`).
    - Render required params in a visible section with heading "Required Parameters" (or omit heading if no required params).
    - Render optional params inside a Headless UI `Disclosure`:
      - DisclosureButton: `+ {optional.length} Optional Parameters` with chevron icon.
      - DisclosurePanel: renders ParameterInput for each optional param.
    - Submit button: "Fetch Data" with loading state (disabled + spinner when loading).
    - On submit: call `onSubmit(values)` with the current parameter values.

    **OperationSelector (src/components/openapi/OperationSelector.tsx):**
    - Props: `operations: ParsedOperation[]`, `selectedIndex: number`, `onSelect: (index: number) => void`.
    - If only 1 operation, render as static text (no selector needed): display method badge + path + summary.
    - If multiple operations, render as a `<select>` dropdown:
      - Each option: `GET /path — summary` format.
    - Style: method badge (`GET` in green), path in monospace.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors. All three components compile cleanly.
  </verify>
  <done>
    ParameterInput maps OpenAPI param schemas to correct HTML input types. ParameterForm renders required params prominently with optional params in collapsible Disclosure. OperationSelector allows choosing between GET operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend store, hook, and App shell for OpenAPI flow</name>
  <files>
    src/store/appStore.ts
    src/hooks/useAPIFetch.ts
    src/App.tsx
  </files>
  <action>
    **Store (src/store/appStore.ts):**
    Add new state fields to AppState interface:
    ```typescript
    // OpenAPI state
    parsedSpec: ParsedSpec | null
    selectedOperationIndex: number
    parameterValues: Record<string, string>

    // OpenAPI actions
    specSuccess: (spec: ParsedSpec) => void
    setSelectedOperation: (index: number) => void
    setParameterValue: (name: string, value: string) => void
    clearParameters: () => void
    ```
    - Import `ParsedSpec` from `../services/openapi/types`.
    - `specSuccess`: sets `parsedSpec`, resets `selectedOperationIndex` to 0, clears `parameterValues`, clears loading.
    - `setSelectedOperation`: sets index and clears `parameterValues`.
    - `setParameterValue`: updates single param value in the record.
    - `clearParameters`: resets `parameterValues` to `{}`.
    - Update `reset` to also clear OpenAPI state.
    - Update `startFetch` to clear `parsedSpec` (fresh fetch clears old spec).

    **Hook (src/hooks/useAPIFetch.ts):**
    Add OpenAPI spec detection and fetching:
    - Import `parseOpenAPISpec` from `../services/openapi/parser`.
    - Import `specSuccess` from store.
    - Add heuristic to detect spec URLs: URL ends with `/openapi.json`, `/openapi.yaml`, `/swagger.json`, `/swagger.yaml`, `/api-docs`, `/v2/api-docs`, `/v3/api-docs`, or contains `swagger` or `openapi` in the path. Implementation: regex or simple string checks.
    - New function `fetchSpec(url: string)`: calls `parseOpenAPISpec(url)`, then `specSuccess(spec)`.
    - Update `fetchAndInfer`: if URL matches spec heuristic, call `fetchSpec` instead of `fetchAPI + inferSchema`.
    - New function `fetchOperation(baseUrl: string, operation: ParsedOperation, params: Record<string, string>)`:
      1. Build full URL: `baseUrl + operation.path`.
      2. Replace path parameters: for each param with `in: 'path'`, replace `{paramName}` in path with value.
      3. Append query parameters: for each param with `in: 'query'` that has a non-empty value, add to URLSearchParams.
      4. Call existing `fetchAPI(fullUrl)` to get data.
      5. Call `inferSchema(data, fullUrl)` and `fetchSuccess(data, schema)`.
    - Export `fetchSpec` and `fetchOperation` alongside `fetchAndInfer`.

    **App (src/App.tsx):**
    1. Import `OperationSelector`, `ParameterForm` from new components.
    2. Read new state from store: `parsedSpec`, `selectedOperationIndex`, `parameterValues`, `setSelectedOperation`, `setParameterValue`.
    3. Import `useAPIFetch` updated hook with `fetchOperation`.
    4. Derive `selectedOperation = parsedSpec?.operations[selectedOperationIndex]`.
    5. When `parsedSpec` is set (and data is null — haven't fetched yet):
       - Show spec title + version as a header badge.
       - Show `OperationSelector` if multiple operations.
       - Show `ParameterForm` with the selected operation's parameters.
       - ParameterForm's `onSubmit` calls `fetchOperation(parsedSpec.baseUrl, selectedOperation, values)`.
    6. When data is also set (after fetch): show ParameterForm collapsed/above the data, and DynamicRenderer below (existing rendering).
    7. Layout: spec info → operation selector → parameter form → data rendering. All within the existing white card container.
    8. Handle the case where spec has 0 GET operations: show friendly message "This API spec has no GET endpoints to display."
  </action>
  <verify>
    1. Run `npx tsc --noEmit` — no type errors.
    2. Run `npm run build` — build succeeds.
    3. Manual test: paste a direct API URL (e.g., `https://jsonplaceholder.typicode.com/users`) — existing flow works unchanged.
    4. Manual test: try an OpenAPI spec URL to verify the full flow (spec detection → parse → operation selector → parameter form → fetch → render). If a public spec is hard to find for testing, verify the code compiles and the heuristic correctly identifies spec URLs by inspecting behavior.
  </verify>
  <done>
    Store has OpenAPI state (parsedSpec, selectedOperation, parameterValues). Hook detects spec URLs and routes to parser. App shell shows operation selector and parameter form when spec is loaded. Submitting form fetches operation data and renders result. Direct API URLs still work via existing flow.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` succeeds
3. Direct API URL flow (paste URL → fetch → render) still works unchanged
4. Parameter form shows required params prominently with optional in collapsible section
5. OperationSelector appears when spec has multiple GET operations
6. Parameter form submit builds correct URL with path and query params
7. Enum parameters render as dropdown selects
8. Boolean parameters render as checkboxes
9. Store correctly tracks OpenAPI state across operation changes
</verification>

<success_criteria>
- Full OpenAPI flow: paste spec URL → detect → parse → show operations → fill params → fetch → render
- Direct API URL flow continues working unchanged
- Required params are prominent, optional params are collapsible
- Parameter types correctly mapped to input types
- Build passes, no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-advanced-rendering-openapi/02-03-SUMMARY.md`
</output>
