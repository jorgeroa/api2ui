# Phase 11: Rich Input Components & UX Polish - Research

**Researched:** 2026-02-07
**Domain:** React form components, shadcn/ui, date pickers, validation patterns
**Confidence:** HIGH

## Summary

This phase implements rich form input components using shadcn/ui as the component library foundation, paired with react-day-picker for date selection. The research confirms that shadcn/ui is the current industry standard for accessible, customizable React components built on Radix UI primitives and styled with Tailwind CSS. The phase requires integrating multiple interaction patterns: calendar/time pickers for datetime fields, tag inputs for array parameters, numeric sliders for bounded ranges, inline validation feedback, applied filter chips with sticky positioning, and hybrid re-fetch behavior balancing user control with quick actions.

Key findings indicate that shadcn/ui follows a "copy-paste" model where components are added to your project rather than installed as dependencies, providing full ownership and customization. React-day-picker v9 (latest: 9.13.1) is specifically a date picker without built-in time functionality, requiring separate time input integration. The hybrid re-fetch approach (text inputs need Apply button, selects/toggles/chips auto-fetch) is validated by form library best practices showing debounced onChange for quick interactions while preserving explicit submission for complex text entry.

**Primary recommendation:** Use shadcn/ui CLI to add Calendar, Popover, Input, Button, Badge, and Slider components. Build custom time picker integration with react-day-picker using separate `<input type="time">` elements. Implement tag input with Enter/comma delimiters using controlled input pattern. Use CSS `position: sticky` for filter chips bar. Leverage Sonner for toast notifications as it's the current shadcn/ui standard.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| shadcn/ui | Current (Feb 2026) | Component library foundation | Industry standard for accessible React components; copy-paste model provides full ownership; built on Radix UI + Tailwind CSS |
| react-day-picker | v9.13.1 (latest) | Date picker component | Official shadcn/ui Calendar component dependency; WAI-ARIA compliant; supports localization, timezones, multiple calendar systems |
| Radix UI | Unified package (2026) | Headless UI primitives | Foundation for shadcn/ui; handles ARIA attributes, focus management, keyboard navigation automatically |
| Sonner | Latest | Toast notifications | Recommended by shadcn/ui (replaced deprecated Toast component); TypeScript-first, React 18+ compatible |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| react-loading-skeleton | 3.5.0 (already installed) | Skeleton loaders | Already in project; can coexist with shadcn Skeleton for loading states |
| React Hook Form | 7.x or Formik 2.4.9 | Form validation library | Optional - if complex validation needed beyond inline blur validation |
| Zod | Latest | Schema validation | Optional - pairs with React Hook Form for type-safe validation |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| shadcn/ui | Material-UI (MUI) | MUI has built-in DateTimePicker but less customizable; heavier bundle size |
| react-day-picker | react-datepicker | react-datepicker has built-in time picker but less accessible; not shadcn/ui standard |
| CSS sticky | JavaScript scroll listeners | JavaScript approach causes jump/flicker; worse performance; sticky is native |
| Sonner | react-hot-toast | Both work well; Sonner is shadcn/ui recommendation for 2026 |

**Installation:**
```bash
# Initialize shadcn/ui (one-time setup)
npx shadcn@latest init

# Add specific components
npx shadcn@latest add calendar
npx shadcn@latest add popover
npx shadcn@latest add input
npx shadcn@latest add button
npx shadcn@latest add badge
npx shadcn@latest add slider
npx shadcn@latest add skeleton  # Optional - for replacing react-loading-skeleton
npx shadcn@latest add sonner

# Note: react-day-picker will be installed automatically with calendar component
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── components/
│   ├── ui/                    # shadcn/ui components (generated by CLI)
│   │   ├── calendar.tsx
│   │   ├── popover.tsx
│   │   ├── input.tsx
│   │   ├── button.tsx
│   │   ├── badge.tsx
│   │   ├── slider.tsx
│   │   └── sonner.tsx
│   ├── forms/
│   │   ├── DateTimePicker.tsx     # Popover + Calendar + time input
│   │   ├── TagInput.tsx           # Array parameter chip input
│   │   ├── RangeSlider.tsx        # Numeric slider with value display
│   │   ├── ParameterInput.tsx     # Enhanced with new components
│   │   └── AppliedFilters.tsx     # Sticky filter chips bar
│   └── ...
├── hooks/
│   ├── useCopyToClipboard.ts      # For URL preview copy
│   ├── useLocalStorage.ts         # For URL preview toggle persistence
│   └── useDebouncedPersist.ts     # Already exists
└── lib/
    └── utils.ts                   # cn() utility for shadcn/ui
```

### Pattern 1: Date + Time Picker Integration
**What:** Combine react-day-picker Calendar with separate time input, conditionally showing time based on schema
**When to use:** When parameter schema indicates `format: "date-time"` or inferred type is datetime
**Example:**
```typescript
// Source: https://daypicker.dev/guides/timepicker
import { useState } from 'react'
import { Calendar } from '@/components/ui/calendar'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'
import { Button } from '@/components/ui/button'

interface DateTimePickerProps {
  value: Date | undefined
  onChange: (date: Date | undefined) => void
  includeTime?: boolean  // Based on schema format
}

export function DateTimePicker({ value, onChange, includeTime = false }: DateTimePickerProps) {
  const [date, setDate] = useState<Date | undefined>(value)

  const handleDateSelect = (selectedDate: Date | undefined) => {
    if (!selectedDate) {
      setDate(undefined)
      onChange(undefined)
      return
    }

    if (includeTime && date) {
      // Preserve existing time when changing date
      selectedDate.setHours(date.getHours())
      selectedDate.setMinutes(date.getMinutes())
    }

    setDate(selectedDate)
    onChange(selectedDate)
  }

  const handleTimeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!date) return

    const [hours, minutes] = e.target.value.split(':').map(Number)
    const newDate = new Date(date)
    newDate.setHours(hours, minutes)

    setDate(newDate)
    onChange(newDate)
  }

  return (
    <div className="space-y-2">
      <Popover>
        <PopoverTrigger asChild>
          <Button variant="outline" className="w-full justify-start text-left">
            {date ? date.toLocaleDateString() : 'Pick a date'}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0" align="start">
          <Calendar
            mode="single"
            selected={date}
            onSelect={handleDateSelect}
            timeZone={Intl.DateTimeFormat().resolvedOptions().timeZone}
          />
        </PopoverContent>
      </Popover>

      {includeTime && (
        <input
          type="time"
          value={date ? `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}` : ''}
          onChange={handleTimeChange}
          className="w-full px-3 py-2 border rounded-md"
        />
      )}
    </div>
  )
}
```

### Pattern 2: Tag Input with Enter/Comma Delimiters
**What:** Controlled input that converts text to chips on Enter or comma, with duplicate detection
**When to use:** When parameter schema type is `array` or maxItems exists
**Example:**
```typescript
// Pattern source: community best practices 2026
import { useState, KeyboardEvent } from 'react'
import { Badge } from '@/components/ui/badge'
import { Input } from '@/components/ui/input'

interface TagInputProps {
  value: string[]
  onChange: (tags: string[]) => void
  maxItems?: number
  placeholder?: string
}

export function TagInput({ value, onChange, maxItems, placeholder }: TagInputProps) {
  const [inputValue, setInputValue] = useState('')
  const [error, setError] = useState<string | null>(null)

  const addTag = (tag: string) => {
    const trimmed = tag.trim()
    if (!trimmed) return

    // Check for duplicate
    if (value.includes(trimmed)) {
      setError('Duplicate tag')
      setTimeout(() => setError(null), 2000)
      return
    }

    // Check maxItems
    if (maxItems && value.length >= maxItems) {
      setError(`Maximum ${maxItems} tags allowed`)
      setTimeout(() => setError(null), 2000)
      return
    }

    onChange([...value, trimmed])
    setInputValue('')
  }

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' || e.key === ',') {
      e.preventDefault()
      addTag(inputValue)
    }
  }

  const removeTag = (index: number) => {
    onChange(value.filter((_, i) => i !== index))
  }

  return (
    <div>
      <div className="flex flex-wrap gap-2 mb-2">
        {value.map((tag, index) => (
          <Badge key={index} variant="secondary">
            {tag}
            <button
              type="button"
              onClick={() => removeTag(index)}
              className="ml-1 hover:text-destructive"
            >
              ×
            </button>
          </Badge>
        ))}
      </div>
      <Input
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder={placeholder ?? 'Type and press Enter or comma'}
      />
      {error && (
        <p className="text-sm text-destructive mt-1">{error}</p>
      )}
    </div>
  )
}
```

### Pattern 3: Numeric Slider with Value Display
**What:** Slider component with current value label shown above track
**When to use:** Only when min/max explicitly known from OpenAPI schema or type inference
**Example:**
```typescript
// Source: https://ui.shadcn.com/docs/components/radix/slider
import { Slider } from '@/components/ui/slider'

interface RangeSliderProps {
  value: number
  onChange: (value: number) => void
  min: number
  max: number
  step?: number
  label: string
}

export function RangeSlider({ value, onChange, min, max, step = 1, label }: RangeSliderProps) {
  return (
    <div className="space-y-2">
      <div className="flex justify-between items-center">
        <label className="text-sm font-medium">{label}</label>
        <span className="text-sm text-muted-foreground">{value}</span>
      </div>
      <Slider
        value={[value]}
        onValueChange={([newValue]) => onChange(newValue)}
        min={min}
        max={max}
        step={step}
      />
      <div className="flex justify-between text-xs text-muted-foreground">
        <span>{min}</span>
        <span>{max}</span>
      </div>
    </div>
  )
}
```

### Pattern 4: Applied Filter Chips (Sticky Bar)
**What:** Sticky positioned bar showing active filters as removable chips
**When to use:** When user has applied any parameter values
**Example:**
```typescript
// Source: CSS sticky best practices 2026
import { Badge } from '@/components/ui/badge'

interface AppliedFiltersProps {
  filters: Record<string, string>
  onRemove: (key: string) => void
  onClearAll: () => void
}

export function AppliedFilters({ filters, onRemove, onClearAll }: AppliedFiltersProps) {
  const entries = Object.entries(filters).filter(([_, value]) => value !== '')

  if (entries.length === 0) return null

  return (
    <div className="sticky top-0 z-10 bg-background border-b border-border py-2 px-4 flex items-center gap-2 flex-wrap">
      <span className="text-sm font-medium text-muted-foreground">Filters:</span>
      {entries.map(([key, value]) => (
        <Badge key={key} variant="secondary">
          {key}: {value}
          <button
            type="button"
            onClick={() => onRemove(key)}
            className="ml-1 hover:text-destructive"
          >
            ×
          </button>
        </Badge>
      ))}
      <button
        type="button"
        onClick={onClearAll}
        className="ml-auto text-sm text-muted-foreground hover:text-foreground"
      >
        Clear all
      </button>
    </div>
  )
}
```

### Pattern 5: Inline Validation on Blur
**What:** Validation triggered on blur event, not onChange, using field-level state
**When to use:** All form inputs except select/toggle (which don't need blur validation)
**Example:**
```typescript
// Source: https://thelinuxcode.com/react-form-validation-with-formik-and-yup-2026-edition/
import { useState } from 'react'
import { Input } from '@/components/ui/input'

interface ValidatedInputProps {
  value: string
  onChange: (value: string) => void
  validate?: (value: string) => string | null
  label: string
  required?: boolean
}

export function ValidatedInput({ value, onChange, validate, label, required }: ValidatedInputProps) {
  const [error, setError] = useState<string | null>(null)
  const [touched, setTouched] = useState(false)

  const handleBlur = () => {
    setTouched(true)
    if (validate) {
      const validationError = validate(value)
      setError(validationError)
    }
  }

  const handleChange = (newValue: string) => {
    onChange(newValue)
    // Clear error on change if previously touched
    if (touched && error) {
      setError(null)
    }
  }

  return (
    <div>
      <label className="text-sm font-medium">
        {label}
        {required && <span className="text-destructive ml-1">*</span>}
      </label>
      <Input
        value={value}
        onChange={(e) => handleChange(e.target.value)}
        onBlur={handleBlur}
        aria-invalid={!!error}
        className={error ? 'border-destructive' : ''}
      />
      {error && (
        <p className="text-sm text-destructive mt-1">{error}</p>
      )}
    </div>
  )
}
```

### Pattern 6: Hybrid Re-fetch with Debounce
**What:** Text inputs require Apply button; selects/toggles/chip removals auto-fetch with debounce
**When to use:** Form submission behavior throughout the application
**Example:**
```typescript
// Source: https://darius-marlowe.medium.com/smarter-forms-in-react-building-a-useautosave-hook-with-debounce-and-react-query-d4d7f9bb052e
import { useEffect, useRef } from 'react'

function useDebounce(callback: () => void, delay: number, deps: any[]) {
  const timeoutRef = useRef<NodeJS.Timeout>()

  useEffect(() => {
    // Clear existing timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }

    // Set new timeout
    timeoutRef.current = setTimeout(callback, delay)

    // Cleanup on unmount
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps)
}

// Usage in form
function ParameterForm() {
  const [textValues, setTextValues] = useState({})
  const [quickValues, setQuickValues] = useState({})  // selects, toggles, etc.

  // Manual submit for text inputs
  const handleSubmit = () => {
    fetchData({ ...textValues, ...quickValues })
  }

  // Auto-fetch for quick inputs (debounced 300ms)
  useDebounce(
    () => {
      fetchData({ ...textValues, ...quickValues })
    },
    300,
    [quickValues]
  )

  return (
    <form onSubmit={(e) => { e.preventDefault(); handleSubmit() }}>
      {/* Text inputs - no auto-fetch */}
      <Input value={textValues.search} onChange={(e) => setTextValues(prev => ({ ...prev, search: e.target.value }))} />

      {/* Select - auto-fetch */}
      <select value={quickValues.status} onChange={(e) => setQuickValues(prev => ({ ...prev, status: e.target.value }))}>
        {/* options */}
      </select>

      <button type="submit">Apply</button>
    </form>
  )
}
```

### Pattern 7: URL Preview with Copy and LocalStorage Persistence
**What:** Toggle to show/hide URL preview with copy button, state persists in localStorage
**When to use:** Below parameter form to show constructed request URL
**Example:**
```typescript
// Source: https://usehooks.com/uselocalstorage
import { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'

function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      return initialValue
    }
  })

  const setValue = (value: T) => {
    try {
      setStoredValue(value)
      window.localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.error('Error saving to localStorage', error)
    }
  }

  return [storedValue, setValue]
}

function useCopyToClipboard() {
  const [isCopied, setIsCopied] = useState(false)

  const copy = async (text: string) => {
    try {
      await navigator.clipboard.writeText(text)
      setIsCopied(true)
      setTimeout(() => setIsCopied(false), 2000)
    } catch (error) {
      console.error('Failed to copy', error)
    }
  }

  return { copy, isCopied }
}

interface URLPreviewProps {
  url: string
}

export function URLPreview({ url }: URLPreviewProps) {
  const [showPreview, setShowPreview] = useLocalStorage('url-preview-visible', false)
  const { copy, isCopied } = useCopyToClipboard()

  const truncatedUrl = url.length > 80 ? url.slice(0, 77) + '...' : url

  return (
    <div className="border-t pt-4">
      <button
        type="button"
        onClick={() => setShowPreview(!showPreview)}
        className="text-sm text-muted-foreground hover:text-foreground"
      >
        {showPreview ? 'Hide' : 'Show'} URL Preview
      </button>

      {showPreview && (
        <div className="mt-2 p-3 bg-muted rounded-md flex items-center gap-2">
          <code className="text-xs flex-1 overflow-hidden">{truncatedUrl}</code>
          <Button
            size="sm"
            variant="outline"
            onClick={() => copy(url)}
          >
            {isCopied ? 'Copied!' : 'Copy'}
          </Button>
        </div>
      )}
    </div>
  )
}
```

### Anti-Patterns to Avoid
- **Don't manually manage ARIA attributes**: Radix UI primitives handle this automatically. Adding redundant ARIA can break accessibility.
- **Don't use uncontrolled inputs for complex forms**: Controlled components are predictable and enable validation. Only use uncontrolled for simple cases.
- **Don't debounce text inputs too aggressively**: 300ms is safe; under 200ms feels laggy on keystroke. Over 500ms feels unresponsive.
- **Don't use JavaScript scroll listeners for sticky positioning**: CSS `position: sticky` is native, performs better, and prevents layout jump.
- **Don't ignore async validation race conditions**: Always use counter-based or latest-only pattern to prevent stale validation results overwriting fresh input.
- **Don't guess slider min/max values**: Only show slider when bounds are explicit in schema. Guessing leads to poor UX and incorrect values.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Date picker accessibility | Custom calendar with keyboard nav | react-day-picker via shadcn Calendar | WAI-ARIA compliant out of box; handles timezone, localization, multiple calendar systems; thoroughly tested |
| Toast notifications | Custom notification queue | Sonner | Handles positioning, stacking, animations, accessibility; TypeScript-first; non-blocking interface |
| Copy to clipboard | Custom execCommand fallback logic | Navigator.clipboard API with hook | Modern API with automatic fallback; community hooks handle edge cases |
| Form validation timing | Manual blur/focus state tracking | Formik or React Hook Form | Prevents race conditions; handles async validation; standardized patterns |
| Sticky positioning | Intersection Observer + state | CSS `position: sticky` | Native browser behavior; zero JavaScript overhead; no layout flicker |
| Skeleton loaders | DIV soup with manual sizing | react-loading-skeleton or shadcn Skeleton | Automatically matches content size; handles animations; accessible |
| Popover positioning | Manual coordinate calculation | Radix UI Popover (via shadcn) | Handles viewport bounds, collision detection, portal rendering, focus trapping |

**Key insight:** Form interactions involve subtle accessibility requirements (focus management, ARIA attributes, keyboard navigation) and edge cases (async validation races, timezone handling, cursor position bugs) that take years to polish. Use battle-tested libraries built on Radix UI primitives rather than reinventing fundamentals.

## Common Pitfalls

### Pitfall 1: Async Validation Race Conditions
**What goes wrong:** Older async validation results overwrite newer input, causing stale error messages or incorrect validation state.
**Why it happens:** When user types quickly, multiple validation requests fire. If slower request resolves after faster one, stale result wins.
**How to avoid:** Implement counter-based pattern tracking validation invocation number, only apply results from latest invocation.
**Warning signs:** Validation errors that flicker or appear after field is already valid; error state reverting unexpectedly.

### Pitfall 2: Controlled vs Uncontrolled Component Confusion
**What goes wrong:** Input value gets stuck, cursor jumps, or onChange doesn't fire. React warns "component is changing from uncontrolled to controlled."
**Why it happens:** Mixing `value={undefined}` (uncontrolled) with `value={string}` (controlled), or missing onChange handler.
**How to avoid:** Always use `value={string ?? ''}` for controlled inputs. Never conditionally switch between controlled and uncontrolled.
**Warning signs:** React console warnings; input that can't be edited; cursor jumping to end on every keystroke.

### Pitfall 3: Time Picker State Desync
**What goes wrong:** Changing date resets time to midnight, or time changes don't persist when date changes.
**Why it happens:** Date and time are managed in separate state, and date selection creates new Date object without preserving time.
**How to avoid:** When date changes, merge existing hours/minutes into new date. When time changes, clone existing date before modifying.
**Warning signs:** Time input resets unexpectedly; datetime values always have 00:00 time component.

### Pitfall 4: Sticky Positioning Not Working
**What goes wrong:** Filter chips bar doesn't stick; stays in normal flow or doesn't appear at top when scrolling.
**Why it happens:** Sticky positioning requires: (1) `top/bottom` value set, (2) overflow container in parent hierarchy, (3) sufficient height to scroll.
**How to avoid:** Set `position: sticky; top: 0; z-index: 10` on bar itself. Ensure parent containers don't have `overflow: hidden`.
**Warning signs:** Element doesn't stick even with sticky class; works in isolation but not in layout.

### Pitfall 5: Over-eager Debounce Clearing User Input
**What goes wrong:** User types quickly, but only first few characters trigger fetch; later input ignored or lost.
**Why it happens:** Debounce delay too long (>500ms) combined with clearing input on submit creates timing window where input disappears.
**How to avoid:** Use 300ms debounce for auto-fetch. Never clear input value on fetch; only update loading state.
**Warning signs:** Input value disappearing mid-typing; fetches triggered with incomplete search terms.

### Pitfall 6: Tag Input Duplicate Detection Case Sensitivity
**What goes wrong:** User can add "React", "react", "REACT" as separate tags when they're logically duplicates.
**Why it happens:** Duplicate check uses strict equality without normalization.
**How to avoid:** Normalize tags to lowercase before duplicate check: `value.map(t => t.toLowerCase()).includes(trimmed.toLowerCase())`.
**Warning signs:** Visually identical tags appearing multiple times with different casing.

### Pitfall 7: LocalStorage SSR Hydration Mismatch
**What goes wrong:** If using Next.js or SSR framework, localStorage access on initial render causes hydration errors.
**Why it happens:** localStorage doesn't exist on server; initial server render differs from client hydration.
**How to avoid:** Use lazy initialization function in useState, wrap localStorage access in `typeof window !== 'undefined'` check.
**Warning signs:** Hydration mismatch warnings; localStorage features broken on first load.

### Pitfall 8: Missing Timezone in Date Serialization
**What goes wrong:** Date selected in one timezone gets interpreted as different date when sent to API or displayed later.
**Why it happens:** Date objects serialize to ISO strings without timezone awareness; API might interpret as UTC while user expects local time.
**How to avoid:** Pass `timeZone` prop to Calendar component using `Intl.DateTimeFormat().resolvedOptions().timeZone`. Serialize to ISO with explicit timezone or UTC timestamp.
**Warning signs:** Dates off by one day in some timezones; datetime values shifting during serialization round-trip.

## Code Examples

Verified patterns from official sources:

### shadcn/ui Component Installation
```bash
# Source: https://ui.shadcn.com/docs/installation
# One-time initialization (if not already done)
npx shadcn@latest init

# During init, configure:
# - TypeScript: Yes
# - Style: Default
# - Base color: Slate (or preference)
# - CSS variables: Yes
# - Tailwind config: Yes (tailwind.config.ts)
# - Components path: @/components/ui
# - Utils path: @/lib/utils
# - React Server Components: No (using Vite, not Next.js)

# Add individual components
npx shadcn@latest add calendar popover input button badge slider sonner
```

### Calendar Component with Timezone Awareness
```typescript
// Source: https://ui.shadcn.com/docs/components/calendar
import { Calendar } from "@/components/ui/calendar"
import { useState } from "react"

export function DatePickerExample() {
  const [date, setDate] = useState<Date | undefined>(new Date())

  return (
    <Calendar
      mode="single"
      selected={date}
      onSelect={setDate}
      timeZone={Intl.DateTimeFormat().resolvedOptions().timeZone}
      className="rounded-lg border"
    />
  )
}
```

### Popover with Calendar Integration
```typescript
// Source: https://ui.shadcn.com/docs/components/popover
import { format } from "date-fns"
import { Calendar } from "@/components/ui/calendar"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
import { Button } from "@/components/ui/button"

export function DatePickerPopover() {
  const [date, setDate] = useState<Date>()

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          className="w-[280px] justify-start text-left font-normal"
        >
          {date ? format(date, "PPP") : <span>Pick a date</span>}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <Calendar
          mode="single"
          selected={date}
          onSelect={setDate}
          initialFocus
        />
      </PopoverContent>
    </Popover>
  )
}
```

### Slider with Min/Max from OpenAPI Schema
```typescript
// Source: https://ui.shadcn.com/docs/components/radix/slider
import { Slider } from "@/components/ui/slider"
import type { ParsedParameter } from "@/types"

interface NumericSliderProps {
  parameter: ParsedParameter
  value: number
  onChange: (value: number) => void
}

export function NumericSlider({ parameter, value, onChange }: NumericSliderProps) {
  const min = parameter.schema.minimum
  const max = parameter.schema.maximum

  // Only render slider if explicit bounds exist
  if (min === undefined || max === undefined) {
    return null
  }

  return (
    <div className="space-y-2">
      <div className="flex justify-between">
        <label className="text-sm font-medium">{parameter.name}</label>
        <span className="text-sm text-muted-foreground">{value}</span>
      </div>
      <Slider
        value={[value]}
        onValueChange={([newValue]) => onChange(newValue)}
        min={min}
        max={max}
        step={parameter.schema.multipleOf ?? 1}
        className="w-full"
      />
    </div>
  )
}
```

### Badge for Removable Filter Chips
```typescript
// Source: https://ui.shadcn.com/docs/components/badge
import { Badge } from "@/components/ui/badge"
import { X } from "lucide-react"  // Or use inline SVG

interface FilterChipProps {
  label: string
  value: string
  onRemove: () => void
}

export function FilterChip({ label, value, onRemove }: FilterChipProps) {
  return (
    <Badge variant="secondary" className="gap-1">
      <span className="text-xs">{label}: {value}</span>
      <button
        type="button"
        onClick={onRemove}
        className="ml-1 rounded-full hover:bg-muted"
      >
        <X className="h-3 w-3" />
      </button>
    </Badge>
  )
}
```

### Skeleton Loader for Loading State
```typescript
// Source: https://ui.shadcn.com/docs/components/radix/skeleton
// Option 1: Use shadcn Skeleton (consistent with shadcn/ui)
import { Skeleton } from "@/components/ui/skeleton"

export function FormSkeleton() {
  return (
    <div className="space-y-4">
      <Skeleton className="h-10 w-full" />
      <Skeleton className="h-10 w-full" />
      <Skeleton className="h-20 w-full" />
      <Skeleton className="h-10 w-32" />
    </div>
  )
}

// Option 2: Keep using react-loading-skeleton (already installed)
// Source: https://github.com/dvtng/react-loading-skeleton
import Skeleton from 'react-loading-skeleton'

export function FormSkeletonAlt() {
  return (
    <div className="space-y-4">
      <Skeleton height={40} />
      <Skeleton height={40} />
      <Skeleton height={80} />
      <Skeleton height={40} width={128} />
    </div>
  )
}
```

### Toast Notification with Sonner
```typescript
// Source: https://ui.shadcn.com/docs/components/sonner
import { toast } from "sonner"

// Show error toast on fetch failure
function handleFetchError(error: Error) {
  toast.error("Failed to fetch data", {
    description: error.message,
    duration: 5000,
  })
}

// Show success toast
function handleFetchSuccess() {
  toast.success("Data fetched successfully")
}

// In App.tsx or layout component, add Toaster:
import { Toaster } from "@/components/ui/sonner"

export function App() {
  return (
    <>
      <div>{/* app content */}</div>
      <Toaster />
    </>
  )
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| shadcn/ui individual @radix-ui/react-* packages | Unified radix-ui package | Feb 2026 | Cleaner package.json; single dependency instead of 10+ Radix packages |
| shadcn/ui Toast component | Sonner component | 2025-2026 | Toast deprecated; Sonner is now recommended for notifications |
| Manual ARIA attribute management | Radix UI primitive auto-handling | Always (Radix design) | Components accessible by default; manual ARIA often causes bugs |
| react-day-picker v8 | react-day-picker v9 | 2024 | Breaking change: `selected` now controlled prop requiring `onSelect` |
| Formik validateOnChange | Formik validateOnBlur default | 2026 best practices | Better UX; reduces error noise while typing |
| JavaScript sticky headers (Intersection Observer) | CSS position: sticky | 2020+ | Native browser feature; better performance; no layout flicker |
| document.execCommand('copy') | navigator.clipboard.writeText | 2020+ | Modern async API; better security; automatic fallback in libraries |

**Deprecated/outdated:**
- **shadcn/ui Toast component**: Replaced by Sonner; documentation now recommends Sonner for all toast use cases
- **Manual Radix UI package installation**: Use unified `radix-ui` package (new-york style) instead of individual `@radix-ui/react-*` packages
- **react-day-picker v8 uncontrolled mode**: v9 requires explicit `onSelect` handler; auto-controlled behavior removed

## Open Questions

Things that couldn't be fully resolved:

1. **Time picker styling consistency**
   - What we know: Native `<input type="time">` renders differently across browsers; some show 12h, others 24h format
   - What's unclear: Whether to build custom time picker for consistency or accept native variance
   - Recommendation: Start with native `<input type="time">` for Phase 11; can build custom in future phase if needed. Native is accessible and works on mobile.

2. **Skeleton loader migration strategy**
   - What we know: Project already uses react-loading-skeleton 3.5.0; shadcn/ui has its own Skeleton component
   - What's unclear: Whether to migrate existing skeletons to shadcn or keep both libraries
   - Recommendation: Add shadcn Skeleton for new components in Phase 11; migrate existing skeletons in future refactor phase to reduce dependencies.

3. **Form validation library adoption**
   - What we know: Phase requirements specify inline validation on blur; current form doesn't use validation library
   - What's unclear: Whether simple inline validation suffices or should adopt React Hook Form/Formik for consistency
   - Recommendation: Implement simple blur validation without library for Phase 11; if complexity grows (conditional validation, async checks), adopt React Hook Form in future phase.

4. **Array parameter display format**
   - What we know: Tag input is locked decision for array parameters; unclear how to serialize for URL query params
   - What's unclear: Comma-separated (`tags=a,b,c`) vs repeated params (`tags=a&tags=b&tags=c`) vs bracket notation (`tags[]=a&tags[]=b`)
   - Recommendation: Check OpenAPI spec `style` property for array parameters (default: `form` with comma-separated); allow override in parameter store.

## Sources

### Primary (HIGH confidence)
- shadcn/ui official documentation - https://ui.shadcn.com/docs
- shadcn/ui changelog (Feb 2026) - https://ui.shadcn.com/docs/changelog/2026-02-radix-ui
- react-day-picker official docs - https://daypicker.dev/
- react-day-picker time picker guide - https://daypicker.dev/guides/timepicker
- Radix UI accessibility documentation - https://www.radix-ui.com/primitives/docs/overview/accessibility
- shadcn/ui component docs:
  - Calendar: https://ui.shadcn.com/docs/components/calendar
  - Popover: https://ui.shadcn.com/docs/components/popover
  - Input: https://ui.shadcn.com/docs/components/input
  - Badge: https://ui.shadcn.com/docs/components/badge
  - Slider: https://ui.shadcn.com/docs/components/radix/slider
  - Sonner: https://ui.shadcn.com/docs/components/sonner
  - Skeleton: https://ui.shadcn.com/docs/components/radix/skeleton

### Secondary (MEDIUM confidence)
- Formik validateOnBlur best practices 2026 - https://copyprogramming.com/howto/formik-validate-on-blur-code-example
- React Form Validation with Formik and Yup (2026 Edition) - https://thelinuxcode.com/react-form-validation-with-formik-and-yup-2026-edition/
- React Hook Form async validation discussion - https://github.com/react-hook-form/react-hook-form/issues/1688
- Smarter Forms in React: useAutoSave Hook with Debounce - https://darius-marlowe.medium.com/smarter-forms-in-react-building-a-useautosave-hook-with-debounce-and-react-query-d4d7f9bb052e
- useLocalStorage React Hook - https://usehooks.com/uselocalstorage
- useCopyToClipboard React Hook - https://usehooks-ts.com/react-hook/use-copy-to-clipboard
- React sticky header best practices - https://blog.logrocket.com/using-react-hooks-to-create-sticky-headers/
- Tailwind CSS skeleton loaders - https://flowbite.com/docs/components/skeleton/
- Controlled vs Uncontrolled Components in React - https://blog.logrocket.com/controlled-vs-uncontrolled-components-in-react/

### Tertiary (LOW confidence - flagged for validation)
- MUI Autocomplete with chips (alternative approach) - https://mui.com/material-ui/react-autocomplete/
- React datepicker (alternative to react-day-picker) - https://reactdatepicker.com/
- OpenAPI form generation libraries (background research) - https://www.npmjs.com/package/openapi-form-generator

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Official shadcn/ui docs, verified current versions, Feb 2026 changelog confirms latest features
- Architecture: HIGH - Patterns verified against official component docs and community best practices from 2026 sources
- Pitfalls: MEDIUM-HIGH - Most pitfalls from official GitHub issues and documented problems; some from WebSearch community discussions

**Research date:** 2026-02-07
**Valid until:** 2026-03-07 (30 days - stable ecosystem; shadcn/ui mature but actively updated)

**Notes:**
- Project already has react-loading-skeleton installed; can coexist with shadcn Skeleton
- Project uses Headless UI (@headlessui/react); shadcn/ui uses Radix UI - both can coexist but prefer Radix going forward
- Tailwind CSS v4.1.18 already installed; shadcn/ui compatible
- React 19.2.0 installed; all researched libraries compatible with React 18+ including React 19
