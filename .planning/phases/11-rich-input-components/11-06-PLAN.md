---
phase: 11-rich-input-components
plan: 06
type: execute
wave: 3
depends_on: ["11-01", "11-04"]
files_modified:
  - src/components/forms/ParameterForm.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Text inputs require Apply button to trigger fetch"
    - "Select/toggle/checkbox changes trigger immediate re-fetch (debounced)"
    - "Chip removal triggers immediate re-fetch"
    - "Loading state shows skeleton loaders in results area"
    - "Error shows toast notification"
    - "Previous results remain visible during error"
    - "Toaster component renders in App.tsx"
  artifacts:
    - path: "src/components/forms/ParameterForm.tsx"
      provides: "Form with hybrid re-fetch behavior"
      exports: ["ParameterForm"]
  key_links:
    - from: "src/components/forms/ParameterForm.tsx"
      to: "debounce callback"
      via: "useEffect with timeout"
      pattern: "setTimeout.*300"
    - from: "src/App.tsx"
      to: "@/components/ui/sonner"
      via: "Toaster import"
      pattern: "import.*Toaster.*from.*@/components/ui"
---

<objective>
Implement hybrid re-fetch behavior and error toast notifications

Purpose: Text inputs need explicit Apply button while quick inputs (selects, toggles, chips) auto-fetch with debounce. Errors show as toast while keeping previous results visible.

Output: ParameterForm with hybrid fetch behavior and Toaster integration in App.tsx.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-rich-input-components/11-CONTEXT.md
@.planning/phases/11-rich-input-components/11-RESEARCH.md
@src/components/forms/ParameterForm.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Toaster to App.tsx</name>
  <files>
    src/App.tsx
  </files>
  <action>
Add Sonner's Toaster component to App.tsx for global toast notifications.

Add import at top:
```typescript
import { Toaster } from '@/components/ui/sonner'
```

Add Toaster at the end of the component (before closing fragment):
```typescript
function App() {
  // ... existing code ...

  return (
    <>
      {/* ... all existing JSX ... */}

      {/* Toast notifications */}
      <Toaster position="bottom-right" />
    </>
  )
}
```

This enables toast notifications anywhere in the app via:
```typescript
import { toast } from 'sonner'
toast.error('Error message')
toast.success('Success message')
```
  </action>
  <verify>
- `grep "import.*Toaster" src/App.tsx` shows import
- `grep "<Toaster" src/App.tsx` shows component usage
- `npm run build` succeeds
  </verify>
  <done>
Toaster component added to App.tsx for global toast notifications
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement hybrid re-fetch in ParameterForm</name>
  <files>
    src/components/forms/ParameterForm.tsx
  </files>
  <action>
Modify ParameterForm to support hybrid re-fetch behavior per CONTEXT.md:
- Text inputs need Apply button
- Selects, toggles, checkboxes, chip removals auto-fetch with 300ms debounce

Add import:
```typescript
import { toast } from 'sonner'
```

Add state to track which values are "quick" (auto-fetch) vs "manual" (need Apply):
```typescript
// Track version of quick values for debounce trigger
const [quickValuesVersion, setQuickValuesVersion] = useState(0)
```

Create handler for quick value changes (selects, checkboxes, etc.):
```typescript
const handleQuickChange = (name: string, value: string) => {
  setValues((prev) => ({ ...prev, [name]: value }))
  setQuickValuesVersion((v) => v + 1)  // Trigger debounced fetch
}

// For array parameters
const handleQuickArrayChange = (name: string, values: string[]) => {
  // Convert array to comma-separated for storage
  setValues((prev) => ({ ...prev, [name]: values.join(',') }))
  setQuickValuesVersion((v) => v + 1)  // Trigger debounced fetch
}
```

Add debounced auto-fetch effect:
```typescript
// Auto-fetch on quick value changes (debounced 300ms)
useEffect(() => {
  if (quickValuesVersion === 0) return  // Skip initial render

  const timer = setTimeout(() => {
    onSubmit(values)
  }, 300)

  return () => clearTimeout(timer)
}, [quickValuesVersion])  // Only trigger on version bump, not on values change
```

Update the props interface to support error callback:
```typescript
interface ParameterFormProps {
  // ... existing props ...
  onError?: (error: Error) => void  // For toast notifications
}
```

Modify how ParameterInput is rendered to distinguish quick vs manual inputs:

For enum selects and checkboxes, use handleQuickChange:
```typescript
<ParameterInput
  key={param.name}
  parameter={param}
  value={values[param.name] ?? ''}
  onChange={(value) => {
    // Check if this is a "quick" input type
    if (param.schema.enum || param.schema.type === 'boolean') {
      handleQuickChange(param.name, value)
    } else {
      handleChange(param.name, value)  // Manual - needs Apply
    }
  }}
  // ... rest of props
/>
```

For array parameters, use handleQuickArrayChange:
```typescript
onArrayChange={(values) => handleQuickArrayChange(param.name, values)}
```

Note: The actual values state update happens in both cases, but quickValuesVersion only bumps for quick inputs, triggering the debounced fetch.
  </action>
  <verify>
- `grep "quickValuesVersion" src/components/forms/ParameterForm.tsx` shows state
- `grep "setTimeout.*300" src/components/forms/ParameterForm.tsx` shows debounce
- `grep "handleQuickChange" src/components/forms/ParameterForm.tsx` shows handler
- `npm run build` succeeds
  </verify>
  <done>
Hybrid re-fetch behavior implemented with 300ms debounce for quick inputs
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error toast integration</name>
  <files>
    src/components/forms/ParameterForm.tsx
  </files>
  <action>
The actual error handling happens in the parent (App.tsx) which calls onSubmit. But we should show errors as toasts per CONTEXT.md.

Modify App.tsx to show toast on fetch error:

In the existing error handling (where error state is set), add toast:
```typescript
import { toast } from 'sonner'

// In handleParameterSubmit or wherever fetch errors are caught:
try {
  await fetchOperation(...)
} catch (err) {
  toast.error('Failed to fetch data', {
    description: err instanceof Error ? err.message : 'Unknown error',
    duration: 5000,
  })
}
```

Actually, looking at the current App.tsx, errors are managed via useAppStore. Modify useAPIFetch hook or App.tsx to show toast on error.

The cleanest approach is to add a useEffect in App.tsx that shows toast when error changes:

```typescript
// In App.tsx, add:
import { toast } from 'sonner'

// Add effect to show toast on error
useEffect(() => {
  if (error) {
    toast.error('Failed to fetch data', {
      description: error,
      duration: 5000,
    })
  }
}, [error])
```

This keeps error toast decoupled from fetch logic and works with the existing error state management.

Per CONTEXT.md: "On error: keep previous results visible, show error toast"
The existing ErrorDisplay component can remain for persistent error display, but we add toast for immediate feedback.
  </action>
  <verify>
- `grep "toast.error" src/App.tsx` shows toast on error
- `grep "useEffect.*error" src/App.tsx` shows error effect
- `npm run build` succeeds
- `npm run dev` shows toast on fetch error
  </verify>
  <done>
Error toast notifications integrated with existing error state
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run `npm run build` - should succeed
2. Run `npm run dev` and test:
   - Type in text input, verify no fetch until Apply clicked
   - Change a select dropdown, verify fetch after ~300ms
   - Toggle a checkbox, verify fetch after ~300ms
   - Cause a fetch error, verify toast appears
3. Verify Toaster renders in DOM (inspect element)
4. Verify 300ms debounce timing
</verification>

<success_criteria>
- Toaster component renders in App.tsx
- Text inputs require Apply button
- Select/toggle changes trigger debounced fetch
- 300ms debounce on quick inputs
- Error shows toast notification
- Toast appears bottom-right (per Toaster position)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/11-rich-input-components/11-06-SUMMARY.md`
</output>
