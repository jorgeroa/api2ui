---
phase: 11-rich-input-components
plan: 05
type: execute
wave: 3
depends_on: ["11-02", "11-03"]
files_modified:
  - src/components/forms/ParameterInput.tsx
autonomous: true

must_haves:
  truths:
    - "Date parameters render DateTimePicker instead of native input"
    - "Datetime parameters render DateTimePicker with time input"
    - "Array parameters render TagInput"
    - "Numeric parameters with min/max render RangeSlider"
    - "Enum array parameters render EnumCheckboxGroup"
    - "Inline validation shows error on blur"
    - "Validation clears when user starts typing"
  artifacts:
    - path: "src/components/forms/ParameterInput.tsx"
      provides: "Enhanced parameter input with rich components"
      exports: ["ParameterInput"]
  key_links:
    - from: "src/components/forms/ParameterInput.tsx"
      to: "src/components/forms/DateTimePicker.tsx"
      via: "conditional render for date type"
      pattern: "DateTimePicker"
    - from: "src/components/forms/ParameterInput.tsx"
      to: "src/components/forms/TagInput.tsx"
      via: "conditional render for array type"
      pattern: "TagInput"
    - from: "src/components/forms/ParameterInput.tsx"
      to: "src/components/forms/RangeSlider.tsx"
      via: "conditional render for numeric with bounds"
      pattern: "RangeSlider"
---

<objective>
Integrate rich input components into ParameterInput with inline validation

Purpose: Replace basic HTML inputs with DateTimePicker, TagInput, RangeSlider, and EnumCheckboxGroup based on parameter schema. Add blur validation for all inputs.

Output: ParameterInput component that automatically selects the appropriate rich input based on parameter type and schema.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-rich-input-components/11-CONTEXT.md
@.planning/phases/11-rich-input-components/11-RESEARCH.md
@src/components/forms/ParameterInput.tsx
@src/components/forms/DateTimePicker.tsx
@src/components/forms/TagInput.tsx
@src/components/forms/RangeSlider.tsx
@src/components/forms/EnumCheckboxGroup.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add inline validation to ParameterInput</name>
  <files>
    src/components/forms/ParameterInput.tsx
  </files>
  <action>
First, add validation state and handlers to ParameterInput. The validation should:
- Trigger on blur (not on change) per CONTEXT.md
- Clear error when user starts typing (if previously touched)
- Support custom validation function prop

Add at the top of the component (after existing props destructuring):

```typescript
// Add to imports
import { useState } from 'react'

// Add to ParameterInputProps interface
interface ParameterInputProps {
  // ... existing props ...
  validate?: (value: string) => string | null  // Optional validation function
}

// Add inside component
const [error, setError] = useState<string | null>(null)
const [touched, setTouched] = useState(false)

// Validation handler for blur
const handleBlur = () => {
  setTouched(true)
  if (validate) {
    const validationError = validate(value)
    setError(validationError)
  } else if (required && !value) {
    setError('This field is required')
  }
}

// Modified change handler
const handleChange = (newValue: string) => {
  onChange(newValue)
  // Clear error when typing (if previously touched)
  if (touched && error) {
    setError(null)
  }
}
```

Then modify the input rendering to use handleBlur and handleChange, and show error state:

```typescript
// In renderInput(), add onBlur to all text-like inputs:
<input
  type="text"
  value={value}
  onChange={(e) => handleChange(e.target.value)}
  onBlur={handleBlur}
  // ... rest of props
  className={`${baseClasses} ${error ? 'border-red-500 focus:ring-red-500' : ''}`}
/>

// Add error display after the input container:
{error && touched && (
  <p className="text-sm text-red-500 mt-1">{error}</p>
)}
```

Apply blur handler to: text, number, email, url, date (native), coordinates, zip inputs.
Do NOT apply to: checkbox (no blur needed), select (no blur needed).
  </action>
  <verify>
- `grep "onBlur" src/components/forms/ParameterInput.tsx` shows blur handlers
- `grep "error.*touched" src/components/forms/ParameterInput.tsx` shows error display
- `grep "handleBlur" src/components/forms/ParameterInput.tsx` shows blur function
- `npm run build` succeeds
  </verify>
  <done>
Inline validation on blur added to ParameterInput
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate rich input components</name>
  <files>
    src/components/forms/ParameterInput.tsx
  </files>
  <action>
Now integrate the new rich input components. Add imports at top:

```typescript
import { DateTimePicker } from './DateTimePicker'
import { TagInput } from './TagInput'
import { RangeSlider, shouldUseSlider } from './RangeSlider'
import { EnumCheckboxGroup, shouldUseEnumCheckboxGroup, getEnumOptions } from './EnumCheckboxGroup'
```

Modify the props interface to support array values:

```typescript
interface ParameterInputProps {
  parameter: ParsedParameter
  value: string                    // Keep for single values
  arrayValue?: string[]            // New: for array parameters
  onChange: (value: string) => void
  onArrayChange?: (values: string[]) => void  // New: for array parameters
  // ... rest of props
}
```

In renderInput(), add these cases BEFORE the existing type checks (priority order):

```typescript
const renderInput = () => {
  const baseClasses = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500'
  const errorClasses = error ? 'border-red-500 focus:ring-red-500 focus:border-red-500' : ''

  // 1. Enum array → EnumCheckboxGroup
  if (shouldUseEnumCheckboxGroup(schema) && onArrayChange) {
    return (
      <EnumCheckboxGroup
        value={arrayValue ?? []}
        onChange={onArrayChange}
        options={getEnumOptions(schema)}
        label={name}
      />
    )
  }

  // 2. Array type → TagInput
  if ((schema.type === 'array' || parameter.isArray) && onArrayChange) {
    return (
      <TagInput
        value={arrayValue ?? []}
        onChange={onArrayChange}
        maxItems={schema.maxItems}
        placeholder={`Add ${name}...`}
      />
    )
  }

  // 3. Numeric with min/max → RangeSlider
  if (shouldUseSlider(schema)) {
    const numValue = value ? parseFloat(value) : schema.minimum ?? 0
    return (
      <RangeSlider
        value={numValue}
        onChange={(v) => onChange(String(v))}
        min={schema.minimum!}
        max={schema.maximum!}
        step={schema.type === 'integer' ? 1 : 0.1}
        label={name}
      />
    )
  }

  // 4. Date format → DateTimePicker (without time)
  if (schema.format === 'date' || effectiveType === 'date') {
    return (
      <DateTimePicker
        value={value}
        onChange={onChange}
        includeTime={false}
        placeholder={`Select ${name}`}
        required={required}
      />
    )
  }

  // 5. DateTime format → DateTimePicker (with time)
  if (schema.format === 'date-time') {
    return (
      <DateTimePicker
        value={value}
        onChange={onChange}
        includeTime={true}
        placeholder={`Select ${name}`}
        required={required}
      />
    )
  }

  // ... existing enum/checkbox/number/text cases continue below ...
```

Update the existing effectiveType cases to include blur handler:

For each text-like input (text, number, email, url, etc.), add:
- `onChange={(e) => handleChange(e.target.value)}`
- `onBlur={handleBlur}`
- `className={\`${baseClasses} ${errorClasses}\`}`
  </action>
  <verify>
- `grep "import.*DateTimePicker" src/components/forms/ParameterInput.tsx` shows import
- `grep "import.*TagInput" src/components/forms/ParameterInput.tsx` shows import
- `grep "import.*RangeSlider" src/components/forms/ParameterInput.tsx` shows import
- `grep "shouldUseSlider" src/components/forms/ParameterInput.tsx` shows usage
- `grep "onArrayChange" src/components/forms/ParameterInput.tsx` shows array prop
- `npm run build` succeeds
  </verify>
  <done>
Rich input components integrated into ParameterInput with type-based selection
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run `npm run build` - should succeed
2. Verify ParameterInput imports all new components
3. Verify component selection logic:
   - Enum arrays → EnumCheckboxGroup
   - Arrays → TagInput
   - Numbers with min/max → RangeSlider
   - Dates → DateTimePicker (without time)
   - DateTimes → DateTimePicker (with time)
4. Verify blur validation on text inputs
5. Run `npm run dev` and manually test if desired
</verification>

<success_criteria>
- Date parameters show calendar picker
- Datetime parameters show calendar + time
- Array parameters show tag input
- Numeric parameters with bounds show slider
- Enum arrays show checkbox group
- Blur on text inputs triggers validation
- Required field shows error if empty on blur
- Error clears when user types
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/11-rich-input-components/11-05-SUMMARY.md`
</output>
