---
phase: 11-rich-input-components
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/components/forms/RangeSlider.tsx
  - src/components/forms/EnumCheckboxGroup.tsx
autonomous: true

must_haves:
  truths:
    - "RangeSlider shows current value above slider track"
    - "RangeSlider shows min/max at ends of track"
    - "RangeSlider only renders when min AND max are provided"
    - "EnumCheckboxGroup renders checkbox for each enum option"
    - "EnumCheckboxGroup tracks multiple selections"
    - "Checkbox selections persist in string[] value"
  artifacts:
    - path: "src/components/forms/RangeSlider.tsx"
      provides: "Numeric slider for bounded ranges"
      exports: ["RangeSlider"]
    - path: "src/components/forms/EnumCheckboxGroup.tsx"
      provides: "Grouped checkboxes for enum arrays"
      exports: ["EnumCheckboxGroup"]
  key_links:
    - from: "src/components/forms/RangeSlider.tsx"
      to: "@/components/ui/slider"
      via: "Slider component import"
      pattern: "import.*Slider.*from.*@/components/ui"
---

<objective>
Create RangeSlider and EnumCheckboxGroup components for specialized input types

Purpose: Provide slider for numeric parameters with known bounds and checkbox group for enum array parameters. Per CONTEXT.md, sliders only appear when min/max are explicit.

Output: Two new form components ready for integration with ParameterForm.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-rich-input-components/11-CONTEXT.md
@.planning/phases/11-rich-input-components/11-RESEARCH.md
@src/components/forms/ParameterInput.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RangeSlider component</name>
  <files>
    src/components/forms/RangeSlider.tsx
  </files>
  <action>
Create RangeSlider component following CONTEXT.md decision (only show when min/max explicit):

```typescript
import { Slider } from '@/components/ui/slider'

interface RangeSliderProps {
  value: number
  onChange: (value: number) => void
  min: number
  max: number
  step?: number
  label: string
}

export function RangeSlider({
  value,
  onChange,
  min,
  max,
  step = 1,
  label,
}: RangeSliderProps) {
  return (
    <div className="space-y-3">
      {/* Label and current value */}
      <div className="flex justify-between items-center">
        <label className="text-sm font-medium text-gray-700">{label}</label>
        <span className="text-sm font-medium text-blue-600 bg-blue-50 px-2 py-0.5 rounded">
          {value}
        </span>
      </div>

      {/* Slider track */}
      <Slider
        value={[value]}
        onValueChange={([newValue]) => {
          if (newValue !== undefined) {
            onChange(newValue)
          }
        }}
        min={min}
        max={max}
        step={step}
        className="w-full"
      />

      {/* Min/max labels */}
      <div className="flex justify-between text-xs text-gray-500">
        <span>{min}</span>
        <span>{max}</span>
      </div>
    </div>
  )
}

/**
 * Helper to check if a parameter should use RangeSlider.
 * Only returns true if BOTH min and max are explicitly defined.
 */
export function shouldUseSlider(schema: {
  minimum?: number
  maximum?: number
  type?: string
}): boolean {
  return (
    schema.minimum !== undefined &&
    schema.maximum !== undefined &&
    (schema.type === 'integer' || schema.type === 'number')
  )
}
```

Key implementation notes:
- Only renders when min/max are both provided (caller responsibility, but helper exported)
- Current value shown above slider (CONTEXT.md decision)
- Min/max shown at ends of track
- Uses shadcn Slider component
- Handles step for integers vs floats
  </action>
  <verify>
- `cat src/components/forms/RangeSlider.tsx` shows component
- `grep "import.*Slider" src/components/forms/RangeSlider.tsx` shows Slider import
- `grep "shouldUseSlider" src/components/forms/RangeSlider.tsx` shows helper function
- `npm run build` succeeds
  </verify>
  <done>
RangeSlider component created with value display and min/max labels
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EnumCheckboxGroup component</name>
  <files>
    src/components/forms/EnumCheckboxGroup.tsx
  </files>
  <action>
Create EnumCheckboxGroup for enum array parameters (FORM-06):

```typescript
interface EnumCheckboxGroupProps {
  value: string[]
  onChange: (value: string[]) => void
  options: string[]
  label: string
}

export function EnumCheckboxGroup({
  value,
  onChange,
  options,
  label,
}: EnumCheckboxGroupProps) {
  const handleToggle = (option: string) => {
    if (value.includes(option)) {
      // Remove
      onChange(value.filter((v) => v !== option))
    } else {
      // Add
      onChange([...value, option])
    }
  }

  return (
    <fieldset className="space-y-2">
      <legend className="text-sm font-medium text-gray-700">{label}</legend>
      <div className="space-y-2">
        {options.map((option) => (
          <label
            key={option}
            className="flex items-center gap-2 cursor-pointer group"
          >
            <input
              type="checkbox"
              checked={value.includes(option)}
              onChange={() => handleToggle(option)}
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            />
            <span className="text-sm text-gray-700 group-hover:text-gray-900">
              {option}
            </span>
          </label>
        ))}
      </div>
      {/* Selection count */}
      {value.length > 0 && (
        <p className="text-xs text-gray-500">
          {value.length} of {options.length} selected
        </p>
      )}
    </fieldset>
  )
}

/**
 * Helper to check if a parameter should use EnumCheckboxGroup.
 * Returns true if schema has enum AND type is array.
 */
export function shouldUseEnumCheckboxGroup(schema: {
  type?: string
  enum?: unknown[]
  items?: { enum?: unknown[] }
}): boolean {
  // Array of enum values
  if (schema.type === 'array' && schema.items?.enum && schema.items.enum.length > 0) {
    return true
  }
  return false
}

/**
 * Get enum options from schema.
 */
export function getEnumOptions(schema: {
  items?: { enum?: unknown[] }
}): string[] {
  if (schema.items?.enum) {
    return schema.items.enum.map(String)
  }
  return []
}
```

Key implementation notes:
- Checkbox group with toggle behavior
- Shows selection count
- Helpers for schema detection
- Uses native checkboxes (not shadcn - simpler for this use case)
- Fieldset/legend for accessibility
  </action>
  <verify>
- `cat src/components/forms/EnumCheckboxGroup.tsx` shows component
- `grep "shouldUseEnumCheckboxGroup" src/components/forms/EnumCheckboxGroup.tsx` shows helper
- `grep "fieldset" src/components/forms/EnumCheckboxGroup.tsx` shows accessible markup
- `npm run build` succeeds
  </verify>
  <done>
EnumCheckboxGroup component created with toggle behavior and selection count
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run `npm run build` - should succeed
2. Verify both components exist:
   - src/components/forms/RangeSlider.tsx
   - src/components/forms/EnumCheckboxGroup.tsx
3. Verify RangeSlider uses shadcn Slider
4. Verify helper functions exported for schema detection
5. Verify EnumCheckboxGroup uses proper fieldset/legend
</verification>

<success_criteria>
- RangeSlider displays current value above track
- RangeSlider shows min/max at ends
- RangeSlider uses shadcn Slider component
- EnumCheckboxGroup renders checkbox per option
- EnumCheckboxGroup tracks selections in string[]
- Helper functions detect when to use each component
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/11-rich-input-components/11-03-SUMMARY.md`
</output>
